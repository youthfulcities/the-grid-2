/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/fast-xml-parser";
exports.ids = ["vendor-chunks/fast-xml-parser"];
exports.modules = {

/***/ "(ssr)/./node_modules/fast-xml-parser/src/fxp.js":
/*!*************************************************!*\
  !*** ./node_modules/fast-xml-parser/src/fxp.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst validator = __webpack_require__(/*! ./validator */ \"(ssr)/./node_modules/fast-xml-parser/src/validator.js\");\nconst XMLParser = __webpack_require__(/*! ./xmlparser/XMLParser */ \"(ssr)/./node_modules/fast-xml-parser/src/xmlparser/XMLParser.js\");\nconst XMLBuilder = __webpack_require__(/*! ./xmlbuilder/json2xml */ \"(ssr)/./node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js\");\nmodule.exports = {\n    XMLParser: XMLParser,\n    XMLValidator: validator,\n    XMLBuilder: XMLBuilder\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmFzdC14bWwtcGFyc2VyL3NyYy9meHAuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNQSxZQUFZQyxtQkFBT0EsQ0FBQztBQUMxQixNQUFNQyxZQUFZRCxtQkFBT0EsQ0FBQztBQUMxQixNQUFNRSxhQUFhRixtQkFBT0EsQ0FBQztBQUUzQkcsT0FBT0MsT0FBTyxHQUFHO0lBQ2ZILFdBQVdBO0lBQ1hJLGNBQWNOO0lBQ2RHLFlBQVlBO0FBQ2QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90aGUtZ3JpZC0yLy4vbm9kZV9tb2R1bGVzL2Zhc3QteG1sLXBhcnNlci9zcmMvZnhwLmpzP2MzZTgiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB2YWxpZGF0b3IgPSByZXF1aXJlKCcuL3ZhbGlkYXRvcicpO1xuY29uc3QgWE1MUGFyc2VyID0gcmVxdWlyZSgnLi94bWxwYXJzZXIvWE1MUGFyc2VyJyk7XG5jb25zdCBYTUxCdWlsZGVyID0gcmVxdWlyZSgnLi94bWxidWlsZGVyL2pzb24yeG1sJyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBYTUxQYXJzZXI6IFhNTFBhcnNlcixcbiAgWE1MVmFsaWRhdG9yOiB2YWxpZGF0b3IsXG4gIFhNTEJ1aWxkZXI6IFhNTEJ1aWxkZXJcbn0iXSwibmFtZXMiOlsidmFsaWRhdG9yIiwicmVxdWlyZSIsIlhNTFBhcnNlciIsIlhNTEJ1aWxkZXIiLCJtb2R1bGUiLCJleHBvcnRzIiwiWE1MVmFsaWRhdG9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/fast-xml-parser/src/fxp.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/fast-xml-parser/src/util.js":
/*!**************************************************!*\
  !*** ./node_modules/fast-xml-parser/src/util.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nconst nameStartChar = \":A-Za-z_\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\";\nconst nameChar = nameStartChar + \"\\\\-.\\\\d\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040\";\nconst nameRegexp = \"[\" + nameStartChar + \"][\" + nameChar + \"]*\";\nconst regexName = new RegExp(\"^\" + nameRegexp + \"$\");\nconst getAllMatches = function(string, regex) {\n    const matches = [];\n    let match = regex.exec(string);\n    while(match){\n        const allmatches = [];\n        allmatches.startIndex = regex.lastIndex - match[0].length;\n        const len = match.length;\n        for(let index = 0; index < len; index++){\n            allmatches.push(match[index]);\n        }\n        matches.push(allmatches);\n        match = regex.exec(string);\n    }\n    return matches;\n};\nconst isName = function(string) {\n    const match = regexName.exec(string);\n    return !(match === null || typeof match === \"undefined\");\n};\nexports.isExist = function(v) {\n    return typeof v !== \"undefined\";\n};\nexports.isEmptyObject = function(obj) {\n    return Object.keys(obj).length === 0;\n};\n/**\n * Copy all the properties of a into b.\n * @param {*} target\n * @param {*} a\n */ exports.merge = function(target, a, arrayMode) {\n    if (a) {\n        const keys = Object.keys(a); // will return an array of own properties\n        const len = keys.length; //don't make it inline\n        for(let i = 0; i < len; i++){\n            if (arrayMode === \"strict\") {\n                target[keys[i]] = [\n                    a[keys[i]]\n                ];\n            } else {\n                target[keys[i]] = a[keys[i]];\n            }\n        }\n    }\n};\n/* exports.merge =function (b,a){\n  return Object.assign(b,a);\n} */ exports.getValue = function(v) {\n    if (exports.isExist(v)) {\n        return v;\n    } else {\n        return \"\";\n    }\n};\n// const fakeCall = function(a) {return a;};\n// const fakeCallNoReturn = function() {};\nexports.isName = isName;\nexports.getAllMatches = getAllMatches;\nexports.nameRegexp = nameRegexp;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmFzdC14bWwtcGFyc2VyL3NyYy91dGlsLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTUEsZ0JBQWdCO0FBQ3RCLE1BQU1DLFdBQVdELGdCQUFnQjtBQUNqQyxNQUFNRSxhQUFhLE1BQU1GLGdCQUFnQixPQUFPQyxXQUFXO0FBQzNELE1BQU1FLFlBQVksSUFBSUMsT0FBTyxNQUFNRixhQUFhO0FBRWhELE1BQU1HLGdCQUFnQixTQUFTQyxNQUFNLEVBQUVDLEtBQUs7SUFDMUMsTUFBTUMsVUFBVSxFQUFFO0lBQ2xCLElBQUlDLFFBQVFGLE1BQU1HLElBQUksQ0FBQ0o7SUFDdkIsTUFBT0csTUFBTztRQUNaLE1BQU1FLGFBQWEsRUFBRTtRQUNyQkEsV0FBV0MsVUFBVSxHQUFHTCxNQUFNTSxTQUFTLEdBQUdKLEtBQUssQ0FBQyxFQUFFLENBQUNLLE1BQU07UUFDekQsTUFBTUMsTUFBTU4sTUFBTUssTUFBTTtRQUN4QixJQUFLLElBQUlFLFFBQVEsR0FBR0EsUUFBUUQsS0FBS0MsUUFBUztZQUN4Q0wsV0FBV00sSUFBSSxDQUFDUixLQUFLLENBQUNPLE1BQU07UUFDOUI7UUFDQVIsUUFBUVMsSUFBSSxDQUFDTjtRQUNiRixRQUFRRixNQUFNRyxJQUFJLENBQUNKO0lBQ3JCO0lBQ0EsT0FBT0U7QUFDVDtBQUVBLE1BQU1VLFNBQVMsU0FBU1osTUFBTTtJQUM1QixNQUFNRyxRQUFRTixVQUFVTyxJQUFJLENBQUNKO0lBQzdCLE9BQU8sQ0FBRUcsQ0FBQUEsVUFBVSxRQUFRLE9BQU9BLFVBQVUsV0FBVTtBQUN4RDtBQUVBVSxlQUFlLEdBQUcsU0FBU0UsQ0FBQztJQUMxQixPQUFPLE9BQU9BLE1BQU07QUFDdEI7QUFFQUYscUJBQXFCLEdBQUcsU0FBU0ksR0FBRztJQUNsQyxPQUFPQyxPQUFPQyxJQUFJLENBQUNGLEtBQUtULE1BQU0sS0FBSztBQUNyQztBQUVBOzs7O0NBSUMsR0FDREssYUFBYSxHQUFHLFNBQVNRLE1BQU0sRUFBRUMsQ0FBQyxFQUFFQyxTQUFTO0lBQzNDLElBQUlELEdBQUc7UUFDTCxNQUFNSCxPQUFPRCxPQUFPQyxJQUFJLENBQUNHLElBQUkseUNBQXlDO1FBQ3RFLE1BQU1iLE1BQU1VLEtBQUtYLE1BQU0sRUFBRSxzQkFBc0I7UUFDL0MsSUFBSyxJQUFJZ0IsSUFBSSxHQUFHQSxJQUFJZixLQUFLZSxJQUFLO1lBQzVCLElBQUlELGNBQWMsVUFBVTtnQkFDMUJGLE1BQU0sQ0FBQ0YsSUFBSSxDQUFDSyxFQUFFLENBQUMsR0FBRztvQkFBRUYsQ0FBQyxDQUFDSCxJQUFJLENBQUNLLEVBQUUsQ0FBQztpQkFBRTtZQUNsQyxPQUFPO2dCQUNMSCxNQUFNLENBQUNGLElBQUksQ0FBQ0ssRUFBRSxDQUFDLEdBQUdGLENBQUMsQ0FBQ0gsSUFBSSxDQUFDSyxFQUFFLENBQUM7WUFDOUI7UUFDRjtJQUNGO0FBQ0Y7QUFDQTs7RUFFRSxHQUVGWCxnQkFBZ0IsR0FBRyxTQUFTRSxDQUFDO0lBQzNCLElBQUlGLFFBQVFDLE9BQU8sQ0FBQ0MsSUFBSTtRQUN0QixPQUFPQTtJQUNULE9BQU87UUFDTCxPQUFPO0lBQ1Q7QUFDRjtBQUVBLDRDQUE0QztBQUM1QywwQ0FBMEM7QUFFMUNGLGNBQWMsR0FBR0Q7QUFDakJDLHFCQUFxQixHQUFHZDtBQUN4QmMsa0JBQWtCLEdBQUdqQiIsInNvdXJjZXMiOlsid2VicGFjazovL3RoZS1ncmlkLTIvLi9ub2RlX21vZHVsZXMvZmFzdC14bWwtcGFyc2VyL3NyYy91dGlsLmpzPzljZTAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBuYW1lU3RhcnRDaGFyID0gJzpBLVphLXpfXFxcXHUwMEMwLVxcXFx1MDBENlxcXFx1MDBEOC1cXFxcdTAwRjZcXFxcdTAwRjgtXFxcXHUwMkZGXFxcXHUwMzcwLVxcXFx1MDM3RFxcXFx1MDM3Ri1cXFxcdTFGRkZcXFxcdTIwMEMtXFxcXHUyMDBEXFxcXHUyMDcwLVxcXFx1MjE4RlxcXFx1MkMwMC1cXFxcdTJGRUZcXFxcdTMwMDEtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRkQnO1xuY29uc3QgbmFtZUNoYXIgPSBuYW1lU3RhcnRDaGFyICsgJ1xcXFwtLlxcXFxkXFxcXHUwMEI3XFxcXHUwMzAwLVxcXFx1MDM2RlxcXFx1MjAzRi1cXFxcdTIwNDAnO1xuY29uc3QgbmFtZVJlZ2V4cCA9ICdbJyArIG5hbWVTdGFydENoYXIgKyAnXVsnICsgbmFtZUNoYXIgKyAnXSonXG5jb25zdCByZWdleE5hbWUgPSBuZXcgUmVnRXhwKCdeJyArIG5hbWVSZWdleHAgKyAnJCcpO1xuXG5jb25zdCBnZXRBbGxNYXRjaGVzID0gZnVuY3Rpb24oc3RyaW5nLCByZWdleCkge1xuICBjb25zdCBtYXRjaGVzID0gW107XG4gIGxldCBtYXRjaCA9IHJlZ2V4LmV4ZWMoc3RyaW5nKTtcbiAgd2hpbGUgKG1hdGNoKSB7XG4gICAgY29uc3QgYWxsbWF0Y2hlcyA9IFtdO1xuICAgIGFsbG1hdGNoZXMuc3RhcnRJbmRleCA9IHJlZ2V4Lmxhc3RJbmRleCAtIG1hdGNoWzBdLmxlbmd0aDtcbiAgICBjb25zdCBsZW4gPSBtYXRjaC5sZW5ndGg7XG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGxlbjsgaW5kZXgrKykge1xuICAgICAgYWxsbWF0Y2hlcy5wdXNoKG1hdGNoW2luZGV4XSk7XG4gICAgfVxuICAgIG1hdGNoZXMucHVzaChhbGxtYXRjaGVzKTtcbiAgICBtYXRjaCA9IHJlZ2V4LmV4ZWMoc3RyaW5nKTtcbiAgfVxuICByZXR1cm4gbWF0Y2hlcztcbn07XG5cbmNvbnN0IGlzTmFtZSA9IGZ1bmN0aW9uKHN0cmluZykge1xuICBjb25zdCBtYXRjaCA9IHJlZ2V4TmFtZS5leGVjKHN0cmluZyk7XG4gIHJldHVybiAhKG1hdGNoID09PSBudWxsIHx8IHR5cGVvZiBtYXRjaCA9PT0gJ3VuZGVmaW5lZCcpO1xufTtcblxuZXhwb3J0cy5pc0V4aXN0ID0gZnVuY3Rpb24odikge1xuICByZXR1cm4gdHlwZW9mIHYgIT09ICd1bmRlZmluZWQnO1xufTtcblxuZXhwb3J0cy5pc0VtcHR5T2JqZWN0ID0gZnVuY3Rpb24ob2JqKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhvYmopLmxlbmd0aCA9PT0gMDtcbn07XG5cbi8qKlxuICogQ29weSBhbGwgdGhlIHByb3BlcnRpZXMgb2YgYSBpbnRvIGIuXG4gKiBAcGFyYW0geyp9IHRhcmdldFxuICogQHBhcmFtIHsqfSBhXG4gKi9cbmV4cG9ydHMubWVyZ2UgPSBmdW5jdGlvbih0YXJnZXQsIGEsIGFycmF5TW9kZSkge1xuICBpZiAoYSkge1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhhKTsgLy8gd2lsbCByZXR1cm4gYW4gYXJyYXkgb2Ygb3duIHByb3BlcnRpZXNcbiAgICBjb25zdCBsZW4gPSBrZXlzLmxlbmd0aDsgLy9kb24ndCBtYWtlIGl0IGlubGluZVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmIChhcnJheU1vZGUgPT09ICdzdHJpY3QnKSB7XG4gICAgICAgIHRhcmdldFtrZXlzW2ldXSA9IFsgYVtrZXlzW2ldXSBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFyZ2V0W2tleXNbaV1dID0gYVtrZXlzW2ldXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG4vKiBleHBvcnRzLm1lcmdlID1mdW5jdGlvbiAoYixhKXtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oYixhKTtcbn0gKi9cblxuZXhwb3J0cy5nZXRWYWx1ZSA9IGZ1bmN0aW9uKHYpIHtcbiAgaWYgKGV4cG9ydHMuaXNFeGlzdCh2KSkge1xuICAgIHJldHVybiB2O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAnJztcbiAgfVxufTtcblxuLy8gY29uc3QgZmFrZUNhbGwgPSBmdW5jdGlvbihhKSB7cmV0dXJuIGE7fTtcbi8vIGNvbnN0IGZha2VDYWxsTm9SZXR1cm4gPSBmdW5jdGlvbigpIHt9O1xuXG5leHBvcnRzLmlzTmFtZSA9IGlzTmFtZTtcbmV4cG9ydHMuZ2V0QWxsTWF0Y2hlcyA9IGdldEFsbE1hdGNoZXM7XG5leHBvcnRzLm5hbWVSZWdleHAgPSBuYW1lUmVnZXhwO1xuIl0sIm5hbWVzIjpbIm5hbWVTdGFydENoYXIiLCJuYW1lQ2hhciIsIm5hbWVSZWdleHAiLCJyZWdleE5hbWUiLCJSZWdFeHAiLCJnZXRBbGxNYXRjaGVzIiwic3RyaW5nIiwicmVnZXgiLCJtYXRjaGVzIiwibWF0Y2giLCJleGVjIiwiYWxsbWF0Y2hlcyIsInN0YXJ0SW5kZXgiLCJsYXN0SW5kZXgiLCJsZW5ndGgiLCJsZW4iLCJpbmRleCIsInB1c2giLCJpc05hbWUiLCJleHBvcnRzIiwiaXNFeGlzdCIsInYiLCJpc0VtcHR5T2JqZWN0Iiwib2JqIiwiT2JqZWN0Iiwia2V5cyIsIm1lcmdlIiwidGFyZ2V0IiwiYSIsImFycmF5TW9kZSIsImkiLCJnZXRWYWx1ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/fast-xml-parser/src/util.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/fast-xml-parser/src/validator.js":
/*!*******************************************************!*\
  !*** ./node_modules/fast-xml-parser/src/validator.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nconst util = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/fast-xml-parser/src/util.js\");\nconst defaultOptions = {\n    allowBooleanAttributes: false,\n    unpairedTags: []\n};\n//const tagsPattern = new RegExp(\"<\\\\/?([\\\\w:\\\\-_\\.]+)\\\\s*\\/?>\",\"g\");\nexports.validate = function(xmlData, options) {\n    options = Object.assign({}, defaultOptions, options);\n    //xmlData = xmlData.replace(/(\\r\\n|\\n|\\r)/gm,\"\");//make it single line\n    //xmlData = xmlData.replace(/(^\\s*<\\?xml.*?\\?>)/g,\"\");//Remove XML starting tag\n    //xmlData = xmlData.replace(/(<!DOCTYPE[\\s\\w\\\"\\.\\/\\-\\:]+(\\[.*\\])*\\s*>)/g,\"\");//Remove DOCTYPE\n    const tags = [];\n    let tagFound = false;\n    //indicates that the root tag has been closed (aka. depth 0 has been reached)\n    let reachedRoot = false;\n    if (xmlData[0] === \"\\uFEFF\") {\n        // check for byte order mark (BOM)\n        xmlData = xmlData.substr(1);\n    }\n    for(let i = 0; i < xmlData.length; i++){\n        if (xmlData[i] === \"<\" && xmlData[i + 1] === \"?\") {\n            i += 2;\n            i = readPI(xmlData, i);\n            if (i.err) return i;\n        } else if (xmlData[i] === \"<\") {\n            //starting of tag\n            //read until you reach to '>' avoiding any '>' in attribute value\n            let tagStartPos = i;\n            i++;\n            if (xmlData[i] === \"!\") {\n                i = readCommentAndCDATA(xmlData, i);\n                continue;\n            } else {\n                let closingTag = false;\n                if (xmlData[i] === \"/\") {\n                    //closing tag\n                    closingTag = true;\n                    i++;\n                }\n                //read tagname\n                let tagName = \"\";\n                for(; i < xmlData.length && xmlData[i] !== \">\" && xmlData[i] !== \" \" && xmlData[i] !== \"\t\" && xmlData[i] !== \"\\n\" && xmlData[i] !== \"\\r\"; i++){\n                    tagName += xmlData[i];\n                }\n                tagName = tagName.trim();\n                //console.log(tagName);\n                if (tagName[tagName.length - 1] === \"/\") {\n                    //self closing tag without attributes\n                    tagName = tagName.substring(0, tagName.length - 1);\n                    //continue;\n                    i--;\n                }\n                if (!validateTagName(tagName)) {\n                    let msg;\n                    if (tagName.trim().length === 0) {\n                        msg = \"Invalid space after '<'.\";\n                    } else {\n                        msg = \"Tag '\" + tagName + \"' is an invalid name.\";\n                    }\n                    return getErrorObject(\"InvalidTag\", msg, getLineNumberForPosition(xmlData, i));\n                }\n                const result = readAttributeStr(xmlData, i);\n                if (result === false) {\n                    return getErrorObject(\"InvalidAttr\", \"Attributes for '\" + tagName + \"' have open quote.\", getLineNumberForPosition(xmlData, i));\n                }\n                let attrStr = result.value;\n                i = result.index;\n                if (attrStr[attrStr.length - 1] === \"/\") {\n                    //self closing tag\n                    const attrStrStart = i - attrStr.length;\n                    attrStr = attrStr.substring(0, attrStr.length - 1);\n                    const isValid = validateAttributeString(attrStr, options);\n                    if (isValid === true) {\n                        tagFound = true;\n                    //continue; //text may presents after self closing tag\n                    } else {\n                        //the result from the nested function returns the position of the error within the attribute\n                        //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute\n                        //this gives us the absolute index in the entire xml, which we can use to find the line at last\n                        return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, attrStrStart + isValid.err.line));\n                    }\n                } else if (closingTag) {\n                    if (!result.tagClosed) {\n                        return getErrorObject(\"InvalidTag\", \"Closing tag '\" + tagName + \"' doesn't have proper closing.\", getLineNumberForPosition(xmlData, i));\n                    } else if (attrStr.trim().length > 0) {\n                        return getErrorObject(\"InvalidTag\", \"Closing tag '\" + tagName + \"' can't have attributes or invalid starting.\", getLineNumberForPosition(xmlData, tagStartPos));\n                    } else {\n                        const otg = tags.pop();\n                        if (tagName !== otg.tagName) {\n                            let openPos = getLineNumberForPosition(xmlData, otg.tagStartPos);\n                            return getErrorObject(\"InvalidTag\", \"Expected closing tag '\" + otg.tagName + \"' (opened in line \" + openPos.line + \", col \" + openPos.col + \") instead of closing tag '\" + tagName + \"'.\", getLineNumberForPosition(xmlData, tagStartPos));\n                        }\n                        //when there are no more tags, we reached the root level.\n                        if (tags.length == 0) {\n                            reachedRoot = true;\n                        }\n                    }\n                } else {\n                    const isValid = validateAttributeString(attrStr, options);\n                    if (isValid !== true) {\n                        //the result from the nested function returns the position of the error within the attribute\n                        //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute\n                        //this gives us the absolute index in the entire xml, which we can use to find the line at last\n                        return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, i - attrStr.length + isValid.err.line));\n                    }\n                    //if the root level has been reached before ...\n                    if (reachedRoot === true) {\n                        return getErrorObject(\"InvalidXml\", \"Multiple possible root nodes found.\", getLineNumberForPosition(xmlData, i));\n                    } else if (options.unpairedTags.indexOf(tagName) !== -1) {\n                    //don't push into stack\n                    } else {\n                        tags.push({\n                            tagName,\n                            tagStartPos\n                        });\n                    }\n                    tagFound = true;\n                }\n                //skip tag text value\n                //It may include comments and CDATA value\n                for(i++; i < xmlData.length; i++){\n                    if (xmlData[i] === \"<\") {\n                        if (xmlData[i + 1] === \"!\") {\n                            //comment or CADATA\n                            i++;\n                            i = readCommentAndCDATA(xmlData, i);\n                            continue;\n                        } else if (xmlData[i + 1] === \"?\") {\n                            i = readPI(xmlData, ++i);\n                            if (i.err) return i;\n                        } else {\n                            break;\n                        }\n                    } else if (xmlData[i] === \"&\") {\n                        const afterAmp = validateAmpersand(xmlData, i);\n                        if (afterAmp == -1) return getErrorObject(\"InvalidChar\", \"char '&' is not expected.\", getLineNumberForPosition(xmlData, i));\n                        i = afterAmp;\n                    } else {\n                        if (reachedRoot === true && !isWhiteSpace(xmlData[i])) {\n                            return getErrorObject(\"InvalidXml\", \"Extra text at the end\", getLineNumberForPosition(xmlData, i));\n                        }\n                    }\n                } //end of reading tag text value\n                if (xmlData[i] === \"<\") {\n                    i--;\n                }\n            }\n        } else {\n            if (isWhiteSpace(xmlData[i])) {\n                continue;\n            }\n            return getErrorObject(\"InvalidChar\", \"char '\" + xmlData[i] + \"' is not expected.\", getLineNumberForPosition(xmlData, i));\n        }\n    }\n    if (!tagFound) {\n        return getErrorObject(\"InvalidXml\", \"Start tag expected.\", 1);\n    } else if (tags.length == 1) {\n        return getErrorObject(\"InvalidTag\", \"Unclosed tag '\" + tags[0].tagName + \"'.\", getLineNumberForPosition(xmlData, tags[0].tagStartPos));\n    } else if (tags.length > 0) {\n        return getErrorObject(\"InvalidXml\", \"Invalid '\" + JSON.stringify(tags.map((t)=>t.tagName), null, 4).replace(/\\r?\\n/g, \"\") + \"' found.\", {\n            line: 1,\n            col: 1\n        });\n    }\n    return true;\n};\nfunction isWhiteSpace(char) {\n    return char === \" \" || char === \"\t\" || char === \"\\n\" || char === \"\\r\";\n}\n/**\n * Read Processing insstructions and skip\n * @param {*} xmlData\n * @param {*} i\n */ function readPI(xmlData, i) {\n    const start = i;\n    for(; i < xmlData.length; i++){\n        if (xmlData[i] == \"?\" || xmlData[i] == \" \") {\n            //tagname\n            const tagname = xmlData.substr(start, i - start);\n            if (i > 5 && tagname === \"xml\") {\n                return getErrorObject(\"InvalidXml\", \"XML declaration allowed only at the start of the document.\", getLineNumberForPosition(xmlData, i));\n            } else if (xmlData[i] == \"?\" && xmlData[i + 1] == \">\") {\n                //check if valid attribut string\n                i++;\n                break;\n            } else {\n                continue;\n            }\n        }\n    }\n    return i;\n}\nfunction readCommentAndCDATA(xmlData, i) {\n    if (xmlData.length > i + 5 && xmlData[i + 1] === \"-\" && xmlData[i + 2] === \"-\") {\n        //comment\n        for(i += 3; i < xmlData.length; i++){\n            if (xmlData[i] === \"-\" && xmlData[i + 1] === \"-\" && xmlData[i + 2] === \">\") {\n                i += 2;\n                break;\n            }\n        }\n    } else if (xmlData.length > i + 8 && xmlData[i + 1] === \"D\" && xmlData[i + 2] === \"O\" && xmlData[i + 3] === \"C\" && xmlData[i + 4] === \"T\" && xmlData[i + 5] === \"Y\" && xmlData[i + 6] === \"P\" && xmlData[i + 7] === \"E\") {\n        let angleBracketsCount = 1;\n        for(i += 8; i < xmlData.length; i++){\n            if (xmlData[i] === \"<\") {\n                angleBracketsCount++;\n            } else if (xmlData[i] === \">\") {\n                angleBracketsCount--;\n                if (angleBracketsCount === 0) {\n                    break;\n                }\n            }\n        }\n    } else if (xmlData.length > i + 9 && xmlData[i + 1] === \"[\" && xmlData[i + 2] === \"C\" && xmlData[i + 3] === \"D\" && xmlData[i + 4] === \"A\" && xmlData[i + 5] === \"T\" && xmlData[i + 6] === \"A\" && xmlData[i + 7] === \"[\") {\n        for(i += 8; i < xmlData.length; i++){\n            if (xmlData[i] === \"]\" && xmlData[i + 1] === \"]\" && xmlData[i + 2] === \">\") {\n                i += 2;\n                break;\n            }\n        }\n    }\n    return i;\n}\nconst doubleQuote = '\"';\nconst singleQuote = \"'\";\n/**\n * Keep reading xmlData until '<' is found outside the attribute value.\n * @param {string} xmlData\n * @param {number} i\n */ function readAttributeStr(xmlData, i) {\n    let attrStr = \"\";\n    let startChar = \"\";\n    let tagClosed = false;\n    for(; i < xmlData.length; i++){\n        if (xmlData[i] === doubleQuote || xmlData[i] === singleQuote) {\n            if (startChar === \"\") {\n                startChar = xmlData[i];\n            } else if (startChar !== xmlData[i]) {\n            //if vaue is enclosed with double quote then single quotes are allowed inside the value and vice versa\n            } else {\n                startChar = \"\";\n            }\n        } else if (xmlData[i] === \">\") {\n            if (startChar === \"\") {\n                tagClosed = true;\n                break;\n            }\n        }\n        attrStr += xmlData[i];\n    }\n    if (startChar !== \"\") {\n        return false;\n    }\n    return {\n        value: attrStr,\n        index: i,\n        tagClosed: tagClosed\n    };\n}\n/**\n * Select all the attributes whether valid or invalid.\n */ const validAttrStrRegxp = new RegExp(\"(\\\\s*)([^\\\\s=]+)(\\\\s*=)?(\\\\s*(['\\\"])(([\\\\s\\\\S])*?)\\\\5)?\", \"g\");\n//attr, =\"sd\", a=\"amit's\", a=\"sd\"b=\"saf\", ab  cd=\"\"\nfunction validateAttributeString(attrStr, options) {\n    //console.log(\"start:\"+attrStr+\":end\");\n    //if(attrStr.trim().length === 0) return true; //empty string\n    const matches = util.getAllMatches(attrStr, validAttrStrRegxp);\n    const attrNames = {};\n    for(let i = 0; i < matches.length; i++){\n        if (matches[i][1].length === 0) {\n            //nospace before attribute name: a=\"sd\"b=\"saf\"\n            return getErrorObject(\"InvalidAttr\", \"Attribute '\" + matches[i][2] + \"' has no space in starting.\", getPositionFromMatch(matches[i]));\n        } else if (matches[i][3] !== undefined && matches[i][4] === undefined) {\n            return getErrorObject(\"InvalidAttr\", \"Attribute '\" + matches[i][2] + \"' is without value.\", getPositionFromMatch(matches[i]));\n        } else if (matches[i][3] === undefined && !options.allowBooleanAttributes) {\n            //independent attribute: ab\n            return getErrorObject(\"InvalidAttr\", \"boolean attribute '\" + matches[i][2] + \"' is not allowed.\", getPositionFromMatch(matches[i]));\n        }\n        /* else if(matches[i][6] === undefined){//attribute without value: ab=\n                    return { err: { code:\"InvalidAttr\",msg:\"attribute \" + matches[i][2] + \" has no value assigned.\"}};\n                } */ const attrName = matches[i][2];\n        if (!validateAttrName(attrName)) {\n            return getErrorObject(\"InvalidAttr\", \"Attribute '\" + attrName + \"' is an invalid name.\", getPositionFromMatch(matches[i]));\n        }\n        if (!attrNames.hasOwnProperty(attrName)) {\n            //check for duplicate attribute.\n            attrNames[attrName] = 1;\n        } else {\n            return getErrorObject(\"InvalidAttr\", \"Attribute '\" + attrName + \"' is repeated.\", getPositionFromMatch(matches[i]));\n        }\n    }\n    return true;\n}\nfunction validateNumberAmpersand(xmlData, i) {\n    let re = /\\d/;\n    if (xmlData[i] === \"x\") {\n        i++;\n        re = /[\\da-fA-F]/;\n    }\n    for(; i < xmlData.length; i++){\n        if (xmlData[i] === \";\") return i;\n        if (!xmlData[i].match(re)) break;\n    }\n    return -1;\n}\nfunction validateAmpersand(xmlData, i) {\n    // https://www.w3.org/TR/xml/#dt-charref\n    i++;\n    if (xmlData[i] === \";\") return -1;\n    if (xmlData[i] === \"#\") {\n        i++;\n        return validateNumberAmpersand(xmlData, i);\n    }\n    let count = 0;\n    for(; i < xmlData.length; i++, count++){\n        if (xmlData[i].match(/\\w/) && count < 20) continue;\n        if (xmlData[i] === \";\") break;\n        return -1;\n    }\n    return i;\n}\nfunction getErrorObject(code, message, lineNumber) {\n    return {\n        err: {\n            code: code,\n            msg: message,\n            line: lineNumber.line || lineNumber,\n            col: lineNumber.col\n        }\n    };\n}\nfunction validateAttrName(attrName) {\n    return util.isName(attrName);\n}\n// const startsWithXML = /^xml/i;\nfunction validateTagName(tagname) {\n    return util.isName(tagname) /* && !tagname.match(startsWithXML) */ ;\n}\n//this function returns the line number for the character at the given index\nfunction getLineNumberForPosition(xmlData, index) {\n    const lines = xmlData.substring(0, index).split(/\\r?\\n/);\n    return {\n        line: lines.length,\n        // column number is last line's length + 1, because column numbering starts at 1:\n        col: lines[lines.length - 1].length + 1\n    };\n}\n//this function returns the position of the first character of match within attrStr\nfunction getPositionFromMatch(match) {\n    return match.startIndex + match[1].length;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmFzdC14bWwtcGFyc2VyL3NyYy92YWxpZGF0b3IuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNQSxPQUFPQyxtQkFBT0EsQ0FBQztBQUVyQixNQUFNQyxpQkFBaUI7SUFDckJDLHdCQUF3QjtJQUN4QkMsY0FBYyxFQUFFO0FBQ2xCO0FBRUEscUVBQXFFO0FBQ3JFQyxnQkFBZ0IsR0FBRyxTQUFVRSxPQUFPLEVBQUVDLE9BQU87SUFDM0NBLFVBQVVDLE9BQU9DLE1BQU0sQ0FBQyxDQUFDLEdBQUdSLGdCQUFnQk07SUFFNUMsc0VBQXNFO0lBQ3RFLCtFQUErRTtJQUMvRSw2RkFBNkY7SUFDN0YsTUFBTUcsT0FBTyxFQUFFO0lBQ2YsSUFBSUMsV0FBVztJQUVmLDZFQUE2RTtJQUM3RSxJQUFJQyxjQUFjO0lBRWxCLElBQUlOLE9BQU8sQ0FBQyxFQUFFLEtBQUssVUFBVTtRQUMzQixrQ0FBa0M7UUFDbENBLFVBQVVBLFFBQVFPLE1BQU0sQ0FBQztJQUMzQjtJQUVBLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJUixRQUFRUyxNQUFNLEVBQUVELElBQUs7UUFFdkMsSUFBSVIsT0FBTyxDQUFDUSxFQUFFLEtBQUssT0FBT1IsT0FBTyxDQUFDUSxJQUFFLEVBQUUsS0FBSyxLQUFLO1lBQzlDQSxLQUFHO1lBQ0hBLElBQUlFLE9BQU9WLFNBQVFRO1lBQ25CLElBQUlBLEVBQUVHLEdBQUcsRUFBRSxPQUFPSDtRQUNwQixPQUFNLElBQUlSLE9BQU8sQ0FBQ1EsRUFBRSxLQUFLLEtBQUs7WUFDNUIsaUJBQWlCO1lBQ2pCLGlFQUFpRTtZQUNqRSxJQUFJSSxjQUFjSjtZQUNsQkE7WUFFQSxJQUFJUixPQUFPLENBQUNRLEVBQUUsS0FBSyxLQUFLO2dCQUN0QkEsSUFBSUssb0JBQW9CYixTQUFTUTtnQkFDakM7WUFDRixPQUFPO2dCQUNMLElBQUlNLGFBQWE7Z0JBQ2pCLElBQUlkLE9BQU8sQ0FBQ1EsRUFBRSxLQUFLLEtBQUs7b0JB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aEMsT0FBT3BFLEtBQUs2RSxNQUFNLENBQUNUO0FBQ3JCO0FBRUEsaUNBQWlDO0FBRWpDLFNBQVMzQyxnQkFBZ0IrQixPQUFPO0lBQzlCLE9BQU94RCxLQUFLNkUsTUFBTSxDQUFDckIsU0FBUyxvQ0FBb0M7QUFDbEU7QUFFQSw0RUFBNEU7QUFDNUUsU0FBUzVCLHlCQUF5QnJCLE9BQU8sRUFBRTBCLEtBQUs7SUFDOUMsTUFBTTZDLFFBQVF2RSxRQUFRaUIsU0FBUyxDQUFDLEdBQUdTLE9BQU84QyxLQUFLLENBQUM7SUFDaEQsT0FBTztRQUNMekMsTUFBTXdDLE1BQU05RCxNQUFNO1FBRWxCLGlGQUFpRjtRQUNqRjJCLEtBQUttQyxLQUFLLENBQUNBLE1BQU05RCxNQUFNLEdBQUcsRUFBRSxDQUFDQSxNQUFNLEdBQUc7SUFDeEM7QUFDRjtBQUVBLG1GQUFtRjtBQUNuRixTQUFTa0QscUJBQXFCTyxLQUFLO0lBQ2pDLE9BQU9BLE1BQU1PLFVBQVUsR0FBR1AsS0FBSyxDQUFDLEVBQUUsQ0FBQ3pELE1BQU07QUFDM0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90aGUtZ3JpZC0yLy4vbm9kZV9tb2R1bGVzL2Zhc3QteG1sLXBhcnNlci9zcmMvdmFsaWRhdG9yLmpzPzdlNWMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbmNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICBhbGxvd0Jvb2xlYW5BdHRyaWJ1dGVzOiBmYWxzZSwgLy9BIHRhZyBjYW4gaGF2ZSBhdHRyaWJ1dGVzIHdpdGhvdXQgYW55IHZhbHVlXG4gIHVucGFpcmVkVGFnczogW11cbn07XG5cbi8vY29uc3QgdGFnc1BhdHRlcm4gPSBuZXcgUmVnRXhwKFwiPFxcXFwvPyhbXFxcXHc6XFxcXC1fXFwuXSspXFxcXHMqXFwvPz5cIixcImdcIik7XG5leHBvcnRzLnZhbGlkYXRlID0gZnVuY3Rpb24gKHhtbERhdGEsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKTtcblxuICAvL3htbERhdGEgPSB4bWxEYXRhLnJlcGxhY2UoLyhcXHJcXG58XFxufFxccikvZ20sXCJcIik7Ly9tYWtlIGl0IHNpbmdsZSBsaW5lXG4gIC8veG1sRGF0YSA9IHhtbERhdGEucmVwbGFjZSgvKF5cXHMqPFxcP3htbC4qP1xcPz4pL2csXCJcIik7Ly9SZW1vdmUgWE1MIHN0YXJ0aW5nIHRhZ1xuICAvL3htbERhdGEgPSB4bWxEYXRhLnJlcGxhY2UoLyg8IURPQ1RZUEVbXFxzXFx3XFxcIlxcLlxcL1xcLVxcOl0rKFxcWy4qXFxdKSpcXHMqPikvZyxcIlwiKTsvL1JlbW92ZSBET0NUWVBFXG4gIGNvbnN0IHRhZ3MgPSBbXTtcbiAgbGV0IHRhZ0ZvdW5kID0gZmFsc2U7XG5cbiAgLy9pbmRpY2F0ZXMgdGhhdCB0aGUgcm9vdCB0YWcgaGFzIGJlZW4gY2xvc2VkIChha2EuIGRlcHRoIDAgaGFzIGJlZW4gcmVhY2hlZClcbiAgbGV0IHJlYWNoZWRSb290ID0gZmFsc2U7XG5cbiAgaWYgKHhtbERhdGFbMF0gPT09ICdcXHVmZWZmJykge1xuICAgIC8vIGNoZWNrIGZvciBieXRlIG9yZGVyIG1hcmsgKEJPTSlcbiAgICB4bWxEYXRhID0geG1sRGF0YS5zdWJzdHIoMSk7XG4gIH1cbiAgXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgeG1sRGF0YS5sZW5ndGg7IGkrKykge1xuXG4gICAgaWYgKHhtbERhdGFbaV0gPT09ICc8JyAmJiB4bWxEYXRhW2krMV0gPT09ICc/Jykge1xuICAgICAgaSs9MjtcbiAgICAgIGkgPSByZWFkUEkoeG1sRGF0YSxpKTtcbiAgICAgIGlmIChpLmVycikgcmV0dXJuIGk7XG4gICAgfWVsc2UgaWYgKHhtbERhdGFbaV0gPT09ICc8Jykge1xuICAgICAgLy9zdGFydGluZyBvZiB0YWdcbiAgICAgIC8vcmVhZCB1bnRpbCB5b3UgcmVhY2ggdG8gJz4nIGF2b2lkaW5nIGFueSAnPicgaW4gYXR0cmlidXRlIHZhbHVlXG4gICAgICBsZXQgdGFnU3RhcnRQb3MgPSBpO1xuICAgICAgaSsrO1xuICAgICAgXG4gICAgICBpZiAoeG1sRGF0YVtpXSA9PT0gJyEnKSB7XG4gICAgICAgIGkgPSByZWFkQ29tbWVudEFuZENEQVRBKHhtbERhdGEsIGkpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBjbG9zaW5nVGFnID0gZmFsc2U7XG4gICAgICAgIGlmICh4bWxEYXRhW2ldID09PSAnLycpIHtcbiAgICAgICAgICAvL2Nsb3NpbmcgdGFnXG4gICAgICAgICAgY2xvc2luZ1RhZyA9IHRydWU7XG4gICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIC8vcmVhZCB0YWduYW1lXG4gICAgICAgIGxldCB0YWdOYW1lID0gJyc7XG4gICAgICAgIGZvciAoOyBpIDwgeG1sRGF0YS5sZW5ndGggJiZcbiAgICAgICAgICB4bWxEYXRhW2ldICE9PSAnPicgJiZcbiAgICAgICAgICB4bWxEYXRhW2ldICE9PSAnICcgJiZcbiAgICAgICAgICB4bWxEYXRhW2ldICE9PSAnXFx0JyAmJlxuICAgICAgICAgIHhtbERhdGFbaV0gIT09ICdcXG4nICYmXG4gICAgICAgICAgeG1sRGF0YVtpXSAhPT0gJ1xccic7IGkrK1xuICAgICAgICApIHtcbiAgICAgICAgICB0YWdOYW1lICs9IHhtbERhdGFbaV07XG4gICAgICAgIH1cbiAgICAgICAgdGFnTmFtZSA9IHRhZ05hbWUudHJpbSgpO1xuICAgICAgICAvL2NvbnNvbGUubG9nKHRhZ05hbWUpO1xuXG4gICAgICAgIGlmICh0YWdOYW1lW3RhZ05hbWUubGVuZ3RoIC0gMV0gPT09ICcvJykge1xuICAgICAgICAgIC8vc2VsZiBjbG9zaW5nIHRhZyB3aXRob3V0IGF0dHJpYnV0ZXNcbiAgICAgICAgICB0YWdOYW1lID0gdGFnTmFtZS5zdWJzdHJpbmcoMCwgdGFnTmFtZS5sZW5ndGggLSAxKTtcbiAgICAgICAgICAvL2NvbnRpbnVlO1xuICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXZhbGlkYXRlVGFnTmFtZSh0YWdOYW1lKSkge1xuICAgICAgICAgIGxldCBtc2c7XG4gICAgICAgICAgaWYgKHRhZ05hbWUudHJpbSgpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgbXNnID0gXCJJbnZhbGlkIHNwYWNlIGFmdGVyICc8Jy5cIjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbXNnID0gXCJUYWcgJ1wiK3RhZ05hbWUrXCInIGlzIGFuIGludmFsaWQgbmFtZS5cIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGdldEVycm9yT2JqZWN0KCdJbnZhbGlkVGFnJywgbXNnLCBnZXRMaW5lTnVtYmVyRm9yUG9zaXRpb24oeG1sRGF0YSwgaSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gcmVhZEF0dHJpYnV0ZVN0cih4bWxEYXRhLCBpKTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gZ2V0RXJyb3JPYmplY3QoJ0ludmFsaWRBdHRyJywgXCJBdHRyaWJ1dGVzIGZvciAnXCIrdGFnTmFtZStcIicgaGF2ZSBvcGVuIHF1b3RlLlwiLCBnZXRMaW5lTnVtYmVyRm9yUG9zaXRpb24oeG1sRGF0YSwgaSkpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBhdHRyU3RyID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICBpID0gcmVzdWx0LmluZGV4O1xuXG4gICAgICAgIGlmIChhdHRyU3RyW2F0dHJTdHIubGVuZ3RoIC0gMV0gPT09ICcvJykge1xuICAgICAgICAgIC8vc2VsZiBjbG9zaW5nIHRhZ1xuICAgICAgICAgIGNvbnN0IGF0dHJTdHJTdGFydCA9IGkgLSBhdHRyU3RyLmxlbmd0aDtcbiAgICAgICAgICBhdHRyU3RyID0gYXR0clN0ci5zdWJzdHJpbmcoMCwgYXR0clN0ci5sZW5ndGggLSAxKTtcbiAgICAgICAgICBjb25zdCBpc1ZhbGlkID0gdmFsaWRhdGVBdHRyaWJ1dGVTdHJpbmcoYXR0clN0ciwgb3B0aW9ucyk7XG4gICAgICAgICAgaWYgKGlzVmFsaWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRhZ0ZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vY29udGludWU7IC8vdGV4dCBtYXkgcHJlc2VudHMgYWZ0ZXIgc2VsZiBjbG9zaW5nIHRhZ1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvL3RoZSByZXN1bHQgZnJvbSB0aGUgbmVzdGVkIGZ1bmN0aW9uIHJldHVybnMgdGhlIHBvc2l0aW9uIG9mIHRoZSBlcnJvciB3aXRoaW4gdGhlIGF0dHJpYnV0ZVxuICAgICAgICAgICAgLy9pbiBvcmRlciB0byBnZXQgdGhlICd0cnVlJyBlcnJvciBsaW5lLCB3ZSBuZWVkIHRvIGNhbGN1bGF0ZSB0aGUgcG9zaXRpb24gd2hlcmUgdGhlIGF0dHJpYnV0ZSBiZWdpbnMgKGkgLSBhdHRyU3RyLmxlbmd0aCkgYW5kIHRoZW4gYWRkIHRoZSBwb3NpdGlvbiB3aXRoaW4gdGhlIGF0dHJpYnV0ZVxuICAgICAgICAgICAgLy90aGlzIGdpdmVzIHVzIHRoZSBhYnNvbHV0ZSBpbmRleCBpbiB0aGUgZW50aXJlIHhtbCwgd2hpY2ggd2UgY2FuIHVzZSB0byBmaW5kIHRoZSBsaW5lIGF0IGxhc3RcbiAgICAgICAgICAgIHJldHVybiBnZXRFcnJvck9iamVjdChpc1ZhbGlkLmVyci5jb2RlLCBpc1ZhbGlkLmVyci5tc2csIGdldExpbmVOdW1iZXJGb3JQb3NpdGlvbih4bWxEYXRhLCBhdHRyU3RyU3RhcnQgKyBpc1ZhbGlkLmVyci5saW5lKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGNsb3NpbmdUYWcpIHtcbiAgICAgICAgICBpZiAoIXJlc3VsdC50YWdDbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRFcnJvck9iamVjdCgnSW52YWxpZFRhZycsIFwiQ2xvc2luZyB0YWcgJ1wiK3RhZ05hbWUrXCInIGRvZXNuJ3QgaGF2ZSBwcm9wZXIgY2xvc2luZy5cIiwgZ2V0TGluZU51bWJlckZvclBvc2l0aW9uKHhtbERhdGEsIGkpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGF0dHJTdHIudHJpbSgpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRFcnJvck9iamVjdCgnSW52YWxpZFRhZycsIFwiQ2xvc2luZyB0YWcgJ1wiK3RhZ05hbWUrXCInIGNhbid0IGhhdmUgYXR0cmlidXRlcyBvciBpbnZhbGlkIHN0YXJ0aW5nLlwiLCBnZXRMaW5lTnVtYmVyRm9yUG9zaXRpb24oeG1sRGF0YSwgdGFnU3RhcnRQb3MpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgb3RnID0gdGFncy5wb3AoKTtcbiAgICAgICAgICAgIGlmICh0YWdOYW1lICE9PSBvdGcudGFnTmFtZSkge1xuICAgICAgICAgICAgICBsZXQgb3BlblBvcyA9IGdldExpbmVOdW1iZXJGb3JQb3NpdGlvbih4bWxEYXRhLCBvdGcudGFnU3RhcnRQb3MpO1xuICAgICAgICAgICAgICByZXR1cm4gZ2V0RXJyb3JPYmplY3QoJ0ludmFsaWRUYWcnLFxuICAgICAgICAgICAgICAgIFwiRXhwZWN0ZWQgY2xvc2luZyB0YWcgJ1wiK290Zy50YWdOYW1lK1wiJyAob3BlbmVkIGluIGxpbmUgXCIrb3BlblBvcy5saW5lK1wiLCBjb2wgXCIrb3BlblBvcy5jb2wrXCIpIGluc3RlYWQgb2YgY2xvc2luZyB0YWcgJ1wiK3RhZ05hbWUrXCInLlwiLFxuICAgICAgICAgICAgICAgIGdldExpbmVOdW1iZXJGb3JQb3NpdGlvbih4bWxEYXRhLCB0YWdTdGFydFBvcykpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL3doZW4gdGhlcmUgYXJlIG5vIG1vcmUgdGFncywgd2UgcmVhY2hlZCB0aGUgcm9vdCBsZXZlbC5cbiAgICAgICAgICAgIGlmICh0YWdzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgIHJlYWNoZWRSb290ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgaXNWYWxpZCA9IHZhbGlkYXRlQXR0cmlidXRlU3RyaW5nKGF0dHJTdHIsIG9wdGlvbnMpO1xuICAgICAgICAgIGlmIChpc1ZhbGlkICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAvL3RoZSByZXN1bHQgZnJvbSB0aGUgbmVzdGVkIGZ1bmN0aW9uIHJldHVybnMgdGhlIHBvc2l0aW9uIG9mIHRoZSBlcnJvciB3aXRoaW4gdGhlIGF0dHJpYnV0ZVxuICAgICAgICAgICAgLy9pbiBvcmRlciB0byBnZXQgdGhlICd0cnVlJyBlcnJvciBsaW5lLCB3ZSBuZWVkIHRvIGNhbGN1bGF0ZSB0aGUgcG9zaXRpb24gd2hlcmUgdGhlIGF0dHJpYnV0ZSBiZWdpbnMgKGkgLSBhdHRyU3RyLmxlbmd0aCkgYW5kIHRoZW4gYWRkIHRoZSBwb3NpdGlvbiB3aXRoaW4gdGhlIGF0dHJpYnV0ZVxuICAgICAgICAgICAgLy90aGlzIGdpdmVzIHVzIHRoZSBhYnNvbHV0ZSBpbmRleCBpbiB0aGUgZW50aXJlIHhtbCwgd2hpY2ggd2UgY2FuIHVzZSB0byBmaW5kIHRoZSBsaW5lIGF0IGxhc3RcbiAgICAgICAgICAgIHJldHVybiBnZXRFcnJvck9iamVjdChpc1ZhbGlkLmVyci5jb2RlLCBpc1ZhbGlkLmVyci5tc2csIGdldExpbmVOdW1iZXJGb3JQb3NpdGlvbih4bWxEYXRhLCBpIC0gYXR0clN0ci5sZW5ndGggKyBpc1ZhbGlkLmVyci5saW5lKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy9pZiB0aGUgcm9vdCBsZXZlbCBoYXMgYmVlbiByZWFjaGVkIGJlZm9yZSAuLi5cbiAgICAgICAgICBpZiAocmVhY2hlZFJvb3QgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRFcnJvck9iamVjdCgnSW52YWxpZFhtbCcsICdNdWx0aXBsZSBwb3NzaWJsZSByb290IG5vZGVzIGZvdW5kLicsIGdldExpbmVOdW1iZXJGb3JQb3NpdGlvbih4bWxEYXRhLCBpKSk7XG4gICAgICAgICAgfSBlbHNlIGlmKG9wdGlvbnMudW5wYWlyZWRUYWdzLmluZGV4T2YodGFnTmFtZSkgIT09IC0xKXtcbiAgICAgICAgICAgIC8vZG9uJ3QgcHVzaCBpbnRvIHN0YWNrXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRhZ3MucHVzaCh7dGFnTmFtZSwgdGFnU3RhcnRQb3N9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGFnRm91bmQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9za2lwIHRhZyB0ZXh0IHZhbHVlXG4gICAgICAgIC8vSXQgbWF5IGluY2x1ZGUgY29tbWVudHMgYW5kIENEQVRBIHZhbHVlXG4gICAgICAgIGZvciAoaSsrOyBpIDwgeG1sRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmICh4bWxEYXRhW2ldID09PSAnPCcpIHtcbiAgICAgICAgICAgIGlmICh4bWxEYXRhW2kgKyAxXSA9PT0gJyEnKSB7XG4gICAgICAgICAgICAgIC8vY29tbWVudCBvciBDQURBVEFcbiAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICBpID0gcmVhZENvbW1lbnRBbmRDREFUQSh4bWxEYXRhLCBpKTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHhtbERhdGFbaSsxXSA9PT0gJz8nKSB7XG4gICAgICAgICAgICAgIGkgPSByZWFkUEkoeG1sRGF0YSwgKytpKTtcbiAgICAgICAgICAgICAgaWYgKGkuZXJyKSByZXR1cm4gaTtcbiAgICAgICAgICAgIH0gZWxzZXtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICh4bWxEYXRhW2ldID09PSAnJicpIHtcbiAgICAgICAgICAgIGNvbnN0IGFmdGVyQW1wID0gdmFsaWRhdGVBbXBlcnNhbmQoeG1sRGF0YSwgaSk7XG4gICAgICAgICAgICBpZiAoYWZ0ZXJBbXAgPT0gLTEpXG4gICAgICAgICAgICAgIHJldHVybiBnZXRFcnJvck9iamVjdCgnSW52YWxpZENoYXInLCBcImNoYXIgJyYnIGlzIG5vdCBleHBlY3RlZC5cIiwgZ2V0TGluZU51bWJlckZvclBvc2l0aW9uKHhtbERhdGEsIGkpKTtcbiAgICAgICAgICAgIGkgPSBhZnRlckFtcDtcbiAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIGlmIChyZWFjaGVkUm9vdCA9PT0gdHJ1ZSAmJiAhaXNXaGl0ZVNwYWNlKHhtbERhdGFbaV0pKSB7XG4gICAgICAgICAgICAgIHJldHVybiBnZXRFcnJvck9iamVjdCgnSW52YWxpZFhtbCcsIFwiRXh0cmEgdGV4dCBhdCB0aGUgZW5kXCIsIGdldExpbmVOdW1iZXJGb3JQb3NpdGlvbih4bWxEYXRhLCBpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vZW5kIG9mIHJlYWRpbmcgdGFnIHRleHQgdmFsdWVcbiAgICAgICAgaWYgKHhtbERhdGFbaV0gPT09ICc8Jykge1xuICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIGlzV2hpdGVTcGFjZSh4bWxEYXRhW2ldKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXRFcnJvck9iamVjdCgnSW52YWxpZENoYXInLCBcImNoYXIgJ1wiK3htbERhdGFbaV0rXCInIGlzIG5vdCBleHBlY3RlZC5cIiwgZ2V0TGluZU51bWJlckZvclBvc2l0aW9uKHhtbERhdGEsIGkpKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIXRhZ0ZvdW5kKSB7XG4gICAgcmV0dXJuIGdldEVycm9yT2JqZWN0KCdJbnZhbGlkWG1sJywgJ1N0YXJ0IHRhZyBleHBlY3RlZC4nLCAxKTtcbiAgfWVsc2UgaWYgKHRhZ3MubGVuZ3RoID09IDEpIHtcbiAgICAgIHJldHVybiBnZXRFcnJvck9iamVjdCgnSW52YWxpZFRhZycsIFwiVW5jbG9zZWQgdGFnICdcIit0YWdzWzBdLnRhZ05hbWUrXCInLlwiLCBnZXRMaW5lTnVtYmVyRm9yUG9zaXRpb24oeG1sRGF0YSwgdGFnc1swXS50YWdTdGFydFBvcykpO1xuICB9ZWxzZSBpZiAodGFncy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gZ2V0RXJyb3JPYmplY3QoJ0ludmFsaWRYbWwnLCBcIkludmFsaWQgJ1wiK1xuICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHRhZ3MubWFwKHQgPT4gdC50YWdOYW1lKSwgbnVsbCwgNCkucmVwbGFjZSgvXFxyP1xcbi9nLCAnJykrXG4gICAgICAgICAgXCInIGZvdW5kLlwiLCB7bGluZTogMSwgY29sOiAxfSk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIGlzV2hpdGVTcGFjZShjaGFyKXtcbiAgcmV0dXJuIGNoYXIgPT09ICcgJyB8fCBjaGFyID09PSAnXFx0JyB8fCBjaGFyID09PSAnXFxuJyAgfHwgY2hhciA9PT0gJ1xccic7XG59XG4vKipcbiAqIFJlYWQgUHJvY2Vzc2luZyBpbnNzdHJ1Y3Rpb25zIGFuZCBza2lwXG4gKiBAcGFyYW0geyp9IHhtbERhdGFcbiAqIEBwYXJhbSB7Kn0gaVxuICovXG5mdW5jdGlvbiByZWFkUEkoeG1sRGF0YSwgaSkge1xuICBjb25zdCBzdGFydCA9IGk7XG4gIGZvciAoOyBpIDwgeG1sRGF0YS5sZW5ndGg7IGkrKykge1xuICAgIGlmICh4bWxEYXRhW2ldID09ICc/JyB8fCB4bWxEYXRhW2ldID09ICcgJykge1xuICAgICAgLy90YWduYW1lXG4gICAgICBjb25zdCB0YWduYW1lID0geG1sRGF0YS5zdWJzdHIoc3RhcnQsIGkgLSBzdGFydCk7XG4gICAgICBpZiAoaSA+IDUgJiYgdGFnbmFtZSA9PT0gJ3htbCcpIHtcbiAgICAgICAgcmV0dXJuIGdldEVycm9yT2JqZWN0KCdJbnZhbGlkWG1sJywgJ1hNTCBkZWNsYXJhdGlvbiBhbGxvd2VkIG9ubHkgYXQgdGhlIHN0YXJ0IG9mIHRoZSBkb2N1bWVudC4nLCBnZXRMaW5lTnVtYmVyRm9yUG9zaXRpb24oeG1sRGF0YSwgaSkpO1xuICAgICAgfSBlbHNlIGlmICh4bWxEYXRhW2ldID09ICc/JyAmJiB4bWxEYXRhW2kgKyAxXSA9PSAnPicpIHtcbiAgICAgICAgLy9jaGVjayBpZiB2YWxpZCBhdHRyaWJ1dCBzdHJpbmdcbiAgICAgICAgaSsrO1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gaTtcbn1cblxuZnVuY3Rpb24gcmVhZENvbW1lbnRBbmRDREFUQSh4bWxEYXRhLCBpKSB7XG4gIGlmICh4bWxEYXRhLmxlbmd0aCA+IGkgKyA1ICYmIHhtbERhdGFbaSArIDFdID09PSAnLScgJiYgeG1sRGF0YVtpICsgMl0gPT09ICctJykge1xuICAgIC8vY29tbWVudFxuICAgIGZvciAoaSArPSAzOyBpIDwgeG1sRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHhtbERhdGFbaV0gPT09ICctJyAmJiB4bWxEYXRhW2kgKyAxXSA9PT0gJy0nICYmIHhtbERhdGFbaSArIDJdID09PSAnPicpIHtcbiAgICAgICAgaSArPSAyO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoXG4gICAgeG1sRGF0YS5sZW5ndGggPiBpICsgOCAmJlxuICAgIHhtbERhdGFbaSArIDFdID09PSAnRCcgJiZcbiAgICB4bWxEYXRhW2kgKyAyXSA9PT0gJ08nICYmXG4gICAgeG1sRGF0YVtpICsgM10gPT09ICdDJyAmJlxuICAgIHhtbERhdGFbaSArIDRdID09PSAnVCcgJiZcbiAgICB4bWxEYXRhW2kgKyA1XSA9PT0gJ1knICYmXG4gICAgeG1sRGF0YVtpICsgNl0gPT09ICdQJyAmJlxuICAgIHhtbERhdGFbaSArIDddID09PSAnRSdcbiAgKSB7XG4gICAgbGV0IGFuZ2xlQnJhY2tldHNDb3VudCA9IDE7XG4gICAgZm9yIChpICs9IDg7IGkgPCB4bWxEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoeG1sRGF0YVtpXSA9PT0gJzwnKSB7XG4gICAgICAgIGFuZ2xlQnJhY2tldHNDb3VudCsrO1xuICAgICAgfSBlbHNlIGlmICh4bWxEYXRhW2ldID09PSAnPicpIHtcbiAgICAgICAgYW5nbGVCcmFja2V0c0NvdW50LS07XG4gICAgICAgIGlmIChhbmdsZUJyYWNrZXRzQ291bnQgPT09IDApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChcbiAgICB4bWxEYXRhLmxlbmd0aCA+IGkgKyA5ICYmXG4gICAgeG1sRGF0YVtpICsgMV0gPT09ICdbJyAmJlxuICAgIHhtbERhdGFbaSArIDJdID09PSAnQycgJiZcbiAgICB4bWxEYXRhW2kgKyAzXSA9PT0gJ0QnICYmXG4gICAgeG1sRGF0YVtpICsgNF0gPT09ICdBJyAmJlxuICAgIHhtbERhdGFbaSArIDVdID09PSAnVCcgJiZcbiAgICB4bWxEYXRhW2kgKyA2XSA9PT0gJ0EnICYmXG4gICAgeG1sRGF0YVtpICsgN10gPT09ICdbJ1xuICApIHtcbiAgICBmb3IgKGkgKz0gODsgaSA8IHhtbERhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh4bWxEYXRhW2ldID09PSAnXScgJiYgeG1sRGF0YVtpICsgMV0gPT09ICddJyAmJiB4bWxEYXRhW2kgKyAyXSA9PT0gJz4nKSB7XG4gICAgICAgIGkgKz0gMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGk7XG59XG5cbmNvbnN0IGRvdWJsZVF1b3RlID0gJ1wiJztcbmNvbnN0IHNpbmdsZVF1b3RlID0gXCInXCI7XG5cbi8qKlxuICogS2VlcCByZWFkaW5nIHhtbERhdGEgdW50aWwgJzwnIGlzIGZvdW5kIG91dHNpZGUgdGhlIGF0dHJpYnV0ZSB2YWx1ZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB4bWxEYXRhXG4gKiBAcGFyYW0ge251bWJlcn0gaVxuICovXG5mdW5jdGlvbiByZWFkQXR0cmlidXRlU3RyKHhtbERhdGEsIGkpIHtcbiAgbGV0IGF0dHJTdHIgPSAnJztcbiAgbGV0IHN0YXJ0Q2hhciA9ICcnO1xuICBsZXQgdGFnQ2xvc2VkID0gZmFsc2U7XG4gIGZvciAoOyBpIDwgeG1sRGF0YS5sZW5ndGg7IGkrKykge1xuICAgIGlmICh4bWxEYXRhW2ldID09PSBkb3VibGVRdW90ZSB8fCB4bWxEYXRhW2ldID09PSBzaW5nbGVRdW90ZSkge1xuICAgICAgaWYgKHN0YXJ0Q2hhciA9PT0gJycpIHtcbiAgICAgICAgc3RhcnRDaGFyID0geG1sRGF0YVtpXTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhcnRDaGFyICE9PSB4bWxEYXRhW2ldKSB7XG4gICAgICAgIC8vaWYgdmF1ZSBpcyBlbmNsb3NlZCB3aXRoIGRvdWJsZSBxdW90ZSB0aGVuIHNpbmdsZSBxdW90ZXMgYXJlIGFsbG93ZWQgaW5zaWRlIHRoZSB2YWx1ZSBhbmQgdmljZSB2ZXJzYVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhcnRDaGFyID0gJyc7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh4bWxEYXRhW2ldID09PSAnPicpIHtcbiAgICAgIGlmIChzdGFydENoYXIgPT09ICcnKSB7XG4gICAgICAgIHRhZ0Nsb3NlZCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBhdHRyU3RyICs9IHhtbERhdGFbaV07XG4gIH1cbiAgaWYgKHN0YXJ0Q2hhciAhPT0gJycpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHZhbHVlOiBhdHRyU3RyLFxuICAgIGluZGV4OiBpLFxuICAgIHRhZ0Nsb3NlZDogdGFnQ2xvc2VkXG4gIH07XG59XG5cbi8qKlxuICogU2VsZWN0IGFsbCB0aGUgYXR0cmlidXRlcyB3aGV0aGVyIHZhbGlkIG9yIGludmFsaWQuXG4gKi9cbmNvbnN0IHZhbGlkQXR0clN0clJlZ3hwID0gbmV3IFJlZ0V4cCgnKFxcXFxzKikoW15cXFxccz1dKykoXFxcXHMqPSk/KFxcXFxzKihbXFwnXCJdKSgoW1xcXFxzXFxcXFNdKSo/KVxcXFw1KT8nLCAnZycpO1xuXG4vL2F0dHIsID1cInNkXCIsIGE9XCJhbWl0J3NcIiwgYT1cInNkXCJiPVwic2FmXCIsIGFiICBjZD1cIlwiXG5cbmZ1bmN0aW9uIHZhbGlkYXRlQXR0cmlidXRlU3RyaW5nKGF0dHJTdHIsIG9wdGlvbnMpIHtcbiAgLy9jb25zb2xlLmxvZyhcInN0YXJ0OlwiK2F0dHJTdHIrXCI6ZW5kXCIpO1xuXG4gIC8vaWYoYXR0clN0ci50cmltKCkubGVuZ3RoID09PSAwKSByZXR1cm4gdHJ1ZTsgLy9lbXB0eSBzdHJpbmdcblxuICBjb25zdCBtYXRjaGVzID0gdXRpbC5nZXRBbGxNYXRjaGVzKGF0dHJTdHIsIHZhbGlkQXR0clN0clJlZ3hwKTtcbiAgY29uc3QgYXR0ck5hbWVzID0ge307XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXRjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKG1hdGNoZXNbaV1bMV0ubGVuZ3RoID09PSAwKSB7XG4gICAgICAvL25vc3BhY2UgYmVmb3JlIGF0dHJpYnV0ZSBuYW1lOiBhPVwic2RcImI9XCJzYWZcIlxuICAgICAgcmV0dXJuIGdldEVycm9yT2JqZWN0KCdJbnZhbGlkQXR0cicsIFwiQXR0cmlidXRlICdcIittYXRjaGVzW2ldWzJdK1wiJyBoYXMgbm8gc3BhY2UgaW4gc3RhcnRpbmcuXCIsIGdldFBvc2l0aW9uRnJvbU1hdGNoKG1hdGNoZXNbaV0pKVxuICAgIH0gZWxzZSBpZiAobWF0Y2hlc1tpXVszXSAhPT0gdW5kZWZpbmVkICYmIG1hdGNoZXNbaV1bNF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGdldEVycm9yT2JqZWN0KCdJbnZhbGlkQXR0cicsIFwiQXR0cmlidXRlICdcIittYXRjaGVzW2ldWzJdK1wiJyBpcyB3aXRob3V0IHZhbHVlLlwiLCBnZXRQb3NpdGlvbkZyb21NYXRjaChtYXRjaGVzW2ldKSk7XG4gICAgfSBlbHNlIGlmIChtYXRjaGVzW2ldWzNdID09PSB1bmRlZmluZWQgJiYgIW9wdGlvbnMuYWxsb3dCb29sZWFuQXR0cmlidXRlcykge1xuICAgICAgLy9pbmRlcGVuZGVudCBhdHRyaWJ1dGU6IGFiXG4gICAgICByZXR1cm4gZ2V0RXJyb3JPYmplY3QoJ0ludmFsaWRBdHRyJywgXCJib29sZWFuIGF0dHJpYnV0ZSAnXCIrbWF0Y2hlc1tpXVsyXStcIicgaXMgbm90IGFsbG93ZWQuXCIsIGdldFBvc2l0aW9uRnJvbU1hdGNoKG1hdGNoZXNbaV0pKTtcbiAgICB9XG4gICAgLyogZWxzZSBpZihtYXRjaGVzW2ldWzZdID09PSB1bmRlZmluZWQpey8vYXR0cmlidXRlIHdpdGhvdXQgdmFsdWU6IGFiPVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBlcnI6IHsgY29kZTpcIkludmFsaWRBdHRyXCIsbXNnOlwiYXR0cmlidXRlIFwiICsgbWF0Y2hlc1tpXVsyXSArIFwiIGhhcyBubyB2YWx1ZSBhc3NpZ25lZC5cIn19O1xuICAgICAgICAgICAgICAgIH0gKi9cbiAgICBjb25zdCBhdHRyTmFtZSA9IG1hdGNoZXNbaV1bMl07XG4gICAgaWYgKCF2YWxpZGF0ZUF0dHJOYW1lKGF0dHJOYW1lKSkge1xuICAgICAgcmV0dXJuIGdldEVycm9yT2JqZWN0KCdJbnZhbGlkQXR0cicsIFwiQXR0cmlidXRlICdcIithdHRyTmFtZStcIicgaXMgYW4gaW52YWxpZCBuYW1lLlwiLCBnZXRQb3NpdGlvbkZyb21NYXRjaChtYXRjaGVzW2ldKSk7XG4gICAgfVxuICAgIGlmICghYXR0ck5hbWVzLmhhc093blByb3BlcnR5KGF0dHJOYW1lKSkge1xuICAgICAgLy9jaGVjayBmb3IgZHVwbGljYXRlIGF0dHJpYnV0ZS5cbiAgICAgIGF0dHJOYW1lc1thdHRyTmFtZV0gPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZ2V0RXJyb3JPYmplY3QoJ0ludmFsaWRBdHRyJywgXCJBdHRyaWJ1dGUgJ1wiK2F0dHJOYW1lK1wiJyBpcyByZXBlYXRlZC5cIiwgZ2V0UG9zaXRpb25Gcm9tTWF0Y2gobWF0Y2hlc1tpXSkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZU51bWJlckFtcGVyc2FuZCh4bWxEYXRhLCBpKSB7XG4gIGxldCByZSA9IC9cXGQvO1xuICBpZiAoeG1sRGF0YVtpXSA9PT0gJ3gnKSB7XG4gICAgaSsrO1xuICAgIHJlID0gL1tcXGRhLWZBLUZdLztcbiAgfVxuICBmb3IgKDsgaSA8IHhtbERhdGEubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoeG1sRGF0YVtpXSA9PT0gJzsnKVxuICAgICAgcmV0dXJuIGk7XG4gICAgaWYgKCF4bWxEYXRhW2ldLm1hdGNoKHJlKSlcbiAgICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiAtMTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVBbXBlcnNhbmQoeG1sRGF0YSwgaSkge1xuICAvLyBodHRwczovL3d3dy53My5vcmcvVFIveG1sLyNkdC1jaGFycmVmXG4gIGkrKztcbiAgaWYgKHhtbERhdGFbaV0gPT09ICc7JylcbiAgICByZXR1cm4gLTE7XG4gIGlmICh4bWxEYXRhW2ldID09PSAnIycpIHtcbiAgICBpKys7XG4gICAgcmV0dXJuIHZhbGlkYXRlTnVtYmVyQW1wZXJzYW5kKHhtbERhdGEsIGkpO1xuICB9XG4gIGxldCBjb3VudCA9IDA7XG4gIGZvciAoOyBpIDwgeG1sRGF0YS5sZW5ndGg7IGkrKywgY291bnQrKykge1xuICAgIGlmICh4bWxEYXRhW2ldLm1hdGNoKC9cXHcvKSAmJiBjb3VudCA8IDIwKVxuICAgICAgY29udGludWU7XG4gICAgaWYgKHhtbERhdGFbaV0gPT09ICc7JylcbiAgICAgIGJyZWFrO1xuICAgIHJldHVybiAtMTtcbiAgfVxuICByZXR1cm4gaTtcbn1cblxuZnVuY3Rpb24gZ2V0RXJyb3JPYmplY3QoY29kZSwgbWVzc2FnZSwgbGluZU51bWJlcikge1xuICByZXR1cm4ge1xuICAgIGVycjoge1xuICAgICAgY29kZTogY29kZSxcbiAgICAgIG1zZzogbWVzc2FnZSxcbiAgICAgIGxpbmU6IGxpbmVOdW1iZXIubGluZSB8fCBsaW5lTnVtYmVyLFxuICAgICAgY29sOiBsaW5lTnVtYmVyLmNvbCxcbiAgICB9LFxuICB9O1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUF0dHJOYW1lKGF0dHJOYW1lKSB7XG4gIHJldHVybiB1dGlsLmlzTmFtZShhdHRyTmFtZSk7XG59XG5cbi8vIGNvbnN0IHN0YXJ0c1dpdGhYTUwgPSAvXnhtbC9pO1xuXG5mdW5jdGlvbiB2YWxpZGF0ZVRhZ05hbWUodGFnbmFtZSkge1xuICByZXR1cm4gdXRpbC5pc05hbWUodGFnbmFtZSkgLyogJiYgIXRhZ25hbWUubWF0Y2goc3RhcnRzV2l0aFhNTCkgKi87XG59XG5cbi8vdGhpcyBmdW5jdGlvbiByZXR1cm5zIHRoZSBsaW5lIG51bWJlciBmb3IgdGhlIGNoYXJhY3RlciBhdCB0aGUgZ2l2ZW4gaW5kZXhcbmZ1bmN0aW9uIGdldExpbmVOdW1iZXJGb3JQb3NpdGlvbih4bWxEYXRhLCBpbmRleCkge1xuICBjb25zdCBsaW5lcyA9IHhtbERhdGEuc3Vic3RyaW5nKDAsIGluZGV4KS5zcGxpdCgvXFxyP1xcbi8pO1xuICByZXR1cm4ge1xuICAgIGxpbmU6IGxpbmVzLmxlbmd0aCxcblxuICAgIC8vIGNvbHVtbiBudW1iZXIgaXMgbGFzdCBsaW5lJ3MgbGVuZ3RoICsgMSwgYmVjYXVzZSBjb2x1bW4gbnVtYmVyaW5nIHN0YXJ0cyBhdCAxOlxuICAgIGNvbDogbGluZXNbbGluZXMubGVuZ3RoIC0gMV0ubGVuZ3RoICsgMVxuICB9O1xufVxuXG4vL3RoaXMgZnVuY3Rpb24gcmV0dXJucyB0aGUgcG9zaXRpb24gb2YgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBtYXRjaCB3aXRoaW4gYXR0clN0clxuZnVuY3Rpb24gZ2V0UG9zaXRpb25Gcm9tTWF0Y2gobWF0Y2gpIHtcbiAgcmV0dXJuIG1hdGNoLnN0YXJ0SW5kZXggKyBtYXRjaFsxXS5sZW5ndGg7XG59XG4iXSwibmFtZXMiOlsidXRpbCIsInJlcXVpcmUiLCJkZWZhdWx0T3B0aW9ucyIsImFsbG93Qm9vbGVhbkF0dHJpYnV0ZXMiLCJ1bnBhaXJlZFRhZ3MiLCJleHBvcnRzIiwidmFsaWRhdGUiLCJ4bWxEYXRhIiwib3B0aW9ucyIsIk9iamVjdCIsImFzc2lnbiIsInRhZ3MiLCJ0YWdGb3VuZCIsInJlYWNoZWRSb290Iiwic3Vic3RyIiwiaSIsImxlbmd0aCIsInJlYWRQSSIsImVyciIsInRhZ1N0YXJ0UG9zIiwicmVhZENvbW1lbnRBbmRDREFUQSIsImNsb3NpbmdUYWciLCJ0YWdOYW1lIiwidHJpbSIsInN1YnN0cmluZyIsInZhbGlkYXRlVGFnTmFtZSIsIm1zZyIsImdldEVycm9yT2JqZWN0IiwiZ2V0TGluZU51bWJlckZvclBvc2l0aW9uIiwicmVzdWx0IiwicmVhZEF0dHJpYnV0ZVN0ciIsImF0dHJTdHIiLCJ2YWx1ZSIsImluZGV4IiwiYXR0clN0clN0YXJ0IiwiaXNWYWxpZCIsInZhbGlkYXRlQXR0cmlidXRlU3RyaW5nIiwiY29kZSIsImxpbmUiLCJ0YWdDbG9zZWQiLCJvdGciLCJwb3AiLCJvcGVuUG9zIiwiY29sIiwiaW5kZXhPZiIsInB1c2giLCJhZnRlckFtcCIsInZhbGlkYXRlQW1wZXJzYW5kIiwiaXNXaGl0ZVNwYWNlIiwiSlNPTiIsInN0cmluZ2lmeSIsIm1hcCIsInQiLCJyZXBsYWNlIiwiY2hhciIsInN0YXJ0IiwidGFnbmFtZSIsImFuZ2xlQnJhY2tldHNDb3VudCIsImRvdWJsZVF1b3RlIiwic2luZ2xlUXVvdGUiLCJzdGFydENoYXIiLCJ2YWxpZEF0dHJTdHJSZWd4cCIsIlJlZ0V4cCIsIm1hdGNoZXMiLCJnZXRBbGxNYXRjaGVzIiwiYXR0ck5hbWVzIiwiZ2V0UG9zaXRpb25Gcm9tTWF0Y2giLCJ1bmRlZmluZWQiLCJhdHRyTmFtZSIsInZhbGlkYXRlQXR0ck5hbWUiLCJoYXNPd25Qcm9wZXJ0eSIsInZhbGlkYXRlTnVtYmVyQW1wZXJzYW5kIiwicmUiLCJtYXRjaCIsImNvdW50IiwibWVzc2FnZSIsImxpbmVOdW1iZXIiLCJpc05hbWUiLCJsaW5lcyIsInNwbGl0Iiwic3RhcnRJbmRleCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/fast-xml-parser/src/validator.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js":
/*!*****************************************************************!*\
  !*** ./node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n//parse Empty Node as self closing node\nconst buildFromOrderedJs = __webpack_require__(/*! ./orderedJs2Xml */ \"(ssr)/./node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js\");\nconst defaultOptions = {\n    attributeNamePrefix: \"@_\",\n    attributesGroupName: false,\n    textNodeName: \"#text\",\n    ignoreAttributes: true,\n    cdataPropName: false,\n    format: false,\n    indentBy: \"  \",\n    suppressEmptyNode: false,\n    suppressUnpairedNode: true,\n    suppressBooleanAttributes: true,\n    tagValueProcessor: function(key, a) {\n        return a;\n    },\n    attributeValueProcessor: function(attrName, a) {\n        return a;\n    },\n    preserveOrder: false,\n    commentPropName: false,\n    unpairedTags: [],\n    entities: [\n        {\n            regex: new RegExp(\"&\", \"g\"),\n            val: \"&amp;\"\n        },\n        {\n            regex: new RegExp(\">\", \"g\"),\n            val: \"&gt;\"\n        },\n        {\n            regex: new RegExp(\"<\", \"g\"),\n            val: \"&lt;\"\n        },\n        {\n            regex: new RegExp(\"'\", \"g\"),\n            val: \"&apos;\"\n        },\n        {\n            regex: new RegExp('\"', \"g\"),\n            val: \"&quot;\"\n        }\n    ],\n    processEntities: true,\n    stopNodes: [],\n    // transformTagName: false,\n    // transformAttributeName: false,\n    oneListGroup: false\n};\nfunction Builder(options) {\n    this.options = Object.assign({}, defaultOptions, options);\n    if (this.options.ignoreAttributes || this.options.attributesGroupName) {\n        this.isAttribute = function() {\n            return false;\n        };\n    } else {\n        this.attrPrefixLen = this.options.attributeNamePrefix.length;\n        this.isAttribute = isAttribute;\n    }\n    this.processTextOrObjNode = processTextOrObjNode;\n    if (this.options.format) {\n        this.indentate = indentate;\n        this.tagEndChar = \">\\n\";\n        this.newLine = \"\\n\";\n    } else {\n        this.indentate = function() {\n            return \"\";\n        };\n        this.tagEndChar = \">\";\n        this.newLine = \"\";\n    }\n}\nBuilder.prototype.build = function(jObj) {\n    if (this.options.preserveOrder) {\n        return buildFromOrderedJs(jObj, this.options);\n    } else {\n        if (Array.isArray(jObj) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1) {\n            jObj = {\n                [this.options.arrayNodeName]: jObj\n            };\n        }\n        return this.j2x(jObj, 0).val;\n    }\n};\nBuilder.prototype.j2x = function(jObj, level) {\n    let attrStr = \"\";\n    let val = \"\";\n    for(let key in jObj){\n        if (!Object.prototype.hasOwnProperty.call(jObj, key)) continue;\n        if (typeof jObj[key] === \"undefined\") {\n            // supress undefined node only if it is not an attribute\n            if (this.isAttribute(key)) {\n                val += \"\";\n            }\n        } else if (jObj[key] === null) {\n            // null attribute should be ignored by the attribute list, but should not cause the tag closing\n            if (this.isAttribute(key)) {\n                val += \"\";\n            } else if (key[0] === \"?\") {\n                val += this.indentate(level) + \"<\" + key + \"?\" + this.tagEndChar;\n            } else {\n                val += this.indentate(level) + \"<\" + key + \"/\" + this.tagEndChar;\n            }\n        // val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;\n        } else if (jObj[key] instanceof Date) {\n            val += this.buildTextValNode(jObj[key], key, \"\", level);\n        } else if (typeof jObj[key] !== \"object\") {\n            //premitive type\n            const attr = this.isAttribute(key);\n            if (attr) {\n                attrStr += this.buildAttrPairStr(attr, \"\" + jObj[key]);\n            } else {\n                //tag value\n                if (key === this.options.textNodeName) {\n                    let newval = this.options.tagValueProcessor(key, \"\" + jObj[key]);\n                    val += this.replaceEntitiesValue(newval);\n                } else {\n                    val += this.buildTextValNode(jObj[key], key, \"\", level);\n                }\n            }\n        } else if (Array.isArray(jObj[key])) {\n            //repeated nodes\n            const arrLen = jObj[key].length;\n            let listTagVal = \"\";\n            for(let j = 0; j < arrLen; j++){\n                const item = jObj[key][j];\n                if (typeof item === \"undefined\") {\n                // supress undefined node\n                } else if (item === null) {\n                    if (key[0] === \"?\") val += this.indentate(level) + \"<\" + key + \"?\" + this.tagEndChar;\n                    else val += this.indentate(level) + \"<\" + key + \"/\" + this.tagEndChar;\n                // val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;\n                } else if (typeof item === \"object\") {\n                    if (this.options.oneListGroup) {\n                        listTagVal += this.j2x(item, level + 1).val;\n                    } else {\n                        listTagVal += this.processTextOrObjNode(item, key, level);\n                    }\n                } else {\n                    listTagVal += this.buildTextValNode(item, key, \"\", level);\n                }\n            }\n            if (this.options.oneListGroup) {\n                listTagVal = this.buildObjectNode(listTagVal, key, \"\", level);\n            }\n            val += listTagVal;\n        } else {\n            //nested node\n            if (this.options.attributesGroupName && key === this.options.attributesGroupName) {\n                const Ks = Object.keys(jObj[key]);\n                const L = Ks.length;\n                for(let j = 0; j < L; j++){\n                    attrStr += this.buildAttrPairStr(Ks[j], \"\" + jObj[key][Ks[j]]);\n                }\n            } else {\n                val += this.processTextOrObjNode(jObj[key], key, level);\n            }\n        }\n    }\n    return {\n        attrStr: attrStr,\n        val: val\n    };\n};\nBuilder.prototype.buildAttrPairStr = function(attrName, val) {\n    val = this.options.attributeValueProcessor(attrName, \"\" + val);\n    val = this.replaceEntitiesValue(val);\n    if (this.options.suppressBooleanAttributes && val === \"true\") {\n        return \" \" + attrName;\n    } else return \" \" + attrName + '=\"' + val + '\"';\n};\nfunction processTextOrObjNode(object, key, level) {\n    const result = this.j2x(object, level + 1);\n    if (object[this.options.textNodeName] !== undefined && Object.keys(object).length === 1) {\n        return this.buildTextValNode(object[this.options.textNodeName], key, result.attrStr, level);\n    } else {\n        return this.buildObjectNode(result.val, key, result.attrStr, level);\n    }\n}\nBuilder.prototype.buildObjectNode = function(val, key, attrStr, level) {\n    if (val === \"\") {\n        if (key[0] === \"?\") return this.indentate(level) + \"<\" + key + attrStr + \"?\" + this.tagEndChar;\n        else {\n            return this.indentate(level) + \"<\" + key + attrStr + this.closeTag(key) + this.tagEndChar;\n        }\n    } else {\n        let tagEndExp = \"</\" + key + this.tagEndChar;\n        let piClosingChar = \"\";\n        if (key[0] === \"?\") {\n            piClosingChar = \"?\";\n            tagEndExp = \"\";\n        }\n        // attrStr is an empty string in case the attribute came as undefined or null\n        if ((attrStr || attrStr === \"\") && val.indexOf(\"<\") === -1) {\n            return this.indentate(level) + \"<\" + key + attrStr + piClosingChar + \">\" + val + tagEndExp;\n        } else if (this.options.commentPropName !== false && key === this.options.commentPropName && piClosingChar.length === 0) {\n            return this.indentate(level) + `<!--${val}-->` + this.newLine;\n        } else {\n            return this.indentate(level) + \"<\" + key + attrStr + piClosingChar + this.tagEndChar + val + this.indentate(level) + tagEndExp;\n        }\n    }\n};\nBuilder.prototype.closeTag = function(key) {\n    let closeTag = \"\";\n    if (this.options.unpairedTags.indexOf(key) !== -1) {\n        if (!this.options.suppressUnpairedNode) closeTag = \"/\";\n    } else if (this.options.suppressEmptyNode) {\n        closeTag = \"/\";\n    } else {\n        closeTag = `></${key}`;\n    }\n    return closeTag;\n};\nfunction buildEmptyObjNode(val, key, attrStr, level) {\n    if (val !== \"\") {\n        return this.buildObjectNode(val, key, attrStr, level);\n    } else {\n        if (key[0] === \"?\") return this.indentate(level) + \"<\" + key + attrStr + \"?\" + this.tagEndChar;\n        else {\n            return this.indentate(level) + \"<\" + key + attrStr + \"/\" + this.tagEndChar;\n        // return this.buildTagStr(level,key, attrStr);\n        }\n    }\n}\nBuilder.prototype.buildTextValNode = function(val, key, attrStr, level) {\n    if (this.options.cdataPropName !== false && key === this.options.cdataPropName) {\n        return this.indentate(level) + `<![CDATA[${val}]]>` + this.newLine;\n    } else if (this.options.commentPropName !== false && key === this.options.commentPropName) {\n        return this.indentate(level) + `<!--${val}-->` + this.newLine;\n    } else if (key[0] === \"?\") {\n        return this.indentate(level) + \"<\" + key + attrStr + \"?\" + this.tagEndChar;\n    } else {\n        let textValue = this.options.tagValueProcessor(key, val);\n        textValue = this.replaceEntitiesValue(textValue);\n        if (textValue === \"\") {\n            return this.indentate(level) + \"<\" + key + attrStr + this.closeTag(key) + this.tagEndChar;\n        } else {\n            return this.indentate(level) + \"<\" + key + attrStr + \">\" + textValue + \"</\" + key + this.tagEndChar;\n        }\n    }\n};\nBuilder.prototype.replaceEntitiesValue = function(textValue) {\n    if (textValue && textValue.length > 0 && this.options.processEntities) {\n        for(let i = 0; i < this.options.entities.length; i++){\n            const entity = this.options.entities[i];\n            textValue = textValue.replace(entity.regex, entity.val);\n        }\n    }\n    return textValue;\n};\nfunction indentate(level) {\n    return this.options.indentBy.repeat(level);\n}\nfunction isAttribute(name /*, options*/ ) {\n    if (name.startsWith(this.options.attributeNamePrefix) && name !== this.options.textNodeName) {\n        return name.substr(this.attrPrefixLen);\n    } else {\n        return false;\n    }\n}\nmodule.exports = Builder;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmFzdC14bWwtcGFyc2VyL3NyYy94bWxidWlsZGVyL2pzb24yeG1sLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsdUNBQXVDO0FBQ3ZDLE1BQU1BLHFCQUFxQkMsbUJBQU9BLENBQUM7QUFFbkMsTUFBTUMsaUJBQWlCO0lBQ3JCQyxxQkFBcUI7SUFDckJDLHFCQUFxQjtJQUNyQkMsY0FBYztJQUNkQyxrQkFBa0I7SUFDbEJDLGVBQWU7SUFDZkMsUUFBUTtJQUNSQyxVQUFVO0lBQ1ZDLG1CQUFtQjtJQUNuQkMsc0JBQXNCO0lBQ3RCQywyQkFBMkI7SUFDM0JDLG1CQUFtQixTQUFTQyxHQUFHLEVBQUVDLENBQUM7UUFDaEMsT0FBT0E7SUFDVDtJQUNBQyx5QkFBeUIsU0FBU0MsUUFBUSxFQUFFRixDQUFDO1FBQzNDLE9BQU9BO0lBQ1Q7SUFDQUcsZUFBZTtJQUNmQyxpQkFBaUI7SUFDakJDLGNBQWMsRUFBRTtJQUNoQkMsVUFBVTtRQUNSO1lBQUVDLE9BQU8sSUFBSUMsT0FBTyxLQUFLO1lBQU1DLEtBQUs7UUFBUTtRQUM1QztZQUFFRixPQUFPLElBQUlDLE9BQU8sS0FBSztZQUFNQyxLQUFLO1FBQU87UUFDM0M7WUFBRUYsT0FBTyxJQUFJQyxPQUFPLEtBQUs7WUFBTUMsS0FBSztRQUFPO1FBQzNDO1lBQUVGLE9BQU8sSUFBSUMsT0FBTyxLQUFNO1lBQU1DLEtBQUs7UUFBUztRQUM5QztZQUFFRixPQUFPLElBQUlDLE9BQU8sS0FBTTtZQUFNQyxLQUFLO1FBQVM7S0FDL0M7SUFDREMsaUJBQWlCO0lBQ2pCQyxXQUFXLEVBQUU7SUFDYiwyQkFBMkI7SUFDM0IsaUNBQWlDO0lBQ2pDQyxjQUFjO0FBQ2hCO0FBRUEsU0FBU0MsUUFBUUMsT0FBTztJQUN0QixJQUFJLENBQUNBLE9BQU8sR0FBR0MsT0FBT0MsTUFBTSxDQUFDLENBQUMsR0FBRzdCLGdCQUFnQjJCO0lBQ2pELElBQUksSUFBSSxDQUFDQSxPQUFPLENBQUN2QixnQkFBZ0IsSUFBSSxJQUFJLENBQUN1QixPQUFPLENBQUN6QixtQkFBbUIsRUFBRTtRQUNyRSxJQUFJLENBQUM0QixXQUFXLEdBQUc7WUFDakIsT0FBTztRQUNUO0lBQ0YsT0FBTztRQUNMLElBQUksQ0FBQ0MsYUFBYSxHQUFHLElBQUksQ0FBQ0osT0FBTyxDQUFDMUIsbUJBQW1CLENBQUMrQixNQUFNO1FBQzVELElBQUksQ0FBQ0YsV0FBVyxHQUFHQTtJQUNyQjtJQUVBLElBQUksQ0FBQ0csb0JBQW9CLEdBQUdBO0lBRTVCLElBQUksSUFBSSxDQUFDTixPQUFPLENBQUNyQixNQUFNLEVBQUU7UUFDdkIsSUFBSSxDQUFDNEIsU0FBUyxHQUFHQTtRQUNqQixJQUFJLENBQUNDLFVBQVUsR0FBRztRQUNsQixJQUFJLENBQUNDLE9BQU8sR0FBRztJQUNqQixPQUFPO1FBQ0wsSUFBSSxDQUFDRixTQUFTLEdBQUc7WUFDZixPQUFPO1FBQ1Q7UUFDQSxJQUFJLENBQUNDLFVBQVUsR0FBRztRQUNsQixJQUFJLENBQUNDLE9BQU8sR0FBRztJQUNqQjtBQUNGO0FBRUFWLFFBQVFXLFNBQVMsQ0FBQ0MsS0FBSyxHQUFHLFNBQVNDLElBQUk7SUFDckMsSUFBRyxJQUFJLENBQUNaLE9BQU8sQ0FBQ1gsYUFBYSxFQUFDO1FBQzVCLE9BQU9sQixtQkFBbUJ5QyxNQUFNLElBQUksQ0FBQ1osT0FBTztJQUM5QyxPQUFNO1FBQ0osSUFBR2EsTUFBTUMsT0FBTyxDQUFDRixTQUFTLElBQUksQ0FBQ1osT0FBTyxDQUFDZSxhQUFhLElBQUksSUFBSSxDQUFDZixPQUFPLENBQUNlLGFBQWEsQ0FBQ1YsTUFBTSxHQUFHLEdBQUU7WUFDNUZPLE9BQU87Z0JBQ0wsQ0FBQyxJQUFJLENBQUNaLE9BQU8sQ0FBQ2UsYUFBYSxDQUFDLEVBQUdIO1lBQ2pDO1FBQ0Y7UUFDQSxPQUFPLElBQUksQ0FBQ0ksR0FBRyxDQUFDSixNQUFNLEdBQUdqQixHQUFHO0lBQzlCO0FBQ0Y7QUFFQUksUUFBUVcsU0FBUyxDQUFDTSxHQUFHLEdBQUcsU0FBU0osSUFBSSxFQUFFSyxLQUFLO0lBQzFDLElBQUlDLFVBQVU7SUFDZCxJQUFJdkIsTUFBTTtJQUNWLElBQUssSUFBSVYsT0FBTzJCLEtBQU07UUFDcEIsSUFBRyxDQUFDWCxPQUFPUyxTQUFTLENBQUNTLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDUixNQUFNM0IsTUFBTTtRQUNyRCxJQUFJLE9BQU8yQixJQUFJLENBQUMzQixJQUFJLEtBQUssYUFBYTtZQUNwQyx3REFBd0Q7WUFDeEQsSUFBSSxJQUFJLENBQUNrQixXQUFXLENBQUNsQixNQUFNO2dCQUN6QlUsT0FBTztZQUNUO1FBQ0YsT0FBTyxJQUFJaUIsSUFBSSxDQUFDM0IsSUFBSSxLQUFLLE1BQU07WUFDN0IsK0ZBQStGO1lBQy9GLElBQUksSUFBSSxDQUFDa0IsV0FBVyxDQUFDbEIsTUFBTTtnQkFDekJVLE9BQU87WUFDVCxPQUFPLElBQUlWLEdBQUcsQ0FBQyxFQUFFLEtBQUssS0FBSztnQkFDekJVLE9BQU8sSUFBSSxDQUFDWSxTQUFTLENBQUNVLFNBQVMsTUFBTWhDLE1BQU0sTUFBTSxJQUFJLENBQUN1QixVQUFVO1lBQ2xFLE9BQU87Z0JBQ0xiLE9BQU8sSUFBSSxDQUFDWSxTQUFTLENBQUNVLFNBQVMsTUFBTWhDLE1BQU0sTUFBTSxJQUFJLENBQUN1QixVQUFVO1lBQ2xFO1FBQ0Esb0VBQW9FO1FBQ3RFLE9BQU8sSUFBSUksSUFBSSxDQUFDM0IsSUFBSSxZQUFZb0MsTUFBTTtZQUNwQzFCLE9BQU8sSUFBSSxDQUFDMkIsZ0JBQWdCLENBQUNWLElBQUksQ0FBQzNCLElBQUksRUFBRUEsS0FBSyxJQUFJZ0M7UUFDbkQsT0FBTyxJQUFJLE9BQU9MLElBQUksQ0FBQzNCLElBQUksS0FBSyxVQUFVO1lBQ3hDLGdCQUFnQjtZQUNoQixNQUFNc0MsT0FBTyxJQUFJLENBQUNwQixXQUFXLENBQUNsQjtZQUM5QixJQUFJc0MsTUFBTTtnQkFDUkwsV0FBVyxJQUFJLENBQUNNLGdCQUFnQixDQUFDRCxNQUFNLEtBQUtYLElBQUksQ0FBQzNCLElBQUk7WUFDdkQsT0FBTTtnQkFDSixXQUFXO2dCQUNYLElBQUlBLFFBQVEsSUFBSSxDQUFDZSxPQUFPLENBQUN4QixZQUFZLEVBQUU7b0JBQ3JDLElBQUlpRCxTQUFTLElBQUksQ0FBQ3pCLE9BQU8sQ0FBQ2hCLGlCQUFpQixDQUFDQyxLQUFLLEtBQUsyQixJQUFJLENBQUMzQixJQUFJO29CQUMvRFUsT0FBTyxJQUFJLENBQUMrQixvQkFBb0IsQ0FBQ0Q7Z0JBQ25DLE9BQU87b0JBQ0w5QixPQUFPLElBQUksQ0FBQzJCLGdCQUFnQixDQUFDVixJQUFJLENBQUMzQixJQUFJLEVBQUVBLEtBQUssSUFBSWdDO2dCQUNuRDtZQUNGO1FBQ0YsT0FBTyxJQUFJSixNQUFNQyxPQUFPLENBQUNGLElBQUksQ0FBQzNCLElBQUksR0FBRztZQUNuQyxnQkFBZ0I7WUFDaEIsTUFBTTBDLFNBQVNmLElBQUksQ0FBQzNCLElBQUksQ0FBQ29CLE1BQU07WUFDL0IsSUFBSXVCLGFBQWE7WUFDakIsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlGLFFBQVFFLElBQUs7Z0JBQy9CLE1BQU1DLE9BQU9sQixJQUFJLENBQUMzQixJQUFJLENBQUM0QyxFQUFFO2dCQUN6QixJQUFJLE9BQU9DLFNBQVMsYUFBYTtnQkFDL0IseUJBQXlCO2dCQUMzQixPQUFPLElBQUlBLFNBQVMsTUFBTTtvQkFDeEIsSUFBRzdDLEdBQUcsQ0FBQyxFQUFFLEtBQUssS0FBS1UsT0FBTyxJQUFJLENBQUNZLFNBQVMsQ0FBQ1UsU0FBUyxNQUFNaEMsTUFBTSxNQUFNLElBQUksQ0FBQ3VCLFVBQVU7eUJBQzlFYixPQUFPLElBQUksQ0FBQ1ksU0FBUyxDQUFDVSxTQUFTLE1BQU1oQyxNQUFNLE1BQU0sSUFBSSxDQUFDdUIsVUFBVTtnQkFDckUsb0VBQW9FO2dCQUN0RSxPQUFPLElBQUksT0FBT3NCLFNBQVMsVUFBVTtvQkFDbkMsSUFBRyxJQUFJLENBQUM5QixPQUFPLENBQUNGLFlBQVksRUFBRTt3QkFDNUI4QixjQUFjLElBQUksQ0FBQ1osR0FBRyxDQUFDYyxNQUFNYixRQUFRLEdBQUd0QixHQUFHO29CQUM3QyxPQUFLO3dCQUNIaUMsY0FBYyxJQUFJLENBQUN0QixvQkFBb0IsQ0FBQ3dCLE1BQU03QyxLQUFLZ0M7b0JBQ3JEO2dCQUNGLE9BQU87b0JBQ0xXLGNBQWMsSUFBSSxDQUFDTixnQkFBZ0IsQ0FBQ1EsTUFBTTdDLEtBQUssSUFBSWdDO2dCQUNyRDtZQUNGO1lBQ0EsSUFBRyxJQUFJLENBQUNqQixPQUFPLENBQUNGLFlBQVksRUFBQztnQkFDM0I4QixhQUFhLElBQUksQ0FBQ0csZUFBZSxDQUFDSCxZQUFZM0MsS0FBSyxJQUFJZ0M7WUFDekQ7WUFDQXRCLE9BQU9pQztRQUNULE9BQU87WUFDTCxhQUFhO1lBQ2IsSUFBSSxJQUFJLENBQUM1QixPQUFPLENBQUN6QixtQkFBbUIsSUFBSVUsUUFBUSxJQUFJLENBQUNlLE9BQU8sQ0FBQ3pCLG1CQUFtQixFQUFFO2dCQUNoRixNQUFNeUQsS0FBSy9CLE9BQU9nQyxJQUFJLENBQUNyQixJQUFJLENBQUMzQixJQUFJO2dCQUNoQyxNQUFNaUQsSUFBSUYsR0FBRzNCLE1BQU07Z0JBQ25CLElBQUssSUFBSXdCLElBQUksR0FBR0EsSUFBSUssR0FBR0wsSUFBSztvQkFDMUJYLFdBQVcsSUFBSSxDQUFDTSxnQkFBZ0IsQ0FBQ1EsRUFBRSxDQUFDSCxFQUFFLEVBQUUsS0FBS2pCLElBQUksQ0FBQzNCLElBQUksQ0FBQytDLEVBQUUsQ0FBQ0gsRUFBRSxDQUFDO2dCQUMvRDtZQUNGLE9BQU87Z0JBQ0xsQyxPQUFPLElBQUksQ0FBQ1csb0JBQW9CLENBQUNNLElBQUksQ0FBQzNCLElBQUksRUFBRUEsS0FBS2dDO1lBQ25EO1FBQ0Y7SUFDRjtJQUNBLE9BQU87UUFBQ0MsU0FBU0E7UUFBU3ZCLEtBQUtBO0lBQUc7QUFDcEM7QUFFQUksUUFBUVcsU0FBUyxDQUFDYyxnQkFBZ0IsR0FBRyxTQUFTcEMsUUFBUSxFQUFFTyxHQUFHO0lBQ3pEQSxNQUFNLElBQUksQ0FBQ0ssT0FBTyxDQUFDYix1QkFBdUIsQ0FBQ0MsVUFBVSxLQUFLTztJQUMxREEsTUFBTSxJQUFJLENBQUMrQixvQkFBb0IsQ0FBQy9CO0lBQ2hDLElBQUksSUFBSSxDQUFDSyxPQUFPLENBQUNqQix5QkFBeUIsSUFBSVksUUFBUSxRQUFRO1FBQzVELE9BQU8sTUFBTVA7SUFDZixPQUFPLE9BQU8sTUFBTUEsV0FBVyxPQUFPTyxNQUFNO0FBQzlDO0FBRUEsU0FBU1cscUJBQXNCNkIsTUFBTSxFQUFFbEQsR0FBRyxFQUFFZ0MsS0FBSztJQUMvQyxNQUFNbUIsU0FBUyxJQUFJLENBQUNwQixHQUFHLENBQUNtQixRQUFRbEIsUUFBUTtJQUN4QyxJQUFJa0IsTUFBTSxDQUFDLElBQUksQ0FBQ25DLE9BQU8sQ0FBQ3hCLFlBQVksQ0FBQyxLQUFLNkQsYUFBYXBDLE9BQU9nQyxJQUFJLENBQUNFLFFBQVE5QixNQUFNLEtBQUssR0FBRztRQUN2RixPQUFPLElBQUksQ0FBQ2lCLGdCQUFnQixDQUFDYSxNQUFNLENBQUMsSUFBSSxDQUFDbkMsT0FBTyxDQUFDeEIsWUFBWSxDQUFDLEVBQUVTLEtBQUttRCxPQUFPbEIsT0FBTyxFQUFFRDtJQUN2RixPQUFPO1FBQ0wsT0FBTyxJQUFJLENBQUNjLGVBQWUsQ0FBQ0ssT0FBT3pDLEdBQUcsRUFBRVYsS0FBS21ELE9BQU9sQixPQUFPLEVBQUVEO0lBQy9EO0FBQ0Y7QUFFQWxCLFFBQVFXLFNBQVMsQ0FBQ3FCLGVBQWUsR0FBRyxTQUFTcEMsR0FBRyxFQUFFVixHQUFHLEVBQUVpQyxPQUFPLEVBQUVELEtBQUs7SUFDbkUsSUFBR3RCLFFBQVEsSUFBRztRQUNaLElBQUdWLEdBQUcsQ0FBQyxFQUFFLEtBQUssS0FBSyxPQUFRLElBQUksQ0FBQ3NCLFNBQVMsQ0FBQ1UsU0FBUyxNQUFNaEMsTUFBTWlDLFVBQVMsTUFBTSxJQUFJLENBQUNWLFVBQVU7YUFDeEY7WUFDSCxPQUFPLElBQUksQ0FBQ0QsU0FBUyxDQUFDVSxTQUFTLE1BQU1oQyxNQUFNaUMsVUFBVSxJQUFJLENBQUNvQixRQUFRLENBQUNyRCxPQUFPLElBQUksQ0FBQ3VCLFVBQVU7UUFDM0Y7SUFDRixPQUFLO1FBRUgsSUFBSStCLFlBQVksT0FBT3RELE1BQU0sSUFBSSxDQUFDdUIsVUFBVTtRQUM1QyxJQUFJZ0MsZ0JBQWdCO1FBRXBCLElBQUd2RCxHQUFHLENBQUMsRUFBRSxLQUFLLEtBQUs7WUFDakJ1RCxnQkFBZ0I7WUFDaEJELFlBQVk7UUFDZDtRQUVBLDZFQUE2RTtRQUM3RSxJQUFJLENBQUNyQixXQUFXQSxZQUFZLEVBQUMsS0FBTXZCLElBQUk4QyxPQUFPLENBQUMsU0FBUyxDQUFDLEdBQUc7WUFDMUQsT0FBUyxJQUFJLENBQUNsQyxTQUFTLENBQUNVLFNBQVMsTUFBT2hDLE1BQU1pQyxVQUFVc0IsZ0JBQWdCLE1BQU03QyxNQUFNNEM7UUFDdEYsT0FBTyxJQUFJLElBQUksQ0FBQ3ZDLE9BQU8sQ0FBQ1YsZUFBZSxLQUFLLFNBQVNMLFFBQVEsSUFBSSxDQUFDZSxPQUFPLENBQUNWLGVBQWUsSUFBSWtELGNBQWNuQyxNQUFNLEtBQUssR0FBRztZQUN2SCxPQUFPLElBQUksQ0FBQ0UsU0FBUyxDQUFDVSxTQUFTLENBQUMsSUFBSSxFQUFFdEIsSUFBSSxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUNjLE9BQU87UUFDL0QsT0FBTTtZQUNKLE9BQ0UsSUFBSSxDQUFDRixTQUFTLENBQUNVLFNBQVMsTUFBTWhDLE1BQU1pQyxVQUFVc0IsZ0JBQWdCLElBQUksQ0FBQ2hDLFVBQVUsR0FDN0ViLE1BQ0EsSUFBSSxDQUFDWSxTQUFTLENBQUNVLFNBQVNzQjtRQUM1QjtJQUNGO0FBQ0Y7QUFFQXhDLFFBQVFXLFNBQVMsQ0FBQzRCLFFBQVEsR0FBRyxTQUFTckQsR0FBRztJQUN2QyxJQUFJcUQsV0FBVztJQUNmLElBQUcsSUFBSSxDQUFDdEMsT0FBTyxDQUFDVCxZQUFZLENBQUNrRCxPQUFPLENBQUN4RCxTQUFTLENBQUMsR0FBRTtRQUMvQyxJQUFHLENBQUMsSUFBSSxDQUFDZSxPQUFPLENBQUNsQixvQkFBb0IsRUFBRXdELFdBQVc7SUFDcEQsT0FBTSxJQUFHLElBQUksQ0FBQ3RDLE9BQU8sQ0FBQ25CLGlCQUFpQixFQUFDO1FBQ3RDeUQsV0FBVztJQUNiLE9BQUs7UUFDSEEsV0FBVyxDQUFDLEdBQUcsRUFBRXJELElBQUksQ0FBQztJQUN4QjtJQUNBLE9BQU9xRDtBQUNUO0FBRUEsU0FBU0ksa0JBQWtCL0MsR0FBRyxFQUFFVixHQUFHLEVBQUVpQyxPQUFPLEVBQUVELEtBQUs7SUFDakQsSUFBSXRCLFFBQVEsSUFBSTtRQUNkLE9BQU8sSUFBSSxDQUFDb0MsZUFBZSxDQUFDcEMsS0FBS1YsS0FBS2lDLFNBQVNEO0lBQ2pELE9BQU87UUFDTCxJQUFHaEMsR0FBRyxDQUFDLEVBQUUsS0FBSyxLQUFLLE9BQVEsSUFBSSxDQUFDc0IsU0FBUyxDQUFDVSxTQUFTLE1BQU1oQyxNQUFNaUMsVUFBUyxNQUFNLElBQUksQ0FBQ1YsVUFBVTthQUN4RjtZQUNILE9BQVEsSUFBSSxDQUFDRCxTQUFTLENBQUNVLFNBQVMsTUFBTWhDLE1BQU1pQyxVQUFVLE1BQU0sSUFBSSxDQUFDVixVQUFVO1FBQzNFLCtDQUErQztRQUNqRDtJQUNGO0FBQ0Y7QUFFQVQsUUFBUVcsU0FBUyxDQUFDWSxnQkFBZ0IsR0FBRyxTQUFTM0IsR0FBRyxFQUFFVixHQUFHLEVBQUVpQyxPQUFPLEVBQUVELEtBQUs7SUFDcEUsSUFBSSxJQUFJLENBQUNqQixPQUFPLENBQUN0QixhQUFhLEtBQUssU0FBU08sUUFBUSxJQUFJLENBQUNlLE9BQU8sQ0FBQ3RCLGFBQWEsRUFBRTtRQUM5RSxPQUFPLElBQUksQ0FBQzZCLFNBQVMsQ0FBQ1UsU0FBUyxDQUFDLFNBQVMsRUFBRXRCLElBQUksR0FBRyxDQUFDLEdBQUksSUFBSSxDQUFDYyxPQUFPO0lBQ3JFLE9BQU0sSUFBSSxJQUFJLENBQUNULE9BQU8sQ0FBQ1YsZUFBZSxLQUFLLFNBQVNMLFFBQVEsSUFBSSxDQUFDZSxPQUFPLENBQUNWLGVBQWUsRUFBRTtRQUN4RixPQUFPLElBQUksQ0FBQ2lCLFNBQVMsQ0FBQ1UsU0FBUyxDQUFDLElBQUksRUFBRXRCLElBQUksR0FBRyxDQUFDLEdBQUksSUFBSSxDQUFDYyxPQUFPO0lBQ2hFLE9BQU0sSUFBR3hCLEdBQUcsQ0FBQyxFQUFFLEtBQUssS0FBSztRQUN2QixPQUFRLElBQUksQ0FBQ3NCLFNBQVMsQ0FBQ1UsU0FBUyxNQUFNaEMsTUFBTWlDLFVBQVMsTUFBTSxJQUFJLENBQUNWLFVBQVU7SUFDNUUsT0FBSztRQUNILElBQUltQyxZQUFZLElBQUksQ0FBQzNDLE9BQU8sQ0FBQ2hCLGlCQUFpQixDQUFDQyxLQUFLVTtRQUNwRGdELFlBQVksSUFBSSxDQUFDakIsb0JBQW9CLENBQUNpQjtRQUV0QyxJQUFJQSxjQUFjLElBQUc7WUFDbkIsT0FBTyxJQUFJLENBQUNwQyxTQUFTLENBQUNVLFNBQVMsTUFBTWhDLE1BQU1pQyxVQUFVLElBQUksQ0FBQ29CLFFBQVEsQ0FBQ3JELE9BQU8sSUFBSSxDQUFDdUIsVUFBVTtRQUMzRixPQUFLO1lBQ0gsT0FBTyxJQUFJLENBQUNELFNBQVMsQ0FBQ1UsU0FBUyxNQUFNaEMsTUFBTWlDLFVBQVUsTUFDbER5QixZQUNELE9BQU8xRCxNQUFNLElBQUksQ0FBQ3VCLFVBQVU7UUFDaEM7SUFDRjtBQUNGO0FBRUFULFFBQVFXLFNBQVMsQ0FBQ2dCLG9CQUFvQixHQUFHLFNBQVNpQixTQUFTO0lBQ3pELElBQUdBLGFBQWFBLFVBQVV0QyxNQUFNLEdBQUcsS0FBSyxJQUFJLENBQUNMLE9BQU8sQ0FBQ0osZUFBZSxFQUFDO1FBQ25FLElBQUssSUFBSWdELElBQUUsR0FBR0EsSUFBRSxJQUFJLENBQUM1QyxPQUFPLENBQUNSLFFBQVEsQ0FBQ2EsTUFBTSxFQUFFdUMsSUFBSztZQUNqRCxNQUFNQyxTQUFTLElBQUksQ0FBQzdDLE9BQU8sQ0FBQ1IsUUFBUSxDQUFDb0QsRUFBRTtZQUN2Q0QsWUFBWUEsVUFBVUcsT0FBTyxDQUFDRCxPQUFPcEQsS0FBSyxFQUFFb0QsT0FBT2xELEdBQUc7UUFDeEQ7SUFDRjtJQUNBLE9BQU9nRDtBQUNUO0FBRUEsU0FBU3BDLFVBQVVVLEtBQUs7SUFDdEIsT0FBTyxJQUFJLENBQUNqQixPQUFPLENBQUNwQixRQUFRLENBQUNtRSxNQUFNLENBQUM5QjtBQUN0QztBQUVBLFNBQVNkLFlBQVk2QyxLQUFLLFdBQVcsR0FBWjtJQUN2QixJQUFJQSxLQUFLQyxVQUFVLENBQUMsSUFBSSxDQUFDakQsT0FBTyxDQUFDMUIsbUJBQW1CLEtBQUswRSxTQUFTLElBQUksQ0FBQ2hELE9BQU8sQ0FBQ3hCLFlBQVksRUFBRTtRQUMzRixPQUFPd0UsS0FBS0UsTUFBTSxDQUFDLElBQUksQ0FBQzlDLGFBQWE7SUFDdkMsT0FBTztRQUNMLE9BQU87SUFDVDtBQUNGO0FBRUErQyxPQUFPQyxPQUFPLEdBQUdyRCIsInNvdXJjZXMiOlsid2VicGFjazovL3RoZS1ncmlkLTIvLi9ub2RlX21vZHVsZXMvZmFzdC14bWwtcGFyc2VyL3NyYy94bWxidWlsZGVyL2pzb24yeG1sLmpzP2VkYTAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuLy9wYXJzZSBFbXB0eSBOb2RlIGFzIHNlbGYgY2xvc2luZyBub2RlXG5jb25zdCBidWlsZEZyb21PcmRlcmVkSnMgPSByZXF1aXJlKCcuL29yZGVyZWRKczJYbWwnKTtcblxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIGF0dHJpYnV0ZU5hbWVQcmVmaXg6ICdAXycsXG4gIGF0dHJpYnV0ZXNHcm91cE5hbWU6IGZhbHNlLFxuICB0ZXh0Tm9kZU5hbWU6ICcjdGV4dCcsXG4gIGlnbm9yZUF0dHJpYnV0ZXM6IHRydWUsXG4gIGNkYXRhUHJvcE5hbWU6IGZhbHNlLFxuICBmb3JtYXQ6IGZhbHNlLFxuICBpbmRlbnRCeTogJyAgJyxcbiAgc3VwcHJlc3NFbXB0eU5vZGU6IGZhbHNlLFxuICBzdXBwcmVzc1VucGFpcmVkTm9kZTogdHJ1ZSxcbiAgc3VwcHJlc3NCb29sZWFuQXR0cmlidXRlczogdHJ1ZSxcbiAgdGFnVmFsdWVQcm9jZXNzb3I6IGZ1bmN0aW9uKGtleSwgYSkge1xuICAgIHJldHVybiBhO1xuICB9LFxuICBhdHRyaWJ1dGVWYWx1ZVByb2Nlc3NvcjogZnVuY3Rpb24oYXR0ck5hbWUsIGEpIHtcbiAgICByZXR1cm4gYTtcbiAgfSxcbiAgcHJlc2VydmVPcmRlcjogZmFsc2UsXG4gIGNvbW1lbnRQcm9wTmFtZTogZmFsc2UsXG4gIHVucGFpcmVkVGFnczogW10sXG4gIGVudGl0aWVzOiBbXG4gICAgeyByZWdleDogbmV3IFJlZ0V4cChcIiZcIiwgXCJnXCIpLCB2YWw6IFwiJmFtcDtcIiB9LC8vaXQgbXVzdCBiZSBvbiB0b3BcbiAgICB7IHJlZ2V4OiBuZXcgUmVnRXhwKFwiPlwiLCBcImdcIiksIHZhbDogXCImZ3Q7XCIgfSxcbiAgICB7IHJlZ2V4OiBuZXcgUmVnRXhwKFwiPFwiLCBcImdcIiksIHZhbDogXCImbHQ7XCIgfSxcbiAgICB7IHJlZ2V4OiBuZXcgUmVnRXhwKFwiXFwnXCIsIFwiZ1wiKSwgdmFsOiBcIiZhcG9zO1wiIH0sXG4gICAgeyByZWdleDogbmV3IFJlZ0V4cChcIlxcXCJcIiwgXCJnXCIpLCB2YWw6IFwiJnF1b3Q7XCIgfVxuICBdLFxuICBwcm9jZXNzRW50aXRpZXM6IHRydWUsXG4gIHN0b3BOb2RlczogW10sXG4gIC8vIHRyYW5zZm9ybVRhZ05hbWU6IGZhbHNlLFxuICAvLyB0cmFuc2Zvcm1BdHRyaWJ1dGVOYW1lOiBmYWxzZSxcbiAgb25lTGlzdEdyb3VwOiBmYWxzZVxufTtcblxuZnVuY3Rpb24gQnVpbGRlcihvcHRpb25zKSB7XG4gIHRoaXMub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKTtcbiAgaWYgKHRoaXMub3B0aW9ucy5pZ25vcmVBdHRyaWJ1dGVzIHx8IHRoaXMub3B0aW9ucy5hdHRyaWJ1dGVzR3JvdXBOYW1lKSB7XG4gICAgdGhpcy5pc0F0dHJpYnV0ZSA9IGZ1bmN0aW9uKC8qYSovKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmF0dHJQcmVmaXhMZW4gPSB0aGlzLm9wdGlvbnMuYXR0cmlidXRlTmFtZVByZWZpeC5sZW5ndGg7XG4gICAgdGhpcy5pc0F0dHJpYnV0ZSA9IGlzQXR0cmlidXRlO1xuICB9XG5cbiAgdGhpcy5wcm9jZXNzVGV4dE9yT2JqTm9kZSA9IHByb2Nlc3NUZXh0T3JPYmpOb2RlXG5cbiAgaWYgKHRoaXMub3B0aW9ucy5mb3JtYXQpIHtcbiAgICB0aGlzLmluZGVudGF0ZSA9IGluZGVudGF0ZTtcbiAgICB0aGlzLnRhZ0VuZENoYXIgPSAnPlxcbic7XG4gICAgdGhpcy5uZXdMaW5lID0gJ1xcbic7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5pbmRlbnRhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9O1xuICAgIHRoaXMudGFnRW5kQ2hhciA9ICc+JztcbiAgICB0aGlzLm5ld0xpbmUgPSAnJztcbiAgfVxufVxuXG5CdWlsZGVyLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uKGpPYmopIHtcbiAgaWYodGhpcy5vcHRpb25zLnByZXNlcnZlT3JkZXIpe1xuICAgIHJldHVybiBidWlsZEZyb21PcmRlcmVkSnMoak9iaiwgdGhpcy5vcHRpb25zKTtcbiAgfWVsc2Uge1xuICAgIGlmKEFycmF5LmlzQXJyYXkoak9iaikgJiYgdGhpcy5vcHRpb25zLmFycmF5Tm9kZU5hbWUgJiYgdGhpcy5vcHRpb25zLmFycmF5Tm9kZU5hbWUubGVuZ3RoID4gMSl7XG4gICAgICBqT2JqID0ge1xuICAgICAgICBbdGhpcy5vcHRpb25zLmFycmF5Tm9kZU5hbWVdIDogak9ialxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5qMngoak9iaiwgMCkudmFsO1xuICB9XG59O1xuXG5CdWlsZGVyLnByb3RvdHlwZS5qMnggPSBmdW5jdGlvbihqT2JqLCBsZXZlbCkge1xuICBsZXQgYXR0clN0ciA9ICcnO1xuICBsZXQgdmFsID0gJyc7XG4gIGZvciAobGV0IGtleSBpbiBqT2JqKSB7XG4gICAgaWYoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChqT2JqLCBrZXkpKSBjb250aW51ZTtcbiAgICBpZiAodHlwZW9mIGpPYmpba2V5XSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIHN1cHJlc3MgdW5kZWZpbmVkIG5vZGUgb25seSBpZiBpdCBpcyBub3QgYW4gYXR0cmlidXRlXG4gICAgICBpZiAodGhpcy5pc0F0dHJpYnV0ZShrZXkpKSB7XG4gICAgICAgIHZhbCArPSAnJztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGpPYmpba2V5XSA9PT0gbnVsbCkge1xuICAgICAgLy8gbnVsbCBhdHRyaWJ1dGUgc2hvdWxkIGJlIGlnbm9yZWQgYnkgdGhlIGF0dHJpYnV0ZSBsaXN0LCBidXQgc2hvdWxkIG5vdCBjYXVzZSB0aGUgdGFnIGNsb3NpbmdcbiAgICAgIGlmICh0aGlzLmlzQXR0cmlidXRlKGtleSkpIHtcbiAgICAgICAgdmFsICs9ICcnO1xuICAgICAgfSBlbHNlIGlmIChrZXlbMF0gPT09ICc/Jykge1xuICAgICAgICB2YWwgKz0gdGhpcy5pbmRlbnRhdGUobGV2ZWwpICsgJzwnICsga2V5ICsgJz8nICsgdGhpcy50YWdFbmRDaGFyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsICs9IHRoaXMuaW5kZW50YXRlKGxldmVsKSArICc8JyArIGtleSArICcvJyArIHRoaXMudGFnRW5kQ2hhcjtcbiAgICAgIH1cbiAgICAgIC8vIHZhbCArPSB0aGlzLmluZGVudGF0ZShsZXZlbCkgKyAnPCcgKyBrZXkgKyAnLycgKyB0aGlzLnRhZ0VuZENoYXI7XG4gICAgfSBlbHNlIGlmIChqT2JqW2tleV0gaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICB2YWwgKz0gdGhpcy5idWlsZFRleHRWYWxOb2RlKGpPYmpba2V5XSwga2V5LCAnJywgbGV2ZWwpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGpPYmpba2V5XSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIC8vcHJlbWl0aXZlIHR5cGVcbiAgICAgIGNvbnN0IGF0dHIgPSB0aGlzLmlzQXR0cmlidXRlKGtleSk7XG4gICAgICBpZiAoYXR0cikge1xuICAgICAgICBhdHRyU3RyICs9IHRoaXMuYnVpbGRBdHRyUGFpclN0cihhdHRyLCAnJyArIGpPYmpba2V5XSk7XG4gICAgICB9ZWxzZSB7XG4gICAgICAgIC8vdGFnIHZhbHVlXG4gICAgICAgIGlmIChrZXkgPT09IHRoaXMub3B0aW9ucy50ZXh0Tm9kZU5hbWUpIHtcbiAgICAgICAgICBsZXQgbmV3dmFsID0gdGhpcy5vcHRpb25zLnRhZ1ZhbHVlUHJvY2Vzc29yKGtleSwgJycgKyBqT2JqW2tleV0pO1xuICAgICAgICAgIHZhbCArPSB0aGlzLnJlcGxhY2VFbnRpdGllc1ZhbHVlKG5ld3ZhbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsICs9IHRoaXMuYnVpbGRUZXh0VmFsTm9kZShqT2JqW2tleV0sIGtleSwgJycsIGxldmVsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShqT2JqW2tleV0pKSB7XG4gICAgICAvL3JlcGVhdGVkIG5vZGVzXG4gICAgICBjb25zdCBhcnJMZW4gPSBqT2JqW2tleV0ubGVuZ3RoO1xuICAgICAgbGV0IGxpc3RUYWdWYWwgPSBcIlwiO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBhcnJMZW47IGorKykge1xuICAgICAgICBjb25zdCBpdGVtID0gak9ialtrZXldW2pdO1xuICAgICAgICBpZiAodHlwZW9mIGl0ZW0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgLy8gc3VwcmVzcyB1bmRlZmluZWQgbm9kZVxuICAgICAgICB9IGVsc2UgaWYgKGl0ZW0gPT09IG51bGwpIHtcbiAgICAgICAgICBpZihrZXlbMF0gPT09IFwiP1wiKSB2YWwgKz0gdGhpcy5pbmRlbnRhdGUobGV2ZWwpICsgJzwnICsga2V5ICsgJz8nICsgdGhpcy50YWdFbmRDaGFyO1xuICAgICAgICAgIGVsc2UgdmFsICs9IHRoaXMuaW5kZW50YXRlKGxldmVsKSArICc8JyArIGtleSArICcvJyArIHRoaXMudGFnRW5kQ2hhcjtcbiAgICAgICAgICAvLyB2YWwgKz0gdGhpcy5pbmRlbnRhdGUobGV2ZWwpICsgJzwnICsga2V5ICsgJy8nICsgdGhpcy50YWdFbmRDaGFyO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpdGVtID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGlmKHRoaXMub3B0aW9ucy5vbmVMaXN0R3JvdXAgKXtcbiAgICAgICAgICAgIGxpc3RUYWdWYWwgKz0gdGhpcy5qMngoaXRlbSwgbGV2ZWwgKyAxKS52YWw7XG4gICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICBsaXN0VGFnVmFsICs9IHRoaXMucHJvY2Vzc1RleHRPck9iak5vZGUoaXRlbSwga2V5LCBsZXZlbClcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGlzdFRhZ1ZhbCArPSB0aGlzLmJ1aWxkVGV4dFZhbE5vZGUoaXRlbSwga2V5LCAnJywgbGV2ZWwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZih0aGlzLm9wdGlvbnMub25lTGlzdEdyb3VwKXtcbiAgICAgICAgbGlzdFRhZ1ZhbCA9IHRoaXMuYnVpbGRPYmplY3ROb2RlKGxpc3RUYWdWYWwsIGtleSwgJycsIGxldmVsKTtcbiAgICAgIH1cbiAgICAgIHZhbCArPSBsaXN0VGFnVmFsO1xuICAgIH0gZWxzZSB7XG4gICAgICAvL25lc3RlZCBub2RlXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmF0dHJpYnV0ZXNHcm91cE5hbWUgJiYga2V5ID09PSB0aGlzLm9wdGlvbnMuYXR0cmlidXRlc0dyb3VwTmFtZSkge1xuICAgICAgICBjb25zdCBLcyA9IE9iamVjdC5rZXlzKGpPYmpba2V5XSk7XG4gICAgICAgIGNvbnN0IEwgPSBLcy5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgTDsgaisrKSB7XG4gICAgICAgICAgYXR0clN0ciArPSB0aGlzLmJ1aWxkQXR0clBhaXJTdHIoS3Nbal0sICcnICsgak9ialtrZXldW0tzW2pdXSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbCArPSB0aGlzLnByb2Nlc3NUZXh0T3JPYmpOb2RlKGpPYmpba2V5XSwga2V5LCBsZXZlbClcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHthdHRyU3RyOiBhdHRyU3RyLCB2YWw6IHZhbH07XG59O1xuXG5CdWlsZGVyLnByb3RvdHlwZS5idWlsZEF0dHJQYWlyU3RyID0gZnVuY3Rpb24oYXR0ck5hbWUsIHZhbCl7XG4gIHZhbCA9IHRoaXMub3B0aW9ucy5hdHRyaWJ1dGVWYWx1ZVByb2Nlc3NvcihhdHRyTmFtZSwgJycgKyB2YWwpO1xuICB2YWwgPSB0aGlzLnJlcGxhY2VFbnRpdGllc1ZhbHVlKHZhbCk7XG4gIGlmICh0aGlzLm9wdGlvbnMuc3VwcHJlc3NCb29sZWFuQXR0cmlidXRlcyAmJiB2YWwgPT09IFwidHJ1ZVwiKSB7XG4gICAgcmV0dXJuICcgJyArIGF0dHJOYW1lO1xuICB9IGVsc2UgcmV0dXJuICcgJyArIGF0dHJOYW1lICsgJz1cIicgKyB2YWwgKyAnXCInO1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzVGV4dE9yT2JqTm9kZSAob2JqZWN0LCBrZXksIGxldmVsKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHRoaXMuajJ4KG9iamVjdCwgbGV2ZWwgKyAxKTtcbiAgaWYgKG9iamVjdFt0aGlzLm9wdGlvbnMudGV4dE5vZGVOYW1lXSAhPT0gdW5kZWZpbmVkICYmIE9iamVjdC5rZXlzKG9iamVjdCkubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIHRoaXMuYnVpbGRUZXh0VmFsTm9kZShvYmplY3RbdGhpcy5vcHRpb25zLnRleHROb2RlTmFtZV0sIGtleSwgcmVzdWx0LmF0dHJTdHIsIGxldmVsKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGhpcy5idWlsZE9iamVjdE5vZGUocmVzdWx0LnZhbCwga2V5LCByZXN1bHQuYXR0clN0ciwgbGV2ZWwpO1xuICB9XG59XG5cbkJ1aWxkZXIucHJvdG90eXBlLmJ1aWxkT2JqZWN0Tm9kZSA9IGZ1bmN0aW9uKHZhbCwga2V5LCBhdHRyU3RyLCBsZXZlbCkge1xuICBpZih2YWwgPT09IFwiXCIpe1xuICAgIGlmKGtleVswXSA9PT0gXCI/XCIpIHJldHVybiAgdGhpcy5pbmRlbnRhdGUobGV2ZWwpICsgJzwnICsga2V5ICsgYXR0clN0cisgJz8nICsgdGhpcy50YWdFbmRDaGFyO1xuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuaW5kZW50YXRlKGxldmVsKSArICc8JyArIGtleSArIGF0dHJTdHIgKyB0aGlzLmNsb3NlVGFnKGtleSkgKyB0aGlzLnRhZ0VuZENoYXI7XG4gICAgfVxuICB9ZWxzZXtcblxuICAgIGxldCB0YWdFbmRFeHAgPSAnPC8nICsga2V5ICsgdGhpcy50YWdFbmRDaGFyO1xuICAgIGxldCBwaUNsb3NpbmdDaGFyID0gXCJcIjtcbiAgICBcbiAgICBpZihrZXlbMF0gPT09IFwiP1wiKSB7XG4gICAgICBwaUNsb3NpbmdDaGFyID0gXCI/XCI7XG4gICAgICB0YWdFbmRFeHAgPSBcIlwiO1xuICAgIH1cbiAgXG4gICAgLy8gYXR0clN0ciBpcyBhbiBlbXB0eSBzdHJpbmcgaW4gY2FzZSB0aGUgYXR0cmlidXRlIGNhbWUgYXMgdW5kZWZpbmVkIG9yIG51bGxcbiAgICBpZiAoKGF0dHJTdHIgfHwgYXR0clN0ciA9PT0gJycpICYmIHZhbC5pbmRleE9mKCc8JykgPT09IC0xKSB7XG4gICAgICByZXR1cm4gKCB0aGlzLmluZGVudGF0ZShsZXZlbCkgKyAnPCcgKyAga2V5ICsgYXR0clN0ciArIHBpQ2xvc2luZ0NoYXIgKyAnPicgKyB2YWwgKyB0YWdFbmRFeHAgKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5jb21tZW50UHJvcE5hbWUgIT09IGZhbHNlICYmIGtleSA9PT0gdGhpcy5vcHRpb25zLmNvbW1lbnRQcm9wTmFtZSAmJiBwaUNsb3NpbmdDaGFyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuaW5kZW50YXRlKGxldmVsKSArIGA8IS0tJHt2YWx9LS0+YCArIHRoaXMubmV3TGluZTtcbiAgICB9ZWxzZSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICB0aGlzLmluZGVudGF0ZShsZXZlbCkgKyAnPCcgKyBrZXkgKyBhdHRyU3RyICsgcGlDbG9zaW5nQ2hhciArIHRoaXMudGFnRW5kQ2hhciArXG4gICAgICAgIHZhbCArXG4gICAgICAgIHRoaXMuaW5kZW50YXRlKGxldmVsKSArIHRhZ0VuZEV4cCAgICApO1xuICAgIH1cbiAgfVxufVxuXG5CdWlsZGVyLnByb3RvdHlwZS5jbG9zZVRhZyA9IGZ1bmN0aW9uKGtleSl7XG4gIGxldCBjbG9zZVRhZyA9IFwiXCI7XG4gIGlmKHRoaXMub3B0aW9ucy51bnBhaXJlZFRhZ3MuaW5kZXhPZihrZXkpICE9PSAtMSl7IC8vdW5wYWlyZWRcbiAgICBpZighdGhpcy5vcHRpb25zLnN1cHByZXNzVW5wYWlyZWROb2RlKSBjbG9zZVRhZyA9IFwiL1wiXG4gIH1lbHNlIGlmKHRoaXMub3B0aW9ucy5zdXBwcmVzc0VtcHR5Tm9kZSl7IC8vZW1wdHlcbiAgICBjbG9zZVRhZyA9IFwiL1wiO1xuICB9ZWxzZXtcbiAgICBjbG9zZVRhZyA9IGA+PC8ke2tleX1gXG4gIH1cbiAgcmV0dXJuIGNsb3NlVGFnO1xufVxuXG5mdW5jdGlvbiBidWlsZEVtcHR5T2JqTm9kZSh2YWwsIGtleSwgYXR0clN0ciwgbGV2ZWwpIHtcbiAgaWYgKHZhbCAhPT0gJycpIHtcbiAgICByZXR1cm4gdGhpcy5idWlsZE9iamVjdE5vZGUodmFsLCBrZXksIGF0dHJTdHIsIGxldmVsKTtcbiAgfSBlbHNlIHtcbiAgICBpZihrZXlbMF0gPT09IFwiP1wiKSByZXR1cm4gIHRoaXMuaW5kZW50YXRlKGxldmVsKSArICc8JyArIGtleSArIGF0dHJTdHIrICc/JyArIHRoaXMudGFnRW5kQ2hhcjtcbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiAgdGhpcy5pbmRlbnRhdGUobGV2ZWwpICsgJzwnICsga2V5ICsgYXR0clN0ciArICcvJyArIHRoaXMudGFnRW5kQ2hhcjtcbiAgICAgIC8vIHJldHVybiB0aGlzLmJ1aWxkVGFnU3RyKGxldmVsLGtleSwgYXR0clN0cik7XG4gICAgfVxuICB9XG59XG5cbkJ1aWxkZXIucHJvdG90eXBlLmJ1aWxkVGV4dFZhbE5vZGUgPSBmdW5jdGlvbih2YWwsIGtleSwgYXR0clN0ciwgbGV2ZWwpIHtcbiAgaWYgKHRoaXMub3B0aW9ucy5jZGF0YVByb3BOYW1lICE9PSBmYWxzZSAmJiBrZXkgPT09IHRoaXMub3B0aW9ucy5jZGF0YVByb3BOYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5kZW50YXRlKGxldmVsKSArIGA8IVtDREFUQVske3ZhbH1dXT5gICsgIHRoaXMubmV3TGluZTtcbiAgfWVsc2UgaWYgKHRoaXMub3B0aW9ucy5jb21tZW50UHJvcE5hbWUgIT09IGZhbHNlICYmIGtleSA9PT0gdGhpcy5vcHRpb25zLmNvbW1lbnRQcm9wTmFtZSkge1xuICAgIHJldHVybiB0aGlzLmluZGVudGF0ZShsZXZlbCkgKyBgPCEtLSR7dmFsfS0tPmAgKyAgdGhpcy5uZXdMaW5lO1xuICB9ZWxzZSBpZihrZXlbMF0gPT09IFwiP1wiKSB7Ly9QSSB0YWdcbiAgICByZXR1cm4gIHRoaXMuaW5kZW50YXRlKGxldmVsKSArICc8JyArIGtleSArIGF0dHJTdHIrICc/JyArIHRoaXMudGFnRW5kQ2hhcjsgXG4gIH1lbHNle1xuICAgIGxldCB0ZXh0VmFsdWUgPSB0aGlzLm9wdGlvbnMudGFnVmFsdWVQcm9jZXNzb3Ioa2V5LCB2YWwpO1xuICAgIHRleHRWYWx1ZSA9IHRoaXMucmVwbGFjZUVudGl0aWVzVmFsdWUodGV4dFZhbHVlKTtcbiAgXG4gICAgaWYoIHRleHRWYWx1ZSA9PT0gJycpe1xuICAgICAgcmV0dXJuIHRoaXMuaW5kZW50YXRlKGxldmVsKSArICc8JyArIGtleSArIGF0dHJTdHIgKyB0aGlzLmNsb3NlVGFnKGtleSkgKyB0aGlzLnRhZ0VuZENoYXI7XG4gICAgfWVsc2V7XG4gICAgICByZXR1cm4gdGhpcy5pbmRlbnRhdGUobGV2ZWwpICsgJzwnICsga2V5ICsgYXR0clN0ciArICc+JyArXG4gICAgICAgICB0ZXh0VmFsdWUgK1xuICAgICAgICAnPC8nICsga2V5ICsgdGhpcy50YWdFbmRDaGFyO1xuICAgIH1cbiAgfVxufVxuXG5CdWlsZGVyLnByb3RvdHlwZS5yZXBsYWNlRW50aXRpZXNWYWx1ZSA9IGZ1bmN0aW9uKHRleHRWYWx1ZSl7XG4gIGlmKHRleHRWYWx1ZSAmJiB0ZXh0VmFsdWUubGVuZ3RoID4gMCAmJiB0aGlzLm9wdGlvbnMucHJvY2Vzc0VudGl0aWVzKXtcbiAgICBmb3IgKGxldCBpPTA7IGk8dGhpcy5vcHRpb25zLmVudGl0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBlbnRpdHkgPSB0aGlzLm9wdGlvbnMuZW50aXRpZXNbaV07XG4gICAgICB0ZXh0VmFsdWUgPSB0ZXh0VmFsdWUucmVwbGFjZShlbnRpdHkucmVnZXgsIGVudGl0eS52YWwpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGV4dFZhbHVlO1xufVxuXG5mdW5jdGlvbiBpbmRlbnRhdGUobGV2ZWwpIHtcbiAgcmV0dXJuIHRoaXMub3B0aW9ucy5pbmRlbnRCeS5yZXBlYXQobGV2ZWwpO1xufVxuXG5mdW5jdGlvbiBpc0F0dHJpYnV0ZShuYW1lIC8qLCBvcHRpb25zKi8pIHtcbiAgaWYgKG5hbWUuc3RhcnRzV2l0aCh0aGlzLm9wdGlvbnMuYXR0cmlidXRlTmFtZVByZWZpeCkgJiYgbmFtZSAhPT0gdGhpcy5vcHRpb25zLnRleHROb2RlTmFtZSkge1xuICAgIHJldHVybiBuYW1lLnN1YnN0cih0aGlzLmF0dHJQcmVmaXhMZW4pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEJ1aWxkZXI7XG4iXSwibmFtZXMiOlsiYnVpbGRGcm9tT3JkZXJlZEpzIiwicmVxdWlyZSIsImRlZmF1bHRPcHRpb25zIiwiYXR0cmlidXRlTmFtZVByZWZpeCIsImF0dHJpYnV0ZXNHcm91cE5hbWUiLCJ0ZXh0Tm9kZU5hbWUiLCJpZ25vcmVBdHRyaWJ1dGVzIiwiY2RhdGFQcm9wTmFtZSIsImZvcm1hdCIsImluZGVudEJ5Iiwic3VwcHJlc3NFbXB0eU5vZGUiLCJzdXBwcmVzc1VucGFpcmVkTm9kZSIsInN1cHByZXNzQm9vbGVhbkF0dHJpYnV0ZXMiLCJ0YWdWYWx1ZVByb2Nlc3NvciIsImtleSIsImEiLCJhdHRyaWJ1dGVWYWx1ZVByb2Nlc3NvciIsImF0dHJOYW1lIiwicHJlc2VydmVPcmRlciIsImNvbW1lbnRQcm9wTmFtZSIsInVucGFpcmVkVGFncyIsImVudGl0aWVzIiwicmVnZXgiLCJSZWdFeHAiLCJ2YWwiLCJwcm9jZXNzRW50aXRpZXMiLCJzdG9wTm9kZXMiLCJvbmVMaXN0R3JvdXAiLCJCdWlsZGVyIiwib3B0aW9ucyIsIk9iamVjdCIsImFzc2lnbiIsImlzQXR0cmlidXRlIiwiYXR0clByZWZpeExlbiIsImxlbmd0aCIsInByb2Nlc3NUZXh0T3JPYmpOb2RlIiwiaW5kZW50YXRlIiwidGFnRW5kQ2hhciIsIm5ld0xpbmUiLCJwcm90b3R5cGUiLCJidWlsZCIsImpPYmoiLCJBcnJheSIsImlzQXJyYXkiLCJhcnJheU5vZGVOYW1lIiwiajJ4IiwibGV2ZWwiLCJhdHRyU3RyIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiRGF0ZSIsImJ1aWxkVGV4dFZhbE5vZGUiLCJhdHRyIiwiYnVpbGRBdHRyUGFpclN0ciIsIm5ld3ZhbCIsInJlcGxhY2VFbnRpdGllc1ZhbHVlIiwiYXJyTGVuIiwibGlzdFRhZ1ZhbCIsImoiLCJpdGVtIiwiYnVpbGRPYmplY3ROb2RlIiwiS3MiLCJrZXlzIiwiTCIsIm9iamVjdCIsInJlc3VsdCIsInVuZGVmaW5lZCIsImNsb3NlVGFnIiwidGFnRW5kRXhwIiwicGlDbG9zaW5nQ2hhciIsImluZGV4T2YiLCJidWlsZEVtcHR5T2JqTm9kZSIsInRleHRWYWx1ZSIsImkiLCJlbnRpdHkiLCJyZXBsYWNlIiwicmVwZWF0IiwibmFtZSIsInN0YXJ0c1dpdGgiLCJzdWJzdHIiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js":
/*!**********************************************************************!*\
  !*** ./node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";
eval("\nconst EOL = \"\\n\";\n/**\n * \n * @param {array} jArray \n * @param {any} options \n * @returns \n */ function toXml(jArray, options) {\n    let indentation = \"\";\n    if (options.format && options.indentBy.length > 0) {\n        indentation = EOL;\n    }\n    return arrToStr(jArray, options, \"\", indentation);\n}\nfunction arrToStr(arr, options, jPath, indentation) {\n    let xmlStr = \"\";\n    let isPreviousElementTag = false;\n    for(let i = 0; i < arr.length; i++){\n        const tagObj = arr[i];\n        const tagName = propName(tagObj);\n        if (tagName === undefined) continue;\n        let newJPath = \"\";\n        if (jPath.length === 0) newJPath = tagName;\n        else newJPath = `${jPath}.${tagName}`;\n        if (tagName === options.textNodeName) {\n            let tagText = tagObj[tagName];\n            if (!isStopNode(newJPath, options)) {\n                tagText = options.tagValueProcessor(tagName, tagText);\n                tagText = replaceEntitiesValue(tagText, options);\n            }\n            if (isPreviousElementTag) {\n                xmlStr += indentation;\n            }\n            xmlStr += tagText;\n            isPreviousElementTag = false;\n            continue;\n        } else if (tagName === options.cdataPropName) {\n            if (isPreviousElementTag) {\n                xmlStr += indentation;\n            }\n            xmlStr += `<![CDATA[${tagObj[tagName][0][options.textNodeName]}]]>`;\n            isPreviousElementTag = false;\n            continue;\n        } else if (tagName === options.commentPropName) {\n            xmlStr += indentation + `<!--${tagObj[tagName][0][options.textNodeName]}-->`;\n            isPreviousElementTag = true;\n            continue;\n        } else if (tagName[0] === \"?\") {\n            const attStr = attr_to_str(tagObj[\":@\"], options);\n            const tempInd = tagName === \"?xml\" ? \"\" : indentation;\n            let piTextNodeName = tagObj[tagName][0][options.textNodeName];\n            piTextNodeName = piTextNodeName.length !== 0 ? \" \" + piTextNodeName : \"\"; //remove extra spacing\n            xmlStr += tempInd + `<${tagName}${piTextNodeName}${attStr}?>`;\n            isPreviousElementTag = true;\n            continue;\n        }\n        let newIdentation = indentation;\n        if (newIdentation !== \"\") {\n            newIdentation += options.indentBy;\n        }\n        const attStr = attr_to_str(tagObj[\":@\"], options);\n        const tagStart = indentation + `<${tagName}${attStr}`;\n        const tagValue = arrToStr(tagObj[tagName], options, newJPath, newIdentation);\n        if (options.unpairedTags.indexOf(tagName) !== -1) {\n            if (options.suppressUnpairedNode) xmlStr += tagStart + \">\";\n            else xmlStr += tagStart + \"/>\";\n        } else if ((!tagValue || tagValue.length === 0) && options.suppressEmptyNode) {\n            xmlStr += tagStart + \"/>\";\n        } else if (tagValue && tagValue.endsWith(\">\")) {\n            xmlStr += tagStart + `>${tagValue}${indentation}</${tagName}>`;\n        } else {\n            xmlStr += tagStart + \">\";\n            if (tagValue && indentation !== \"\" && (tagValue.includes(\"/>\") || tagValue.includes(\"</\"))) {\n                xmlStr += indentation + options.indentBy + tagValue + indentation;\n            } else {\n                xmlStr += tagValue;\n            }\n            xmlStr += `</${tagName}>`;\n        }\n        isPreviousElementTag = true;\n    }\n    return xmlStr;\n}\nfunction propName(obj) {\n    const keys = Object.keys(obj);\n    for(let i = 0; i < keys.length; i++){\n        const key = keys[i];\n        if (!obj.hasOwnProperty(key)) continue;\n        if (key !== \":@\") return key;\n    }\n}\nfunction attr_to_str(attrMap, options) {\n    let attrStr = \"\";\n    if (attrMap && !options.ignoreAttributes) {\n        for(let attr in attrMap){\n            if (!attrMap.hasOwnProperty(attr)) continue;\n            let attrVal = options.attributeValueProcessor(attr, attrMap[attr]);\n            attrVal = replaceEntitiesValue(attrVal, options);\n            if (attrVal === true && options.suppressBooleanAttributes) {\n                attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}`;\n            } else {\n                attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}=\"${attrVal}\"`;\n            }\n        }\n    }\n    return attrStr;\n}\nfunction isStopNode(jPath, options) {\n    jPath = jPath.substr(0, jPath.length - options.textNodeName.length - 1);\n    let tagName = jPath.substr(jPath.lastIndexOf(\".\") + 1);\n    for(let index in options.stopNodes){\n        if (options.stopNodes[index] === jPath || options.stopNodes[index] === \"*.\" + tagName) return true;\n    }\n    return false;\n}\nfunction replaceEntitiesValue(textValue, options) {\n    if (textValue && textValue.length > 0 && options.processEntities) {\n        for(let i = 0; i < options.entities.length; i++){\n            const entity = options.entities[i];\n            textValue = textValue.replace(entity.regex, entity.val);\n        }\n    }\n    return textValue;\n}\nmodule.exports = toXml;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmFzdC14bWwtcGFyc2VyL3NyYy94bWxidWlsZGVyL29yZGVyZWRKczJYbWwuanMiLCJtYXBwaW5ncyI6IjtBQUFBLE1BQU1BLE1BQU07QUFFWjs7Ozs7Q0FLQyxHQUNELFNBQVNDLE1BQU1DLE1BQU0sRUFBRUMsT0FBTztJQUMxQixJQUFJQyxjQUFjO0lBQ2xCLElBQUlELFFBQVFFLE1BQU0sSUFBSUYsUUFBUUcsUUFBUSxDQUFDQyxNQUFNLEdBQUcsR0FBRztRQUMvQ0gsY0FBY0o7SUFDbEI7SUFDQSxPQUFPUSxTQUFTTixRQUFRQyxTQUFTLElBQUlDO0FBQ3pDO0FBRUEsU0FBU0ksU0FBU0MsR0FBRyxFQUFFTixPQUFPLEVBQUVPLEtBQUssRUFBRU4sV0FBVztJQUM5QyxJQUFJTyxTQUFTO0lBQ2IsSUFBSUMsdUJBQXVCO0lBRTNCLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJSixJQUFJRixNQUFNLEVBQUVNLElBQUs7UUFDakMsTUFBTUMsU0FBU0wsR0FBRyxDQUFDSSxFQUFFO1FBQ3JCLE1BQU1FLFVBQVVDLFNBQVNGO1FBQ3pCLElBQUdDLFlBQVlFLFdBQVc7UUFFMUIsSUFBSUMsV0FBVztRQUNmLElBQUlSLE1BQU1ILE1BQU0sS0FBSyxHQUFHVyxXQUFXSDthQUM5QkcsV0FBVyxDQUFDLEVBQUVSLE1BQU0sQ0FBQyxFQUFFSyxRQUFRLENBQUM7UUFFckMsSUFBSUEsWUFBWVosUUFBUWdCLFlBQVksRUFBRTtZQUNsQyxJQUFJQyxVQUFVTixNQUFNLENBQUNDLFFBQVE7WUFDN0IsSUFBSSxDQUFDTSxXQUFXSCxVQUFVZixVQUFVO2dCQUNoQ2lCLFVBQVVqQixRQUFRbUIsaUJBQWlCLENBQUNQLFNBQVNLO2dCQUM3Q0EsVUFBVUcscUJBQXFCSCxTQUFTakI7WUFDNUM7WUFDQSxJQUFJUyxzQkFBc0I7Z0JBQ3RCRCxVQUFVUDtZQUNkO1lBQ0FPLFVBQVVTO1lBQ1ZSLHVCQUF1QjtZQUN2QjtRQUNKLE9BQU8sSUFBSUcs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QU0sR0FBRyxLQUFLSixRQUFRc0QsZUFBZSxFQUFFO1FBQzlELElBQUssSUFBSTVDLElBQUksR0FBR0EsSUFBSVYsUUFBUXVELFFBQVEsQ0FBQ25ELE1BQU0sRUFBRU0sSUFBSztZQUM5QyxNQUFNOEMsU0FBU3hELFFBQVF1RCxRQUFRLENBQUM3QyxFQUFFO1lBQ2xDMkMsWUFBWUEsVUFBVUksT0FBTyxDQUFDRCxPQUFPRSxLQUFLLEVBQUVGLE9BQU9HLEdBQUc7UUFDMUQ7SUFDSjtJQUNBLE9BQU9OO0FBQ1g7QUFDQU8sT0FBT0MsT0FBTyxHQUFHL0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90aGUtZ3JpZC0yLy4vbm9kZV9tb2R1bGVzL2Zhc3QteG1sLXBhcnNlci9zcmMveG1sYnVpbGRlci9vcmRlcmVkSnMyWG1sLmpzPzkyZjEiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgRU9MID0gXCJcXG5cIjtcblxuLyoqXG4gKiBcbiAqIEBwYXJhbSB7YXJyYXl9IGpBcnJheSBcbiAqIEBwYXJhbSB7YW55fSBvcHRpb25zIFxuICogQHJldHVybnMgXG4gKi9cbmZ1bmN0aW9uIHRvWG1sKGpBcnJheSwgb3B0aW9ucykge1xuICAgIGxldCBpbmRlbnRhdGlvbiA9IFwiXCI7XG4gICAgaWYgKG9wdGlvbnMuZm9ybWF0ICYmIG9wdGlvbnMuaW5kZW50QnkubGVuZ3RoID4gMCkge1xuICAgICAgICBpbmRlbnRhdGlvbiA9IEVPTDtcbiAgICB9XG4gICAgcmV0dXJuIGFyclRvU3RyKGpBcnJheSwgb3B0aW9ucywgXCJcIiwgaW5kZW50YXRpb24pO1xufVxuXG5mdW5jdGlvbiBhcnJUb1N0cihhcnIsIG9wdGlvbnMsIGpQYXRoLCBpbmRlbnRhdGlvbikge1xuICAgIGxldCB4bWxTdHIgPSBcIlwiO1xuICAgIGxldCBpc1ByZXZpb3VzRWxlbWVudFRhZyA9IGZhbHNlO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgdGFnT2JqID0gYXJyW2ldO1xuICAgICAgICBjb25zdCB0YWdOYW1lID0gcHJvcE5hbWUodGFnT2JqKTtcbiAgICAgICAgaWYodGFnTmFtZSA9PT0gdW5kZWZpbmVkKSBjb250aW51ZTtcblxuICAgICAgICBsZXQgbmV3SlBhdGggPSBcIlwiO1xuICAgICAgICBpZiAoalBhdGgubGVuZ3RoID09PSAwKSBuZXdKUGF0aCA9IHRhZ05hbWVcbiAgICAgICAgZWxzZSBuZXdKUGF0aCA9IGAke2pQYXRofS4ke3RhZ05hbWV9YDtcblxuICAgICAgICBpZiAodGFnTmFtZSA9PT0gb3B0aW9ucy50ZXh0Tm9kZU5hbWUpIHtcbiAgICAgICAgICAgIGxldCB0YWdUZXh0ID0gdGFnT2JqW3RhZ05hbWVdO1xuICAgICAgICAgICAgaWYgKCFpc1N0b3BOb2RlKG5ld0pQYXRoLCBvcHRpb25zKSkge1xuICAgICAgICAgICAgICAgIHRhZ1RleHQgPSBvcHRpb25zLnRhZ1ZhbHVlUHJvY2Vzc29yKHRhZ05hbWUsIHRhZ1RleHQpO1xuICAgICAgICAgICAgICAgIHRhZ1RleHQgPSByZXBsYWNlRW50aXRpZXNWYWx1ZSh0YWdUZXh0LCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1ByZXZpb3VzRWxlbWVudFRhZykge1xuICAgICAgICAgICAgICAgIHhtbFN0ciArPSBpbmRlbnRhdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHhtbFN0ciArPSB0YWdUZXh0O1xuICAgICAgICAgICAgaXNQcmV2aW91c0VsZW1lbnRUYWcgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHRhZ05hbWUgPT09IG9wdGlvbnMuY2RhdGFQcm9wTmFtZSkge1xuICAgICAgICAgICAgaWYgKGlzUHJldmlvdXNFbGVtZW50VGFnKSB7XG4gICAgICAgICAgICAgICAgeG1sU3RyICs9IGluZGVudGF0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeG1sU3RyICs9IGA8IVtDREFUQVske3RhZ09ialt0YWdOYW1lXVswXVtvcHRpb25zLnRleHROb2RlTmFtZV19XV0+YDtcbiAgICAgICAgICAgIGlzUHJldmlvdXNFbGVtZW50VGFnID0gZmFsc2U7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIGlmICh0YWdOYW1lID09PSBvcHRpb25zLmNvbW1lbnRQcm9wTmFtZSkge1xuICAgICAgICAgICAgeG1sU3RyICs9IGluZGVudGF0aW9uICsgYDwhLS0ke3RhZ09ialt0YWdOYW1lXVswXVtvcHRpb25zLnRleHROb2RlTmFtZV19LS0+YDtcbiAgICAgICAgICAgIGlzUHJldmlvdXNFbGVtZW50VGFnID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHRhZ05hbWVbMF0gPT09IFwiP1wiKSB7XG4gICAgICAgICAgICBjb25zdCBhdHRTdHIgPSBhdHRyX3RvX3N0cih0YWdPYmpbXCI6QFwiXSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCB0ZW1wSW5kID0gdGFnTmFtZSA9PT0gXCI/eG1sXCIgPyBcIlwiIDogaW5kZW50YXRpb247XG4gICAgICAgICAgICBsZXQgcGlUZXh0Tm9kZU5hbWUgPSB0YWdPYmpbdGFnTmFtZV1bMF1bb3B0aW9ucy50ZXh0Tm9kZU5hbWVdO1xuICAgICAgICAgICAgcGlUZXh0Tm9kZU5hbWUgPSBwaVRleHROb2RlTmFtZS5sZW5ndGggIT09IDAgPyBcIiBcIiArIHBpVGV4dE5vZGVOYW1lIDogXCJcIjsgLy9yZW1vdmUgZXh0cmEgc3BhY2luZ1xuICAgICAgICAgICAgeG1sU3RyICs9IHRlbXBJbmQgKyBgPCR7dGFnTmFtZX0ke3BpVGV4dE5vZGVOYW1lfSR7YXR0U3RyfT8+YDtcbiAgICAgICAgICAgIGlzUHJldmlvdXNFbGVtZW50VGFnID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBuZXdJZGVudGF0aW9uID0gaW5kZW50YXRpb247XG4gICAgICAgIGlmIChuZXdJZGVudGF0aW9uICE9PSBcIlwiKSB7XG4gICAgICAgICAgICBuZXdJZGVudGF0aW9uICs9IG9wdGlvbnMuaW5kZW50Qnk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXR0U3RyID0gYXR0cl90b19zdHIodGFnT2JqW1wiOkBcIl0sIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCB0YWdTdGFydCA9IGluZGVudGF0aW9uICsgYDwke3RhZ05hbWV9JHthdHRTdHJ9YDtcbiAgICAgICAgY29uc3QgdGFnVmFsdWUgPSBhcnJUb1N0cih0YWdPYmpbdGFnTmFtZV0sIG9wdGlvbnMsIG5ld0pQYXRoLCBuZXdJZGVudGF0aW9uKTtcbiAgICAgICAgaWYgKG9wdGlvbnMudW5wYWlyZWRUYWdzLmluZGV4T2YodGFnTmFtZSkgIT09IC0xKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zdXBwcmVzc1VucGFpcmVkTm9kZSkgeG1sU3RyICs9IHRhZ1N0YXJ0ICsgXCI+XCI7XG4gICAgICAgICAgICBlbHNlIHhtbFN0ciArPSB0YWdTdGFydCArIFwiLz5cIjtcbiAgICAgICAgfSBlbHNlIGlmICgoIXRhZ1ZhbHVlIHx8IHRhZ1ZhbHVlLmxlbmd0aCA9PT0gMCkgJiYgb3B0aW9ucy5zdXBwcmVzc0VtcHR5Tm9kZSkge1xuICAgICAgICAgICAgeG1sU3RyICs9IHRhZ1N0YXJ0ICsgXCIvPlwiO1xuICAgICAgICB9IGVsc2UgaWYgKHRhZ1ZhbHVlICYmIHRhZ1ZhbHVlLmVuZHNXaXRoKFwiPlwiKSkge1xuICAgICAgICAgICAgeG1sU3RyICs9IHRhZ1N0YXJ0ICsgYD4ke3RhZ1ZhbHVlfSR7aW5kZW50YXRpb259PC8ke3RhZ05hbWV9PmA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB4bWxTdHIgKz0gdGFnU3RhcnQgKyBcIj5cIjtcbiAgICAgICAgICAgIGlmICh0YWdWYWx1ZSAmJiBpbmRlbnRhdGlvbiAhPT0gXCJcIiAmJiAodGFnVmFsdWUuaW5jbHVkZXMoXCIvPlwiKSB8fCB0YWdWYWx1ZS5pbmNsdWRlcyhcIjwvXCIpKSkge1xuICAgICAgICAgICAgICAgIHhtbFN0ciArPSBpbmRlbnRhdGlvbiArIG9wdGlvbnMuaW5kZW50QnkgKyB0YWdWYWx1ZSArIGluZGVudGF0aW9uO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB4bWxTdHIgKz0gdGFnVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB4bWxTdHIgKz0gYDwvJHt0YWdOYW1lfT5gO1xuICAgICAgICB9XG4gICAgICAgIGlzUHJldmlvdXNFbGVtZW50VGFnID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4geG1sU3RyO1xufVxuXG5mdW5jdGlvbiBwcm9wTmFtZShvYmopIHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgaWYoIW9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSBjb250aW51ZTtcbiAgICAgICAgaWYgKGtleSAhPT0gXCI6QFwiKSByZXR1cm4ga2V5O1xuICAgIH1cbn1cblxuZnVuY3Rpb24gYXR0cl90b19zdHIoYXR0ck1hcCwgb3B0aW9ucykge1xuICAgIGxldCBhdHRyU3RyID0gXCJcIjtcbiAgICBpZiAoYXR0ck1hcCAmJiAhb3B0aW9ucy5pZ25vcmVBdHRyaWJ1dGVzKSB7XG4gICAgICAgIGZvciAobGV0IGF0dHIgaW4gYXR0ck1hcCkge1xuICAgICAgICAgICAgaWYoIWF0dHJNYXAuaGFzT3duUHJvcGVydHkoYXR0cikpIGNvbnRpbnVlO1xuICAgICAgICAgICAgbGV0IGF0dHJWYWwgPSBvcHRpb25zLmF0dHJpYnV0ZVZhbHVlUHJvY2Vzc29yKGF0dHIsIGF0dHJNYXBbYXR0cl0pO1xuICAgICAgICAgICAgYXR0clZhbCA9IHJlcGxhY2VFbnRpdGllc1ZhbHVlKGF0dHJWYWwsIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKGF0dHJWYWwgPT09IHRydWUgJiYgb3B0aW9ucy5zdXBwcmVzc0Jvb2xlYW5BdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgYXR0clN0ciArPSBgICR7YXR0ci5zdWJzdHIob3B0aW9ucy5hdHRyaWJ1dGVOYW1lUHJlZml4Lmxlbmd0aCl9YDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYXR0clN0ciArPSBgICR7YXR0ci5zdWJzdHIob3B0aW9ucy5hdHRyaWJ1dGVOYW1lUHJlZml4Lmxlbmd0aCl9PVwiJHthdHRyVmFsfVwiYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXR0clN0cjtcbn1cblxuZnVuY3Rpb24gaXNTdG9wTm9kZShqUGF0aCwgb3B0aW9ucykge1xuICAgIGpQYXRoID0galBhdGguc3Vic3RyKDAsIGpQYXRoLmxlbmd0aCAtIG9wdGlvbnMudGV4dE5vZGVOYW1lLmxlbmd0aCAtIDEpO1xuICAgIGxldCB0YWdOYW1lID0galBhdGguc3Vic3RyKGpQYXRoLmxhc3RJbmRleE9mKFwiLlwiKSArIDEpO1xuICAgIGZvciAobGV0IGluZGV4IGluIG9wdGlvbnMuc3RvcE5vZGVzKSB7XG4gICAgICAgIGlmIChvcHRpb25zLnN0b3BOb2Rlc1tpbmRleF0gPT09IGpQYXRoIHx8IG9wdGlvbnMuc3RvcE5vZGVzW2luZGV4XSA9PT0gXCIqLlwiICsgdGFnTmFtZSkgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gcmVwbGFjZUVudGl0aWVzVmFsdWUodGV4dFZhbHVlLCBvcHRpb25zKSB7XG4gICAgaWYgKHRleHRWYWx1ZSAmJiB0ZXh0VmFsdWUubGVuZ3RoID4gMCAmJiBvcHRpb25zLnByb2Nlc3NFbnRpdGllcykge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9wdGlvbnMuZW50aXRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGVudGl0eSA9IG9wdGlvbnMuZW50aXRpZXNbaV07XG4gICAgICAgICAgICB0ZXh0VmFsdWUgPSB0ZXh0VmFsdWUucmVwbGFjZShlbnRpdHkucmVnZXgsIGVudGl0eS52YWwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0ZXh0VmFsdWU7XG59XG5tb2R1bGUuZXhwb3J0cyA9IHRvWG1sO1xuIl0sIm5hbWVzIjpbIkVPTCIsInRvWG1sIiwiakFycmF5Iiwib3B0aW9ucyIsImluZGVudGF0aW9uIiwiZm9ybWF0IiwiaW5kZW50QnkiLCJsZW5ndGgiLCJhcnJUb1N0ciIsImFyciIsImpQYXRoIiwieG1sU3RyIiwiaXNQcmV2aW91c0VsZW1lbnRUYWciLCJpIiwidGFnT2JqIiwidGFnTmFtZSIsInByb3BOYW1lIiwidW5kZWZpbmVkIiwibmV3SlBhdGgiLCJ0ZXh0Tm9kZU5hbWUiLCJ0YWdUZXh0IiwiaXNTdG9wTm9kZSIsInRhZ1ZhbHVlUHJvY2Vzc29yIiwicmVwbGFjZUVudGl0aWVzVmFsdWUiLCJjZGF0YVByb3BOYW1lIiwiY29tbWVudFByb3BOYW1lIiwiYXR0U3RyIiwiYXR0cl90b19zdHIiLCJ0ZW1wSW5kIiwicGlUZXh0Tm9kZU5hbWUiLCJuZXdJZGVudGF0aW9uIiwidGFnU3RhcnQiLCJ0YWdWYWx1ZSIsInVucGFpcmVkVGFncyIsImluZGV4T2YiLCJzdXBwcmVzc1VucGFpcmVkTm9kZSIsInN1cHByZXNzRW1wdHlOb2RlIiwiZW5kc1dpdGgiLCJpbmNsdWRlcyIsIm9iaiIsImtleXMiLCJPYmplY3QiLCJrZXkiLCJoYXNPd25Qcm9wZXJ0eSIsImF0dHJNYXAiLCJhdHRyU3RyIiwiaWdub3JlQXR0cmlidXRlcyIsImF0dHIiLCJhdHRyVmFsIiwiYXR0cmlidXRlVmFsdWVQcm9jZXNzb3IiLCJzdXBwcmVzc0Jvb2xlYW5BdHRyaWJ1dGVzIiwic3Vic3RyIiwiYXR0cmlidXRlTmFtZVByZWZpeCIsImxhc3RJbmRleE9mIiwiaW5kZXgiLCJzdG9wTm9kZXMiLCJ0ZXh0VmFsdWUiLCJwcm9jZXNzRW50aXRpZXMiLCJlbnRpdGllcyIsImVudGl0eSIsInJlcGxhY2UiLCJyZWdleCIsInZhbCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js":
/*!*********************************************************************!*\
  !*** ./node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst util = __webpack_require__(/*! ../util */ \"(ssr)/./node_modules/fast-xml-parser/src/util.js\");\n//TODO: handle comments\nfunction readDocType(xmlData, i) {\n    const entities = {};\n    if (xmlData[i + 3] === \"O\" && xmlData[i + 4] === \"C\" && xmlData[i + 5] === \"T\" && xmlData[i + 6] === \"Y\" && xmlData[i + 7] === \"P\" && xmlData[i + 8] === \"E\") {\n        i = i + 9;\n        let angleBracketsCount = 1;\n        let hasBody = false, comment = false;\n        let exp = \"\";\n        for(; i < xmlData.length; i++){\n            if (xmlData[i] === \"<\" && !comment) {\n                if (hasBody && isEntity(xmlData, i)) {\n                    i += 7;\n                    [entityName, val, i] = readEntityExp(xmlData, i + 1);\n                    if (val.indexOf(\"&\") === -1) entities[validateEntityName(entityName)] = {\n                        regx: RegExp(`&${entityName};`, \"g\"),\n                        val: val\n                    };\n                } else if (hasBody && isElement(xmlData, i)) i += 8; //Not supported\n                else if (hasBody && isAttlist(xmlData, i)) i += 8; //Not supported\n                else if (hasBody && isNotation(xmlData, i)) i += 9; //Not supported\n                else if (isComment) comment = true;\n                else throw new Error(\"Invalid DOCTYPE\");\n                angleBracketsCount++;\n                exp = \"\";\n            } else if (xmlData[i] === \">\") {\n                if (comment) {\n                    if (xmlData[i - 1] === \"-\" && xmlData[i - 2] === \"-\") {\n                        comment = false;\n                        angleBracketsCount--;\n                    }\n                } else {\n                    angleBracketsCount--;\n                }\n                if (angleBracketsCount === 0) {\n                    break;\n                }\n            } else if (xmlData[i] === \"[\") {\n                hasBody = true;\n            } else {\n                exp += xmlData[i];\n            }\n        }\n        if (angleBracketsCount !== 0) {\n            throw new Error(`Unclosed DOCTYPE`);\n        }\n    } else {\n        throw new Error(`Invalid Tag instead of DOCTYPE`);\n    }\n    return {\n        entities,\n        i\n    };\n}\nfunction readEntityExp(xmlData, i) {\n    //External entities are not supported\n    //    <!ENTITY ext SYSTEM \"http://normal-website.com\" >\n    //Parameter entities are not supported\n    //    <!ENTITY entityname \"&anotherElement;\">\n    //Internal entities are supported\n    //    <!ENTITY entityname \"replacement text\">\n    //read EntityName\n    let entityName1 = \"\";\n    for(; i < xmlData.length && xmlData[i] !== \"'\" && xmlData[i] !== '\"'; i++){\n        // if(xmlData[i] === \" \") continue;\n        // else \n        entityName1 += xmlData[i];\n    }\n    entityName1 = entityName1.trim();\n    if (entityName1.indexOf(\" \") !== -1) throw new Error(\"External entites are not supported\");\n    //read Entity Value\n    const startChar = xmlData[i++];\n    let val1 = \"\";\n    for(; i < xmlData.length && xmlData[i] !== startChar; i++){\n        val1 += xmlData[i];\n    }\n    return [\n        entityName1,\n        val1,\n        i\n    ];\n}\nfunction isComment(xmlData, i) {\n    if (xmlData[i + 1] === \"!\" && xmlData[i + 2] === \"-\" && xmlData[i + 3] === \"-\") return true;\n    return false;\n}\nfunction isEntity(xmlData, i) {\n    if (xmlData[i + 1] === \"!\" && xmlData[i + 2] === \"E\" && xmlData[i + 3] === \"N\" && xmlData[i + 4] === \"T\" && xmlData[i + 5] === \"I\" && xmlData[i + 6] === \"T\" && xmlData[i + 7] === \"Y\") return true;\n    return false;\n}\nfunction isElement(xmlData, i) {\n    if (xmlData[i + 1] === \"!\" && xmlData[i + 2] === \"E\" && xmlData[i + 3] === \"L\" && xmlData[i + 4] === \"E\" && xmlData[i + 5] === \"M\" && xmlData[i + 6] === \"E\" && xmlData[i + 7] === \"N\" && xmlData[i + 8] === \"T\") return true;\n    return false;\n}\nfunction isAttlist(xmlData, i) {\n    if (xmlData[i + 1] === \"!\" && xmlData[i + 2] === \"A\" && xmlData[i + 3] === \"T\" && xmlData[i + 4] === \"T\" && xmlData[i + 5] === \"L\" && xmlData[i + 6] === \"I\" && xmlData[i + 7] === \"S\" && xmlData[i + 8] === \"T\") return true;\n    return false;\n}\nfunction isNotation(xmlData, i) {\n    if (xmlData[i + 1] === \"!\" && xmlData[i + 2] === \"N\" && xmlData[i + 3] === \"O\" && xmlData[i + 4] === \"T\" && xmlData[i + 5] === \"A\" && xmlData[i + 6] === \"T\" && xmlData[i + 7] === \"I\" && xmlData[i + 8] === \"O\" && xmlData[i + 9] === \"N\") return true;\n    return false;\n}\nfunction validateEntityName(name) {\n    if (util.isName(name)) return name;\n    else throw new Error(`Invalid entity name ${name}`);\n}\nmodule.exports = readDocType;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmFzdC14bWwtcGFyc2VyL3NyYy94bWxwYXJzZXIvRG9jVHlwZVJlYWRlci5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsTUFBTUEsT0FBT0MsbUJBQU9BLENBQUM7QUFFckIsdUJBQXVCO0FBQ3ZCLFNBQVNDLFlBQVlDLE9BQU8sRUFBRUMsQ0FBQztJQUUzQixNQUFNQyxXQUFXLENBQUM7SUFDbEIsSUFBSUYsT0FBTyxDQUFDQyxJQUFJLEVBQUUsS0FBSyxPQUNsQkQsT0FBTyxDQUFDQyxJQUFJLEVBQUUsS0FBSyxPQUNuQkQsT0FBTyxDQUFDQyxJQUFJLEVBQUUsS0FBSyxPQUNuQkQsT0FBTyxDQUFDQyxJQUFJLEVBQUUsS0FBSyxPQUNuQkQsT0FBTyxDQUFDQyxJQUFJLEVBQUUsS0FBSyxPQUNuQkQsT0FBTyxDQUFDQyxJQUFJLEVBQUUsS0FBSyxLQUN4QjtRQUNJQSxJQUFJQSxJQUFFO1FBQ04sSUFBSUUscUJBQXFCO1FBQ3pCLElBQUlDLFVBQVUsT0FBT0MsVUFBVTtRQUMvQixJQUFJQyxNQUFNO1FBQ1YsTUFBS0wsSUFBRUQsUUFBUU8sTUFBTSxFQUFDTixJQUFJO1lBQ3RCLElBQUlELE9BQU8sQ0FBQ0MsRUFBRSxLQUFLLE9BQU8sQ0FBQ0ksU0FBUztnQkFDaEMsSUFBSUQsV0FBV0ksU0FBU1IsU0FBU0MsSUFBRztvQkFDaENBLEtBQUs7b0JBQ0wsQ0FBQ1EsWUFBWUMsS0FBSVQsRUFBRSxHQUFHVSxjQUFjWCxTQUFRQyxJQUFFO29CQUM5QyxJQUFHUyxJQUFJRSxPQUFPLENBQUMsU0FBUyxDQUFDLEdBQ3JCVixRQUFRLENBQUVXLG1CQUFtQkosWUFBYSxHQUFHO3dCQUN6Q0ssTUFBT0MsT0FBUSxDQUFDLENBQUMsRUFBRU4sV0FBVyxDQUFDLENBQUMsRUFBQzt3QkFDakNDLEtBQUtBO29CQUNUO2dCQUNSLE9BQ0ssSUFBSU4sV0FBV1ksVUFBVWhCLFNBQVNDLElBQUtBLEtBQUssR0FBRSxlQUFlO3FCQUM3RCxJQUFJRyxX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T0FBTyxDQUFDQyxJQUFFLEVBQUUsS0FBSyxPQUNqQkQsT0FBTyxDQUFDQyxJQUFFLEVBQUUsS0FBSyxPQUNqQkQsT0FBTyxDQUFDQyxJQUFFLEVBQUUsS0FBSyxPQUNqQkQsT0FBTyxDQUFDQyxJQUFFLEVBQUUsS0FBSyxPQUNqQkQsT0FBTyxDQUFDQyxJQUFFLEVBQUUsS0FBSyxPQUNqQkQsT0FBTyxDQUFDQyxJQUFFLEVBQUUsS0FBSyxLQUFLLE9BQU87SUFDN0IsT0FBTztBQUNYO0FBRUEsU0FBU2dCLFVBQVVqQixPQUFPLEVBQUVDLENBQUM7SUFDekIsSUFBR0QsT0FBTyxDQUFDQyxJQUFFLEVBQUUsS0FBSyxPQUNwQkQsT0FBTyxDQUFDQyxJQUFFLEVBQUUsS0FBSyxPQUNqQkQsT0FBTyxDQUFDQyxJQUFFLEVBQUUsS0FBSyxPQUNqQkQsT0FBTyxDQUFDQyxJQUFFLEVBQUUsS0FBSyxPQUNqQkQsT0FBTyxDQUFDQyxJQUFFLEVBQUUsS0FBSyxPQUNqQkQsT0FBTyxDQUFDQyxJQUFFLEVBQUUsS0FBSyxPQUNqQkQsT0FBTyxDQUFDQyxJQUFFLEVBQUUsS0FBSyxPQUNqQkQsT0FBTyxDQUFDQyxJQUFFLEVBQUUsS0FBSyxLQUFLLE9BQU87SUFDN0IsT0FBTztBQUNYO0FBQ0EsU0FBU2lCLFdBQVdsQixPQUFPLEVBQUVDLENBQUM7SUFDMUIsSUFBR0QsT0FBTyxDQUFDQyxJQUFFLEVBQUUsS0FBSyxPQUNwQkQsT0FBTyxDQUFDQyxJQUFFLEVBQUUsS0FBSyxPQUNqQkQsT0FBTyxDQUFDQyxJQUFFLEVBQUUsS0FBSyxPQUNqQkQsT0FBTyxDQUFDQyxJQUFFLEVBQUUsS0FBSyxPQUNqQkQsT0FBTyxDQUFDQyxJQUFFLEVBQUUsS0FBSyxPQUNqQkQsT0FBTyxDQUFDQyxJQUFFLEVBQUUsS0FBSyxPQUNqQkQsT0FBTyxDQUFDQyxJQUFFLEVBQUUsS0FBSyxPQUNqQkQsT0FBTyxDQUFDQyxJQUFFLEVBQUUsS0FBSyxPQUNqQkQsT0FBTyxDQUFDQyxJQUFFLEVBQUUsS0FBSyxLQUFLLE9BQU87SUFDN0IsT0FBTztBQUNYO0FBRUEsU0FBU1ksbUJBQW1CVSxJQUFJO0lBQzVCLElBQUkxQixLQUFLMkIsTUFBTSxDQUFDRCxPQUNuQixPQUFPQTtTQUVBLE1BQU0sSUFBSUgsTUFBTSxDQUFDLG9CQUFvQixFQUFFRyxLQUFLLENBQUM7QUFDckQ7QUFFQUUsT0FBT0MsT0FBTyxHQUFHM0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90aGUtZ3JpZC0yLy4vbm9kZV9tb2R1bGVzL2Zhc3QteG1sLXBhcnNlci9zcmMveG1scGFyc2VyL0RvY1R5cGVSZWFkZXIuanM/YmQ4ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuXG4vL1RPRE86IGhhbmRsZSBjb21tZW50c1xuZnVuY3Rpb24gcmVhZERvY1R5cGUoeG1sRGF0YSwgaSl7XG4gICAgXG4gICAgY29uc3QgZW50aXRpZXMgPSB7fTtcbiAgICBpZiggeG1sRGF0YVtpICsgM10gPT09ICdPJyAmJlxuICAgICAgICAgeG1sRGF0YVtpICsgNF0gPT09ICdDJyAmJlxuICAgICAgICAgeG1sRGF0YVtpICsgNV0gPT09ICdUJyAmJlxuICAgICAgICAgeG1sRGF0YVtpICsgNl0gPT09ICdZJyAmJlxuICAgICAgICAgeG1sRGF0YVtpICsgN10gPT09ICdQJyAmJlxuICAgICAgICAgeG1sRGF0YVtpICsgOF0gPT09ICdFJylcbiAgICB7ICAgIFxuICAgICAgICBpID0gaSs5O1xuICAgICAgICBsZXQgYW5nbGVCcmFja2V0c0NvdW50ID0gMTtcbiAgICAgICAgbGV0IGhhc0JvZHkgPSBmYWxzZSwgY29tbWVudCA9IGZhbHNlO1xuICAgICAgICBsZXQgZXhwID0gXCJcIjtcbiAgICAgICAgZm9yKDtpPHhtbERhdGEubGVuZ3RoO2krKyl7XG4gICAgICAgICAgICBpZiAoeG1sRGF0YVtpXSA9PT0gJzwnICYmICFjb21tZW50KSB7IC8vRGV0ZXJtaW5lIHRoZSB0YWcgdHlwZVxuICAgICAgICAgICAgICAgIGlmKCBoYXNCb2R5ICYmIGlzRW50aXR5KHhtbERhdGEsIGkpKXtcbiAgICAgICAgICAgICAgICAgICAgaSArPSA3OyBcbiAgICAgICAgICAgICAgICAgICAgW2VudGl0eU5hbWUsIHZhbCxpXSA9IHJlYWRFbnRpdHlFeHAoeG1sRGF0YSxpKzEpO1xuICAgICAgICAgICAgICAgICAgICBpZih2YWwuaW5kZXhPZihcIiZcIikgPT09IC0xKSAvL1BhcmFtZXRlciBlbnRpdGllcyBhcmUgbm90IHN1cHBvcnRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgZW50aXRpZXNbIHZhbGlkYXRlRW50aXR5TmFtZShlbnRpdHlOYW1lKSBdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZ3ggOiBSZWdFeHAoIGAmJHtlbnRpdHlOYW1lfTtgLFwiZ1wiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWw6IHZhbFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiggaGFzQm9keSAmJiBpc0VsZW1lbnQoeG1sRGF0YSwgaSkpICBpICs9IDg7Ly9Ob3Qgc3VwcG9ydGVkXG4gICAgICAgICAgICAgICAgZWxzZSBpZiggaGFzQm9keSAmJiBpc0F0dGxpc3QoeG1sRGF0YSwgaSkpICBpICs9IDg7Ly9Ob3Qgc3VwcG9ydGVkXG4gICAgICAgICAgICAgICAgZWxzZSBpZiggaGFzQm9keSAmJiBpc05vdGF0aW9uKHhtbERhdGEsIGkpKSBpICs9IDk7Ly9Ob3Qgc3VwcG9ydGVkXG4gICAgICAgICAgICAgICAgZWxzZSBpZiggaXNDb21tZW50KSAgICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBlbHNlICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgRE9DVFlQRVwiKTtcblxuICAgICAgICAgICAgICAgIGFuZ2xlQnJhY2tldHNDb3VudCsrO1xuICAgICAgICAgICAgICAgIGV4cCA9IFwiXCI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHhtbERhdGFbaV0gPT09ICc+JykgeyAvL1JlYWQgdGFnIGNvbnRlbnRcbiAgICAgICAgICAgICAgICBpZihjb21tZW50KXtcbiAgICAgICAgICAgICAgICAgICAgaWYoIHhtbERhdGFbaSAtIDFdID09PSBcIi1cIiAmJiB4bWxEYXRhW2kgLSAyXSA9PT0gXCItXCIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYW5nbGVCcmFja2V0c0NvdW50LS07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgYW5nbGVCcmFja2V0c0NvdW50LS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhbmdsZUJyYWNrZXRzQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1lbHNlIGlmKCB4bWxEYXRhW2ldID09PSAnWycpe1xuICAgICAgICAgICAgICAgIGhhc0JvZHkgPSB0cnVlO1xuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgZXhwICs9IHhtbERhdGFbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYoYW5nbGVCcmFja2V0c0NvdW50ICE9PSAwKXtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5jbG9zZWQgRE9DVFlQRWApO1xuICAgICAgICB9XG4gICAgfWVsc2V7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBUYWcgaW5zdGVhZCBvZiBET0NUWVBFYCk7XG4gICAgfVxuICAgIHJldHVybiB7ZW50aXRpZXMsIGl9O1xufVxuXG5mdW5jdGlvbiByZWFkRW50aXR5RXhwKHhtbERhdGEsaSl7XG4gICAgLy9FeHRlcm5hbCBlbnRpdGllcyBhcmUgbm90IHN1cHBvcnRlZFxuICAgIC8vICAgIDwhRU5USVRZIGV4dCBTWVNURU0gXCJodHRwOi8vbm9ybWFsLXdlYnNpdGUuY29tXCIgPlxuXG4gICAgLy9QYXJhbWV0ZXIgZW50aXRpZXMgYXJlIG5vdCBzdXBwb3J0ZWRcbiAgICAvLyAgICA8IUVOVElUWSBlbnRpdHluYW1lIFwiJmFub3RoZXJFbGVtZW50O1wiPlxuXG4gICAgLy9JbnRlcm5hbCBlbnRpdGllcyBhcmUgc3VwcG9ydGVkXG4gICAgLy8gICAgPCFFTlRJVFkgZW50aXR5bmFtZSBcInJlcGxhY2VtZW50IHRleHRcIj5cbiAgICBcbiAgICAvL3JlYWQgRW50aXR5TmFtZVxuICAgIGxldCBlbnRpdHlOYW1lID0gXCJcIjtcbiAgICBmb3IgKDsgaSA8IHhtbERhdGEubGVuZ3RoICYmICh4bWxEYXRhW2ldICE9PSBcIidcIiAmJiB4bWxEYXRhW2ldICE9PSAnXCInICk7IGkrKykge1xuICAgICAgICAvLyBpZih4bWxEYXRhW2ldID09PSBcIiBcIikgY29udGludWU7XG4gICAgICAgIC8vIGVsc2UgXG4gICAgICAgIGVudGl0eU5hbWUgKz0geG1sRGF0YVtpXTtcbiAgICB9XG4gICAgZW50aXR5TmFtZSA9IGVudGl0eU5hbWUudHJpbSgpO1xuICAgIGlmKGVudGl0eU5hbWUuaW5kZXhPZihcIiBcIikgIT09IC0xKSB0aHJvdyBuZXcgRXJyb3IoXCJFeHRlcm5hbCBlbnRpdGVzIGFyZSBub3Qgc3VwcG9ydGVkXCIpO1xuXG4gICAgLy9yZWFkIEVudGl0eSBWYWx1ZVxuICAgIGNvbnN0IHN0YXJ0Q2hhciA9IHhtbERhdGFbaSsrXTtcbiAgICBsZXQgdmFsID0gXCJcIlxuICAgIGZvciAoOyBpIDwgeG1sRGF0YS5sZW5ndGggJiYgeG1sRGF0YVtpXSAhPT0gc3RhcnRDaGFyIDsgaSsrKSB7XG4gICAgICAgIHZhbCArPSB4bWxEYXRhW2ldO1xuICAgIH1cbiAgICByZXR1cm4gW2VudGl0eU5hbWUsIHZhbCwgaV07XG59XG5cbmZ1bmN0aW9uIGlzQ29tbWVudCh4bWxEYXRhLCBpKXtcbiAgICBpZih4bWxEYXRhW2krMV0gPT09ICchJyAmJlxuICAgIHhtbERhdGFbaSsyXSA9PT0gJy0nICYmXG4gICAgeG1sRGF0YVtpKzNdID09PSAnLScpIHJldHVybiB0cnVlXG4gICAgcmV0dXJuIGZhbHNlXG59XG5mdW5jdGlvbiBpc0VudGl0eSh4bWxEYXRhLCBpKXtcbiAgICBpZih4bWxEYXRhW2krMV0gPT09ICchJyAmJlxuICAgIHhtbERhdGFbaSsyXSA9PT0gJ0UnICYmXG4gICAgeG1sRGF0YVtpKzNdID09PSAnTicgJiZcbiAgICB4bWxEYXRhW2krNF0gPT09ICdUJyAmJlxuICAgIHhtbERhdGFbaSs1XSA9PT0gJ0knICYmXG4gICAgeG1sRGF0YVtpKzZdID09PSAnVCcgJiZcbiAgICB4bWxEYXRhW2krN10gPT09ICdZJykgcmV0dXJuIHRydWVcbiAgICByZXR1cm4gZmFsc2Vcbn1cbmZ1bmN0aW9uIGlzRWxlbWVudCh4bWxEYXRhLCBpKXtcbiAgICBpZih4bWxEYXRhW2krMV0gPT09ICchJyAmJlxuICAgIHhtbERhdGFbaSsyXSA9PT0gJ0UnICYmXG4gICAgeG1sRGF0YVtpKzNdID09PSAnTCcgJiZcbiAgICB4bWxEYXRhW2krNF0gPT09ICdFJyAmJlxuICAgIHhtbERhdGFbaSs1XSA9PT0gJ00nICYmXG4gICAgeG1sRGF0YVtpKzZdID09PSAnRScgJiZcbiAgICB4bWxEYXRhW2krN10gPT09ICdOJyAmJlxuICAgIHhtbERhdGFbaSs4XSA9PT0gJ1QnKSByZXR1cm4gdHJ1ZVxuICAgIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBpc0F0dGxpc3QoeG1sRGF0YSwgaSl7XG4gICAgaWYoeG1sRGF0YVtpKzFdID09PSAnIScgJiZcbiAgICB4bWxEYXRhW2krMl0gPT09ICdBJyAmJlxuICAgIHhtbERhdGFbaSszXSA9PT0gJ1QnICYmXG4gICAgeG1sRGF0YVtpKzRdID09PSAnVCcgJiZcbiAgICB4bWxEYXRhW2krNV0gPT09ICdMJyAmJlxuICAgIHhtbERhdGFbaSs2XSA9PT0gJ0knICYmXG4gICAgeG1sRGF0YVtpKzddID09PSAnUycgJiZcbiAgICB4bWxEYXRhW2krOF0gPT09ICdUJykgcmV0dXJuIHRydWVcbiAgICByZXR1cm4gZmFsc2Vcbn1cbmZ1bmN0aW9uIGlzTm90YXRpb24oeG1sRGF0YSwgaSl7XG4gICAgaWYoeG1sRGF0YVtpKzFdID09PSAnIScgJiZcbiAgICB4bWxEYXRhW2krMl0gPT09ICdOJyAmJlxuICAgIHhtbERhdGFbaSszXSA9PT0gJ08nICYmXG4gICAgeG1sRGF0YVtpKzRdID09PSAnVCcgJiZcbiAgICB4bWxEYXRhW2krNV0gPT09ICdBJyAmJlxuICAgIHhtbERhdGFbaSs2XSA9PT0gJ1QnICYmXG4gICAgeG1sRGF0YVtpKzddID09PSAnSScgJiZcbiAgICB4bWxEYXRhW2krOF0gPT09ICdPJyAmJlxuICAgIHhtbERhdGFbaSs5XSA9PT0gJ04nKSByZXR1cm4gdHJ1ZVxuICAgIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUVudGl0eU5hbWUobmFtZSl7XG4gICAgaWYgKHV0aWwuaXNOYW1lKG5hbWUpKVxuXHRyZXR1cm4gbmFtZTtcbiAgICBlbHNlXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBlbnRpdHkgbmFtZSAke25hbWV9YCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVhZERvY1R5cGU7XG4iXSwibmFtZXMiOlsidXRpbCIsInJlcXVpcmUiLCJyZWFkRG9jVHlwZSIsInhtbERhdGEiLCJpIiwiZW50aXRpZXMiLCJhbmdsZUJyYWNrZXRzQ291bnQiLCJoYXNCb2R5IiwiY29tbWVudCIsImV4cCIsImxlbmd0aCIsImlzRW50aXR5IiwiZW50aXR5TmFtZSIsInZhbCIsInJlYWRFbnRpdHlFeHAiLCJpbmRleE9mIiwidmFsaWRhdGVFbnRpdHlOYW1lIiwicmVneCIsIlJlZ0V4cCIsImlzRWxlbWVudCIsImlzQXR0bGlzdCIsImlzTm90YXRpb24iLCJpc0NvbW1lbnQiLCJFcnJvciIsInRyaW0iLCJzdGFydENoYXIiLCJuYW1lIiwiaXNOYW1lIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js":
/*!**********************************************************************!*\
  !*** ./node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("const defaultOptions = {\n    preserveOrder: false,\n    attributeNamePrefix: \"@_\",\n    attributesGroupName: false,\n    textNodeName: \"#text\",\n    ignoreAttributes: true,\n    removeNSPrefix: false,\n    allowBooleanAttributes: false,\n    //ignoreRootElement : false,\n    parseTagValue: true,\n    parseAttributeValue: false,\n    trimValues: true,\n    cdataPropName: false,\n    numberParseOptions: {\n        hex: true,\n        leadingZeros: true,\n        eNotation: true\n    },\n    tagValueProcessor: function(tagName, val) {\n        return val;\n    },\n    attributeValueProcessor: function(attrName, val) {\n        return val;\n    },\n    stopNodes: [],\n    alwaysCreateTextNode: false,\n    isArray: ()=>false,\n    commentPropName: false,\n    unpairedTags: [],\n    processEntities: true,\n    htmlEntities: false,\n    ignoreDeclaration: false,\n    ignorePiTags: false,\n    transformTagName: false,\n    transformAttributeName: false,\n    updateTag: function(tagName, jPath, attrs) {\n        return tagName;\n    }\n};\nconst buildOptions = function(options) {\n    return Object.assign({}, defaultOptions, options);\n};\nexports.buildOptions = buildOptions;\nexports.defaultOptions = defaultOptions;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmFzdC14bWwtcGFyc2VyL3NyYy94bWxwYXJzZXIvT3B0aW9uc0J1aWxkZXIuanMiLCJtYXBwaW5ncyI6IkFBQ0EsTUFBTUEsaUJBQWlCO0lBQ25CQyxlQUFlO0lBQ2ZDLHFCQUFxQjtJQUNyQkMscUJBQXFCO0lBQ3JCQyxjQUFjO0lBQ2RDLGtCQUFrQjtJQUNsQkMsZ0JBQWdCO0lBQ2hCQyx3QkFBd0I7SUFDeEIsNEJBQTRCO0lBQzVCQyxlQUFlO0lBQ2ZDLHFCQUFxQjtJQUNyQkMsWUFBWTtJQUNaQyxlQUFlO0lBQ2ZDLG9CQUFvQjtRQUNsQkMsS0FBSztRQUNMQyxjQUFjO1FBQ2RDLFdBQVc7SUFDYjtJQUNBQyxtQkFBbUIsU0FBU0MsT0FBTyxFQUFFQyxHQUFHO1FBQ3RDLE9BQU9BO0lBQ1Q7SUFDQUMseUJBQXlCLFNBQVNDLFFBQVEsRUFBRUYsR0FBRztRQUM3QyxPQUFPQTtJQUNUO0lBQ0FHLFdBQVcsRUFBRTtJQUNiQyxzQkFBc0I7SUFDdEJDLFNBQVMsSUFBTTtJQUNmQyxpQkFBaUI7SUFDakJDLGNBQWMsRUFBRTtJQUNoQkMsaUJBQWlCO0lBQ2pCQyxjQUFjO0lBQ2RDLG1CQUFtQjtJQUNuQkMsY0FBYztJQUNkQyxrQkFBa0I7SUFDbEJDLHdCQUF3QjtJQUN4QkMsV0FBVyxTQUFTZixPQUFPLEVBQUVnQixLQUFLLEVBQUVDLEtBQUs7UUFDdkMsT0FBT2pCO0lBQ1Q7QUFFSjtBQUVBLE1BQU1rQixlQUFlLFNBQVNDLE9BQU87SUFDakMsT0FBT0MsT0FBT0MsTUFBTSxDQUFDLENBQUMsR0FBR3RDLGdCQUFnQm9DO0FBQzdDO0FBRUFHLG9CQUFvQixHQUFHSjtBQUN2Qkksc0JBQXNCLEdBQUd2QyIsInNvdXJjZXMiOlsid2VicGFjazovL3RoZS1ncmlkLTIvLi9ub2RlX21vZHVsZXMvZmFzdC14bWwtcGFyc2VyL3NyYy94bWxwYXJzZXIvT3B0aW9uc0J1aWxkZXIuanM/YmI3OCJdLCJzb3VyY2VzQ29udGVudCI6WyJcbmNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgIHByZXNlcnZlT3JkZXI6IGZhbHNlLFxuICAgIGF0dHJpYnV0ZU5hbWVQcmVmaXg6ICdAXycsXG4gICAgYXR0cmlidXRlc0dyb3VwTmFtZTogZmFsc2UsXG4gICAgdGV4dE5vZGVOYW1lOiAnI3RleHQnLFxuICAgIGlnbm9yZUF0dHJpYnV0ZXM6IHRydWUsXG4gICAgcmVtb3ZlTlNQcmVmaXg6IGZhbHNlLCAvLyByZW1vdmUgTlMgZnJvbSB0YWcgbmFtZSBvciBhdHRyaWJ1dGUgbmFtZSBpZiB0cnVlXG4gICAgYWxsb3dCb29sZWFuQXR0cmlidXRlczogZmFsc2UsIC8vYSB0YWcgY2FuIGhhdmUgYXR0cmlidXRlcyB3aXRob3V0IGFueSB2YWx1ZVxuICAgIC8vaWdub3JlUm9vdEVsZW1lbnQgOiBmYWxzZSxcbiAgICBwYXJzZVRhZ1ZhbHVlOiB0cnVlLFxuICAgIHBhcnNlQXR0cmlidXRlVmFsdWU6IGZhbHNlLFxuICAgIHRyaW1WYWx1ZXM6IHRydWUsIC8vVHJpbSBzdHJpbmcgdmFsdWVzIG9mIHRhZyBhbmQgYXR0cmlidXRlc1xuICAgIGNkYXRhUHJvcE5hbWU6IGZhbHNlLFxuICAgIG51bWJlclBhcnNlT3B0aW9uczoge1xuICAgICAgaGV4OiB0cnVlLFxuICAgICAgbGVhZGluZ1plcm9zOiB0cnVlLFxuICAgICAgZU5vdGF0aW9uOiB0cnVlXG4gICAgfSxcbiAgICB0YWdWYWx1ZVByb2Nlc3NvcjogZnVuY3Rpb24odGFnTmFtZSwgdmFsKSB7XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH0sXG4gICAgYXR0cmlidXRlVmFsdWVQcm9jZXNzb3I6IGZ1bmN0aW9uKGF0dHJOYW1lLCB2YWwpIHtcbiAgICAgIHJldHVybiB2YWw7XG4gICAgfSxcbiAgICBzdG9wTm9kZXM6IFtdLCAvL25lc3RlZCB0YWdzIHdpbGwgbm90IGJlIHBhcnNlZCBldmVuIGZvciBlcnJvcnNcbiAgICBhbHdheXNDcmVhdGVUZXh0Tm9kZTogZmFsc2UsXG4gICAgaXNBcnJheTogKCkgPT4gZmFsc2UsXG4gICAgY29tbWVudFByb3BOYW1lOiBmYWxzZSxcbiAgICB1bnBhaXJlZFRhZ3M6IFtdLFxuICAgIHByb2Nlc3NFbnRpdGllczogdHJ1ZSxcbiAgICBodG1sRW50aXRpZXM6IGZhbHNlLFxuICAgIGlnbm9yZURlY2xhcmF0aW9uOiBmYWxzZSxcbiAgICBpZ25vcmVQaVRhZ3M6IGZhbHNlLFxuICAgIHRyYW5zZm9ybVRhZ05hbWU6IGZhbHNlLFxuICAgIHRyYW5zZm9ybUF0dHJpYnV0ZU5hbWU6IGZhbHNlLFxuICAgIHVwZGF0ZVRhZzogZnVuY3Rpb24odGFnTmFtZSwgalBhdGgsIGF0dHJzKXtcbiAgICAgIHJldHVybiB0YWdOYW1lXG4gICAgfSxcbiAgICAvLyBza2lwRW1wdHlMaXN0SXRlbTogZmFsc2Vcbn07XG4gICBcbmNvbnN0IGJ1aWxkT3B0aW9ucyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpO1xufTtcblxuZXhwb3J0cy5idWlsZE9wdGlvbnMgPSBidWlsZE9wdGlvbnM7XG5leHBvcnRzLmRlZmF1bHRPcHRpb25zID0gZGVmYXVsdE9wdGlvbnM7Il0sIm5hbWVzIjpbImRlZmF1bHRPcHRpb25zIiwicHJlc2VydmVPcmRlciIsImF0dHJpYnV0ZU5hbWVQcmVmaXgiLCJhdHRyaWJ1dGVzR3JvdXBOYW1lIiwidGV4dE5vZGVOYW1lIiwiaWdub3JlQXR0cmlidXRlcyIsInJlbW92ZU5TUHJlZml4IiwiYWxsb3dCb29sZWFuQXR0cmlidXRlcyIsInBhcnNlVGFnVmFsdWUiLCJwYXJzZUF0dHJpYnV0ZVZhbHVlIiwidHJpbVZhbHVlcyIsImNkYXRhUHJvcE5hbWUiLCJudW1iZXJQYXJzZU9wdGlvbnMiLCJoZXgiLCJsZWFkaW5nWmVyb3MiLCJlTm90YXRpb24iLCJ0YWdWYWx1ZVByb2Nlc3NvciIsInRhZ05hbWUiLCJ2YWwiLCJhdHRyaWJ1dGVWYWx1ZVByb2Nlc3NvciIsImF0dHJOYW1lIiwic3RvcE5vZGVzIiwiYWx3YXlzQ3JlYXRlVGV4dE5vZGUiLCJpc0FycmF5IiwiY29tbWVudFByb3BOYW1lIiwidW5wYWlyZWRUYWdzIiwicHJvY2Vzc0VudGl0aWVzIiwiaHRtbEVudGl0aWVzIiwiaWdub3JlRGVjbGFyYXRpb24iLCJpZ25vcmVQaVRhZ3MiLCJ0cmFuc2Zvcm1UYWdOYW1lIiwidHJhbnNmb3JtQXR0cmlidXRlTmFtZSIsInVwZGF0ZVRhZyIsImpQYXRoIiwiYXR0cnMiLCJidWlsZE9wdGlvbnMiLCJvcHRpb25zIiwiT2JqZWN0IiwiYXNzaWduIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js":
/*!************************************************************************!*\
  !*** ./node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n///@ts-check\nconst util = __webpack_require__(/*! ../util */ \"(ssr)/./node_modules/fast-xml-parser/src/util.js\");\nconst xmlNode = __webpack_require__(/*! ./xmlNode */ \"(ssr)/./node_modules/fast-xml-parser/src/xmlparser/xmlNode.js\");\nconst readDocType = __webpack_require__(/*! ./DocTypeReader */ \"(ssr)/./node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js\");\nconst toNumber = __webpack_require__(/*! strnum */ \"(ssr)/./node_modules/strnum/strnum.js\");\n// const regx =\n//   '<((!\\\\[CDATA\\\\[([\\\\s\\\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\\\/)(NAME)\\\\s*>))([^<]*)'\n//   .replace(/NAME/g, util.nameRegexp);\n//const tagsRegx = new RegExp(\"<(\\\\/?[\\\\w:\\\\-\\._]+)([^>]*)>(\\\\s*\"+cdataRegx+\")*([^<]+)?\",\"g\");\n//const tagsRegx = new RegExp(\"<(\\\\/?)((\\\\w*:)?([\\\\w:\\\\-\\._]+))([^>]*)>([^<]*)(\"+cdataRegx+\"([^<]*))*([^<]+)?\",\"g\");\nclass OrderedObjParser {\n    constructor(options){\n        this.options = options;\n        this.currentNode = null;\n        this.tagsNodeStack = [];\n        this.docTypeEntities = {};\n        this.lastEntities = {\n            \"apos\": {\n                regex: /&(apos|#39|#x27);/g,\n                val: \"'\"\n            },\n            \"gt\": {\n                regex: /&(gt|#62|#x3E);/g,\n                val: \">\"\n            },\n            \"lt\": {\n                regex: /&(lt|#60|#x3C);/g,\n                val: \"<\"\n            },\n            \"quot\": {\n                regex: /&(quot|#34|#x22);/g,\n                val: '\"'\n            }\n        };\n        this.ampEntity = {\n            regex: /&(amp|#38|#x26);/g,\n            val: \"&\"\n        };\n        this.htmlEntities = {\n            \"space\": {\n                regex: /&(nbsp|#160);/g,\n                val: \" \"\n            },\n            // \"lt\" : { regex: /&(lt|#60);/g, val: \"<\" },\n            // \"gt\" : { regex: /&(gt|#62);/g, val: \">\" },\n            // \"amp\" : { regex: /&(amp|#38);/g, val: \"&\" },\n            // \"quot\" : { regex: /&(quot|#34);/g, val: \"\\\"\" },\n            // \"apos\" : { regex: /&(apos|#39);/g, val: \"'\" },\n            \"cent\": {\n                regex: /&(cent|#162);/g,\n                val: \"\\xa2\"\n            },\n            \"pound\": {\n                regex: /&(pound|#163);/g,\n                val: \"\\xa3\"\n            },\n            \"yen\": {\n                regex: /&(yen|#165);/g,\n                val: \"\\xa5\"\n            },\n            \"euro\": {\n                regex: /&(euro|#8364);/g,\n                val: \"€\"\n            },\n            \"copyright\": {\n                regex: /&(copy|#169);/g,\n                val: \"\\xa9\"\n            },\n            \"reg\": {\n                regex: /&(reg|#174);/g,\n                val: \"\\xae\"\n            },\n            \"inr\": {\n                regex: /&(inr|#8377);/g,\n                val: \"₹\"\n            }\n        };\n        this.addExternalEntities = addExternalEntities;\n        this.parseXml = parseXml;\n        this.parseTextData = parseTextData;\n        this.resolveNameSpace = resolveNameSpace;\n        this.buildAttributesMap = buildAttributesMap;\n        this.isItStopNode = isItStopNode;\n        this.replaceEntitiesValue = replaceEntitiesValue;\n        this.readStopNodeData = readStopNodeData;\n        this.saveTextToParentTag = saveTextToParentTag;\n        this.addChild = addChild;\n    }\n}\nfunction addExternalEntities(externalEntities) {\n    const entKeys = Object.keys(externalEntities);\n    for(let i = 0; i < entKeys.length; i++){\n        const ent = entKeys[i];\n        this.lastEntities[ent] = {\n            regex: new RegExp(\"&\" + ent + \";\", \"g\"),\n            val: externalEntities[ent]\n        };\n    }\n}\n/**\n * @param {string} val\n * @param {string} tagName\n * @param {string} jPath\n * @param {boolean} dontTrim\n * @param {boolean} hasAttributes\n * @param {boolean} isLeafNode\n * @param {boolean} escapeEntities\n */ function parseTextData(val, tagName, jPath, dontTrim, hasAttributes, isLeafNode, escapeEntities) {\n    if (val !== undefined) {\n        if (this.options.trimValues && !dontTrim) {\n            val = val.trim();\n        }\n        if (val.length > 0) {\n            if (!escapeEntities) val = this.replaceEntitiesValue(val);\n            const newval = this.options.tagValueProcessor(tagName, val, jPath, hasAttributes, isLeafNode);\n            if (newval === null || newval === undefined) {\n                //don't parse\n                return val;\n            } else if (typeof newval !== typeof val || newval !== val) {\n                //overwrite\n                return newval;\n            } else if (this.options.trimValues) {\n                return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);\n            } else {\n                const trimmedVal = val.trim();\n                if (trimmedVal === val) {\n                    return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);\n                } else {\n                    return val;\n                }\n            }\n        }\n    }\n}\nfunction resolveNameSpace(tagname) {\n    if (this.options.removeNSPrefix) {\n        const tags = tagname.split(\":\");\n        const prefix = tagname.charAt(0) === \"/\" ? \"/\" : \"\";\n        if (tags[0] === \"xmlns\") {\n            return \"\";\n        }\n        if (tags.length === 2) {\n            tagname = prefix + tags[1];\n        }\n    }\n    return tagname;\n}\n//TODO: change regex to capture NS\n//const attrsRegx = new RegExp(\"([\\\\w\\\\-\\\\.\\\\:]+)\\\\s*=\\\\s*(['\\\"])((.|\\n)*?)\\\\2\",\"gm\");\nconst attrsRegx = new RegExp(\"([^\\\\s=]+)\\\\s*(=\\\\s*(['\\\"])([\\\\s\\\\S]*?)\\\\3)?\", \"gm\");\nfunction buildAttributesMap(attrStr, jPath, tagName) {\n    if (!this.options.ignoreAttributes && typeof attrStr === \"string\") {\n        // attrStr = attrStr.replace(/\\r?\\n/g, ' ');\n        //attrStr = attrStr || attrStr.trim();\n        const matches = util.getAllMatches(attrStr, attrsRegx);\n        const len = matches.length; //don't make it inline\n        const attrs = {};\n        for(let i = 0; i < len; i++){\n            const attrName = this.resolveNameSpace(matches[i][1]);\n            let oldVal = matches[i][4];\n            let aName = this.options.attributeNamePrefix + attrName;\n            if (attrName.length) {\n                if (this.options.transformAttributeName) {\n                    aName = this.options.transformAttributeName(aName);\n                }\n                if (aName === \"__proto__\") aName = \"#__proto__\";\n                if (oldVal !== undefined) {\n                    if (this.options.trimValues) {\n                        oldVal = oldVal.trim();\n                    }\n                    oldVal = this.replaceEntitiesValue(oldVal);\n                    const newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);\n                    if (newVal === null || newVal === undefined) {\n                        //don't parse\n                        attrs[aName] = oldVal;\n                    } else if (typeof newVal !== typeof oldVal || newVal !== oldVal) {\n                        //overwrite\n                        attrs[aName] = newVal;\n                    } else {\n                        //parse\n                        attrs[aName] = parseValue(oldVal, this.options.parseAttributeValue, this.options.numberParseOptions);\n                    }\n                } else if (this.options.allowBooleanAttributes) {\n                    attrs[aName] = true;\n                }\n            }\n        }\n        if (!Object.keys(attrs).length) {\n            return;\n        }\n        if (this.options.attributesGroupName) {\n            const attrCollection = {};\n            attrCollection[this.options.attributesGroupName] = attrs;\n            return attrCollection;\n        }\n        return attrs;\n    }\n}\nconst parseXml = function(xmlData) {\n    xmlData = xmlData.replace(/\\r\\n?/g, \"\\n\"); //TODO: remove this line\n    const xmlObj = new xmlNode(\"!xml\");\n    let currentNode = xmlObj;\n    let textData = \"\";\n    let jPath = \"\";\n    for(let i = 0; i < xmlData.length; i++){\n        const ch = xmlData[i];\n        if (ch === \"<\") {\n            // const nextIndex = i+1;\n            // const _2ndChar = xmlData[nextIndex];\n            if (xmlData[i + 1] === \"/\") {\n                const closeIndex = findClosingIndex(xmlData, \">\", i, \"Closing Tag is not closed.\");\n                let tagName = xmlData.substring(i + 2, closeIndex).trim();\n                if (this.options.removeNSPrefix) {\n                    const colonIndex = tagName.indexOf(\":\");\n                    if (colonIndex !== -1) {\n                        tagName = tagName.substr(colonIndex + 1);\n                    }\n                }\n                if (this.options.transformTagName) {\n                    tagName = this.options.transformTagName(tagName);\n                }\n                if (currentNode) {\n                    textData = this.saveTextToParentTag(textData, currentNode, jPath);\n                }\n                //check if last tag of nested tag was unpaired tag\n                const lastTagName = jPath.substring(jPath.lastIndexOf(\".\") + 1);\n                if (tagName && this.options.unpairedTags.indexOf(tagName) !== -1) {\n                    throw new Error(`Unpaired tag can not be used as closing tag: </${tagName}>`);\n                }\n                let propIndex = 0;\n                if (lastTagName && this.options.unpairedTags.indexOf(lastTagName) !== -1) {\n                    propIndex = jPath.lastIndexOf(\".\", jPath.lastIndexOf(\".\") - 1);\n                    this.tagsNodeStack.pop();\n                } else {\n                    propIndex = jPath.lastIndexOf(\".\");\n                }\n                jPath = jPath.substring(0, propIndex);\n                currentNode = this.tagsNodeStack.pop(); //avoid recursion, set the parent tag scope\n                textData = \"\";\n                i = closeIndex;\n            } else if (xmlData[i + 1] === \"?\") {\n                let tagData = readTagExp(xmlData, i, false, \"?>\");\n                if (!tagData) throw new Error(\"Pi Tag is not closed.\");\n                textData = this.saveTextToParentTag(textData, currentNode, jPath);\n                if (this.options.ignoreDeclaration && tagData.tagName === \"?xml\" || this.options.ignorePiTags) {} else {\n                    const childNode = new xmlNode(tagData.tagName);\n                    childNode.add(this.options.textNodeName, \"\");\n                    if (tagData.tagName !== tagData.tagExp && tagData.attrExpPresent) {\n                        childNode[\":@\"] = this.buildAttributesMap(tagData.tagExp, jPath, tagData.tagName);\n                    }\n                    this.addChild(currentNode, childNode, jPath);\n                }\n                i = tagData.closeIndex + 1;\n            } else if (xmlData.substr(i + 1, 3) === \"!--\") {\n                const endIndex = findClosingIndex(xmlData, \"-->\", i + 4, \"Comment is not closed.\");\n                if (this.options.commentPropName) {\n                    const comment = xmlData.substring(i + 4, endIndex - 2);\n                    textData = this.saveTextToParentTag(textData, currentNode, jPath);\n                    currentNode.add(this.options.commentPropName, [\n                        {\n                            [this.options.textNodeName]: comment\n                        }\n                    ]);\n                }\n                i = endIndex;\n            } else if (xmlData.substr(i + 1, 2) === \"!D\") {\n                const result = readDocType(xmlData, i);\n                this.docTypeEntities = result.entities;\n                i = result.i;\n            } else if (xmlData.substr(i + 1, 2) === \"![\") {\n                const closeIndex = findClosingIndex(xmlData, \"]]>\", i, \"CDATA is not closed.\") - 2;\n                const tagExp = xmlData.substring(i + 9, closeIndex);\n                textData = this.saveTextToParentTag(textData, currentNode, jPath);\n                let val = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true, true);\n                if (val == undefined) val = \"\";\n                //cdata should be set even if it is 0 length string\n                if (this.options.cdataPropName) {\n                    currentNode.add(this.options.cdataPropName, [\n                        {\n                            [this.options.textNodeName]: tagExp\n                        }\n                    ]);\n                } else {\n                    currentNode.add(this.options.textNodeName, val);\n                }\n                i = closeIndex + 2;\n            } else {\n                let result = readTagExp(xmlData, i, this.options.removeNSPrefix);\n                let tagName = result.tagName;\n                const rawTagName = result.rawTagName;\n                let tagExp = result.tagExp;\n                let attrExpPresent = result.attrExpPresent;\n                let closeIndex = result.closeIndex;\n                if (this.options.transformTagName) {\n                    tagName = this.options.transformTagName(tagName);\n                }\n                //save text as child node\n                if (currentNode && textData) {\n                    if (currentNode.tagname !== \"!xml\") {\n                        //when nested tag is found\n                        textData = this.saveTextToParentTag(textData, currentNode, jPath, false);\n                    }\n                }\n                //check if last tag was unpaired tag\n                const lastTag = currentNode;\n                if (lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1) {\n                    currentNode = this.tagsNodeStack.pop();\n                    jPath = jPath.substring(0, jPath.lastIndexOf(\".\"));\n                }\n                if (tagName !== xmlObj.tagname) {\n                    jPath += jPath ? \".\" + tagName : tagName;\n                }\n                if (this.isItStopNode(this.options.stopNodes, jPath, tagName)) {\n                    let tagContent = \"\";\n                    //self-closing tag\n                    if (tagExp.length > 0 && tagExp.lastIndexOf(\"/\") === tagExp.length - 1) {\n                        i = result.closeIndex;\n                    } else if (this.options.unpairedTags.indexOf(tagName) !== -1) {\n                        i = result.closeIndex;\n                    } else {\n                        //read until closing tag is found\n                        const result = this.readStopNodeData(xmlData, rawTagName, closeIndex + 1);\n                        if (!result) throw new Error(`Unexpected end of ${rawTagName}`);\n                        i = result.i;\n                        tagContent = result.tagContent;\n                    }\n                    const childNode = new xmlNode(tagName);\n                    if (tagName !== tagExp && attrExpPresent) {\n                        childNode[\":@\"] = this.buildAttributesMap(tagExp, jPath, tagName);\n                    }\n                    if (tagContent) {\n                        tagContent = this.parseTextData(tagContent, tagName, jPath, true, attrExpPresent, true, true);\n                    }\n                    jPath = jPath.substr(0, jPath.lastIndexOf(\".\"));\n                    childNode.add(this.options.textNodeName, tagContent);\n                    this.addChild(currentNode, childNode, jPath);\n                } else {\n                    //selfClosing tag\n                    if (tagExp.length > 0 && tagExp.lastIndexOf(\"/\") === tagExp.length - 1) {\n                        if (tagName[tagName.length - 1] === \"/\") {\n                            tagName = tagName.substr(0, tagName.length - 1);\n                            jPath = jPath.substr(0, jPath.length - 1);\n                            tagExp = tagName;\n                        } else {\n                            tagExp = tagExp.substr(0, tagExp.length - 1);\n                        }\n                        if (this.options.transformTagName) {\n                            tagName = this.options.transformTagName(tagName);\n                        }\n                        const childNode = new xmlNode(tagName);\n                        if (tagName !== tagExp && attrExpPresent) {\n                            childNode[\":@\"] = this.buildAttributesMap(tagExp, jPath, tagName);\n                        }\n                        this.addChild(currentNode, childNode, jPath);\n                        jPath = jPath.substr(0, jPath.lastIndexOf(\".\"));\n                    } else {\n                        const childNode = new xmlNode(tagName);\n                        this.tagsNodeStack.push(currentNode);\n                        if (tagName !== tagExp && attrExpPresent) {\n                            childNode[\":@\"] = this.buildAttributesMap(tagExp, jPath, tagName);\n                        }\n                        this.addChild(currentNode, childNode, jPath);\n                        currentNode = childNode;\n                    }\n                    textData = \"\";\n                    i = closeIndex;\n                }\n            }\n        } else {\n            textData += xmlData[i];\n        }\n    }\n    return xmlObj.child;\n};\nfunction addChild(currentNode, childNode, jPath) {\n    const result = this.options.updateTag(childNode.tagname, jPath, childNode[\":@\"]);\n    if (result === false) {} else if (typeof result === \"string\") {\n        childNode.tagname = result;\n        currentNode.addChild(childNode);\n    } else {\n        currentNode.addChild(childNode);\n    }\n}\nconst replaceEntitiesValue = function(val) {\n    if (this.options.processEntities) {\n        for(let entityName in this.docTypeEntities){\n            const entity = this.docTypeEntities[entityName];\n            val = val.replace(entity.regx, entity.val);\n        }\n        for(let entityName in this.lastEntities){\n            const entity = this.lastEntities[entityName];\n            val = val.replace(entity.regex, entity.val);\n        }\n        if (this.options.htmlEntities) {\n            for(let entityName in this.htmlEntities){\n                const entity = this.htmlEntities[entityName];\n                val = val.replace(entity.regex, entity.val);\n            }\n        }\n        val = val.replace(this.ampEntity.regex, this.ampEntity.val);\n    }\n    return val;\n};\nfunction saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {\n    if (textData) {\n        if (isLeafNode === undefined) isLeafNode = Object.keys(currentNode.child).length === 0;\n        textData = this.parseTextData(textData, currentNode.tagname, jPath, false, currentNode[\":@\"] ? Object.keys(currentNode[\":@\"]).length !== 0 : false, isLeafNode);\n        if (textData !== undefined && textData !== \"\") currentNode.add(this.options.textNodeName, textData);\n        textData = \"\";\n    }\n    return textData;\n}\n//TODO: use jPath to simplify the logic\n/**\n * \n * @param {string[]} stopNodes \n * @param {string} jPath\n * @param {string} currentTagName \n */ function isItStopNode(stopNodes, jPath, currentTagName) {\n    const allNodesExp = \"*.\" + currentTagName;\n    for(const stopNodePath in stopNodes){\n        const stopNodeExp = stopNodes[stopNodePath];\n        if (allNodesExp === stopNodeExp || jPath === stopNodeExp) return true;\n    }\n    return false;\n}\n/**\n * Returns the tag Expression and where it is ending handling single-double quotes situation\n * @param {string} xmlData \n * @param {number} i starting index\n * @returns \n */ function tagExpWithClosingIndex(xmlData, i, closingChar = \">\") {\n    let attrBoundary;\n    let tagExp = \"\";\n    for(let index = i; index < xmlData.length; index++){\n        let ch = xmlData[index];\n        if (attrBoundary) {\n            if (ch === attrBoundary) attrBoundary = \"\"; //reset\n        } else if (ch === '\"' || ch === \"'\") {\n            attrBoundary = ch;\n        } else if (ch === closingChar[0]) {\n            if (closingChar[1]) {\n                if (xmlData[index + 1] === closingChar[1]) {\n                    return {\n                        data: tagExp,\n                        index: index\n                    };\n                }\n            } else {\n                return {\n                    data: tagExp,\n                    index: index\n                };\n            }\n        } else if (ch === \"\t\") {\n            ch = \" \";\n        }\n        tagExp += ch;\n    }\n}\nfunction findClosingIndex(xmlData, str, i, errMsg) {\n    const closingIndex = xmlData.indexOf(str, i);\n    if (closingIndex === -1) {\n        throw new Error(errMsg);\n    } else {\n        return closingIndex + str.length - 1;\n    }\n}\nfunction readTagExp(xmlData, i, removeNSPrefix, closingChar = \">\") {\n    const result = tagExpWithClosingIndex(xmlData, i + 1, closingChar);\n    if (!result) return;\n    let tagExp = result.data;\n    const closeIndex = result.index;\n    const separatorIndex = tagExp.search(/\\s/);\n    let tagName = tagExp;\n    let attrExpPresent = true;\n    if (separatorIndex !== -1) {\n        tagName = tagExp.substring(0, separatorIndex);\n        tagExp = tagExp.substring(separatorIndex + 1).trimStart();\n    }\n    const rawTagName = tagName;\n    if (removeNSPrefix) {\n        const colonIndex = tagName.indexOf(\":\");\n        if (colonIndex !== -1) {\n            tagName = tagName.substr(colonIndex + 1);\n            attrExpPresent = tagName !== result.data.substr(colonIndex + 1);\n        }\n    }\n    return {\n        tagName: tagName,\n        tagExp: tagExp,\n        closeIndex: closeIndex,\n        attrExpPresent: attrExpPresent,\n        rawTagName: rawTagName\n    };\n}\n/**\n * find paired tag for a stop node\n * @param {string} xmlData \n * @param {string} tagName \n * @param {number} i \n */ function readStopNodeData(xmlData, tagName, i) {\n    const startIndex = i;\n    // Starting at 1 since we already have an open tag\n    let openTagCount = 1;\n    for(; i < xmlData.length; i++){\n        if (xmlData[i] === \"<\") {\n            if (xmlData[i + 1] === \"/\") {\n                const closeIndex = findClosingIndex(xmlData, \">\", i, `${tagName} is not closed`);\n                let closeTagName = xmlData.substring(i + 2, closeIndex).trim();\n                if (closeTagName === tagName) {\n                    openTagCount--;\n                    if (openTagCount === 0) {\n                        return {\n                            tagContent: xmlData.substring(startIndex, i),\n                            i: closeIndex\n                        };\n                    }\n                }\n                i = closeIndex;\n            } else if (xmlData[i + 1] === \"?\") {\n                const closeIndex = findClosingIndex(xmlData, \"?>\", i + 1, \"StopNode is not closed.\");\n                i = closeIndex;\n            } else if (xmlData.substr(i + 1, 3) === \"!--\") {\n                const closeIndex = findClosingIndex(xmlData, \"-->\", i + 3, \"StopNode is not closed.\");\n                i = closeIndex;\n            } else if (xmlData.substr(i + 1, 2) === \"![\") {\n                const closeIndex = findClosingIndex(xmlData, \"]]>\", i, \"StopNode is not closed.\") - 2;\n                i = closeIndex;\n            } else {\n                const tagData = readTagExp(xmlData, i, \">\");\n                if (tagData) {\n                    const openTagName = tagData && tagData.tagName;\n                    if (openTagName === tagName && tagData.tagExp[tagData.tagExp.length - 1] !== \"/\") {\n                        openTagCount++;\n                    }\n                    i = tagData.closeIndex;\n                }\n            }\n        }\n    } //end for loop\n}\nfunction parseValue(val, shouldParse, options) {\n    if (shouldParse && typeof val === \"string\") {\n        //console.log(options)\n        const newval = val.trim();\n        if (newval === \"true\") return true;\n        else if (newval === \"false\") return false;\n        else return toNumber(val, options);\n    } else {\n        if (util.isExist(val)) {\n            return val;\n        } else {\n            return \"\";\n        }\n    }\n}\nmodule.exports = OrderedObjParser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmFzdC14bWwtcGFyc2VyL3NyYy94bWxwYXJzZXIvT3JkZXJlZE9ialBhcnNlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLFlBQVk7QUFFWixNQUFNQSxPQUFPQyxtQkFBT0EsQ0FBQztBQUNyQixNQUFNQyxVQUFVRCxtQkFBT0EsQ0FBQztBQUN4QixNQUFNRSxjQUFjRixtQkFBT0EsQ0FBQyw0RkFBaUI7QUFDN0MsTUFBTUcsV0FBV0gsbUJBQU9BLENBQUMscURBQVE7QUFFakMsZUFBZTtBQUNmLDRGQUE0RjtBQUM1Rix3Q0FBd0M7QUFFeEMsOEZBQThGO0FBQzlGLG9IQUFvSDtBQUVwSCxNQUFNSTtJQUNKQyxZQUFZQyxPQUFPLENBQUM7UUFDbEIsSUFBSSxDQUFDQSxPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDQyxXQUFXLEdBQUc7UUFDbkIsSUFBSSxDQUFDQyxhQUFhLEdBQUcsRUFBRTtRQUN2QixJQUFJLENBQUNDLGVBQWUsR0FBRyxDQUFDO1FBQ3hCLElBQUksQ0FBQ0MsWUFBWSxHQUFHO1lBQ2xCLFFBQVM7Z0JBQUVDLE9BQU87Z0JBQXNCQyxLQUFNO1lBQUc7WUFDakQsTUFBTztnQkFBRUQsT0FBTztnQkFBb0JDLEtBQU07WUFBRztZQUM3QyxNQUFPO2dCQUFFRCxPQUFPO2dCQUFvQkMsS0FBTTtZQUFHO1lBQzdDLFFBQVM7Z0JBQUVELE9BQU87Z0JBQXNCQyxLQUFNO1lBQUk7UUFDcEQ7UUFDQSxJQUFJLENBQUNDLFNBQVMsR0FBRztZQUFFRixPQUFPO1lBQXFCQyxLQUFNO1FBQUc7UUFDeEQsSUFBSSxDQUFDRSxZQUFZLEdBQUc7WUFDbEIsU0FBUztnQkFBRUgsT0FBTztnQkFBa0JDLEtBQUs7WUFBSTtZQUM3Qyw2Q0FBNkM7WUFDN0MsNkNBQTZDO1lBQzdDLCtDQUErQztZQUMvQyxrREFBa0Q7WUFDbEQsaURBQWlEO1lBQ2pELFFBQVM7Z0JBQUVELE9BQU87Z0JBQWtCQyxLQUFLO1lBQUk7WUFDN0MsU0FB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QUFPO2dCQUM1QyxNQUFNZ0QsYUFBYUMsaUJBQWlCTixTQUFTLE9BQU8zQyxJQUFFLEdBQUc7Z0JBQ3pEQSxJQUFFZ0Q7WUFDSixPQUFPLElBQUdMLFFBQVFVLE1BQU0sQ0FBQ3JELElBQUksR0FBRyxPQUFPLE1BQU07Z0JBQzNDLE1BQU1nRCxhQUFhQyxpQkFBaUJOLFNBQVMsT0FBTzNDLEdBQUcsNkJBQTZCO2dCQUNwRkEsSUFBRWdEO1lBQ0osT0FBTztnQkFDTCxNQUFNYSxVQUFVQyxXQUFXbkIsU0FBUzNDLEdBQUc7Z0JBRXZDLElBQUk2RCxTQUFTO29CQUNYLE1BQU00QyxjQUFjNUMsV0FBV0EsUUFBUXpELE9BQU87b0JBQzlDLElBQUlxRyxnQkFBZ0JyRyxXQUFXeUQsUUFBUU8sTUFBTSxDQUFDUCxRQUFRTyxNQUFNLENBQUNuRSxNQUFNLEdBQUMsRUFBRSxLQUFLLEtBQUs7d0JBQzlFc0c7b0JBQ0Y7b0JBQ0F2RyxJQUFFNkQsUUFBUWIsVUFBVTtnQkFDdEI7WUFDRjtRQUNGO0lBQ0osRUFBQyxjQUFjO0FBQ2pCO0FBRUEsU0FBU2pDLFdBQVdoQyxHQUFHLEVBQUUySCxXQUFXLEVBQUVqSSxPQUFPO0lBQzNDLElBQUlpSSxlQUFlLE9BQU8zSCxRQUFRLFVBQVU7UUFDMUMsc0JBQXNCO1FBQ3RCLE1BQU04QixTQUFTOUIsSUFBSTZCLElBQUk7UUFDdkIsSUFBR0MsV0FBVyxRQUFTLE9BQU87YUFDekIsSUFBR0EsV0FBVyxTQUFVLE9BQU87YUFDL0IsT0FBT3ZDLFNBQVNTLEtBQUtOO0lBQzVCLE9BQU87UUFDTCxJQUFJUCxLQUFLeUksT0FBTyxDQUFDNUgsTUFBTTtZQUNyQixPQUFPQTtRQUNULE9BQU87WUFDTCxPQUFPO1FBQ1Q7SUFDRjtBQUNGO0FBR0E2SCxPQUFPQyxPQUFPLEdBQUd0SSIsInNvdXJjZXMiOlsid2VicGFjazovL3RoZS1ncmlkLTIvLi9ub2RlX21vZHVsZXMvZmFzdC14bWwtcGFyc2VyL3NyYy94bWxwYXJzZXIvT3JkZXJlZE9ialBhcnNlci5qcz8wM2EzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbi8vL0B0cy1jaGVja1xuXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuY29uc3QgeG1sTm9kZSA9IHJlcXVpcmUoJy4veG1sTm9kZScpO1xuY29uc3QgcmVhZERvY1R5cGUgPSByZXF1aXJlKFwiLi9Eb2NUeXBlUmVhZGVyXCIpO1xuY29uc3QgdG9OdW1iZXIgPSByZXF1aXJlKFwic3RybnVtXCIpO1xuXG4vLyBjb25zdCByZWd4ID1cbi8vICAgJzwoKCFcXFxcW0NEQVRBXFxcXFsoW1xcXFxzXFxcXFNdKj8pKF1dPikpfCgoTkFNRTopPyhOQU1FKSkoW14+XSopPnwoKFxcXFwvKShOQU1FKVxcXFxzKj4pKShbXjxdKiknXG4vLyAgIC5yZXBsYWNlKC9OQU1FL2csIHV0aWwubmFtZVJlZ2V4cCk7XG5cbi8vY29uc3QgdGFnc1JlZ3ggPSBuZXcgUmVnRXhwKFwiPChcXFxcLz9bXFxcXHc6XFxcXC1cXC5fXSspKFtePl0qKT4oXFxcXHMqXCIrY2RhdGFSZWd4K1wiKSooW148XSspP1wiLFwiZ1wiKTtcbi8vY29uc3QgdGFnc1JlZ3ggPSBuZXcgUmVnRXhwKFwiPChcXFxcLz8pKChcXFxcdyo6KT8oW1xcXFx3OlxcXFwtXFwuX10rKSkoW14+XSopPihbXjxdKikoXCIrY2RhdGFSZWd4K1wiKFtePF0qKSkqKFtePF0rKT9cIixcImdcIik7XG5cbmNsYXNzIE9yZGVyZWRPYmpQYXJzZXJ7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpe1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5jdXJyZW50Tm9kZSA9IG51bGw7XG4gICAgdGhpcy50YWdzTm9kZVN0YWNrID0gW107XG4gICAgdGhpcy5kb2NUeXBlRW50aXRpZXMgPSB7fTtcbiAgICB0aGlzLmxhc3RFbnRpdGllcyA9IHtcbiAgICAgIFwiYXBvc1wiIDogeyByZWdleDogLyYoYXBvc3wjMzl8I3gyNyk7L2csIHZhbCA6IFwiJ1wifSxcbiAgICAgIFwiZ3RcIiA6IHsgcmVnZXg6IC8mKGd0fCM2MnwjeDNFKTsvZywgdmFsIDogXCI+XCJ9LFxuICAgICAgXCJsdFwiIDogeyByZWdleDogLyYobHR8IzYwfCN4M0MpOy9nLCB2YWwgOiBcIjxcIn0sXG4gICAgICBcInF1b3RcIiA6IHsgcmVnZXg6IC8mKHF1b3R8IzM0fCN4MjIpOy9nLCB2YWwgOiBcIlxcXCJcIn0sXG4gICAgfTtcbiAgICB0aGlzLmFtcEVudGl0eSA9IHsgcmVnZXg6IC8mKGFtcHwjMzh8I3gyNik7L2csIHZhbCA6IFwiJlwifTtcbiAgICB0aGlzLmh0bWxFbnRpdGllcyA9IHtcbiAgICAgIFwic3BhY2VcIjogeyByZWdleDogLyYobmJzcHwjMTYwKTsvZywgdmFsOiBcIiBcIiB9LFxuICAgICAgLy8gXCJsdFwiIDogeyByZWdleDogLyYobHR8IzYwKTsvZywgdmFsOiBcIjxcIiB9LFxuICAgICAgLy8gXCJndFwiIDogeyByZWdleDogLyYoZ3R8IzYyKTsvZywgdmFsOiBcIj5cIiB9LFxuICAgICAgLy8gXCJhbXBcIiA6IHsgcmVnZXg6IC8mKGFtcHwjMzgpOy9nLCB2YWw6IFwiJlwiIH0sXG4gICAgICAvLyBcInF1b3RcIiA6IHsgcmVnZXg6IC8mKHF1b3R8IzM0KTsvZywgdmFsOiBcIlxcXCJcIiB9LFxuICAgICAgLy8gXCJhcG9zXCIgOiB7IHJlZ2V4OiAvJihhcG9zfCMzOSk7L2csIHZhbDogXCInXCIgfSxcbiAgICAgIFwiY2VudFwiIDogeyByZWdleDogLyYoY2VudHwjMTYyKTsvZywgdmFsOiBcIsKiXCIgfSxcbiAgICAgIFwicG91bmRcIiA6IHsgcmVnZXg6IC8mKHBvdW5kfCMxNjMpOy9nLCB2YWw6IFwiwqNcIiB9LFxuICAgICAgXCJ5ZW5cIiA6IHsgcmVnZXg6IC8mKHllbnwjMTY1KTsvZywgdmFsOiBcIsKlXCIgfSxcbiAgICAgIFwiZXVyb1wiIDogeyByZWdleDogLyYoZXVyb3wjODM2NCk7L2csIHZhbDogXCLigqxcIiB9LFxuICAgICAgXCJjb3B5cmlnaHRcIiA6IHsgcmVnZXg6IC8mKGNvcHl8IzE2OSk7L2csIHZhbDogXCLCqVwiIH0sXG4gICAgICBcInJlZ1wiIDogeyByZWdleDogLyYocmVnfCMxNzQpOy9nLCB2YWw6IFwiwq5cIiB9LFxuICAgICAgXCJpbnJcIiA6IHsgcmVnZXg6IC8mKGlucnwjODM3Nyk7L2csIHZhbDogXCLigrlcIiB9LFxuICAgIH07XG4gICAgdGhpcy5hZGRFeHRlcm5hbEVudGl0aWVzID0gYWRkRXh0ZXJuYWxFbnRpdGllcztcbiAgICB0aGlzLnBhcnNlWG1sID0gcGFyc2VYbWw7XG4gICAgdGhpcy5wYXJzZVRleHREYXRhID0gcGFyc2VUZXh0RGF0YTtcbiAgICB0aGlzLnJlc29sdmVOYW1lU3BhY2UgPSByZXNvbHZlTmFtZVNwYWNlO1xuICAgIHRoaXMuYnVpbGRBdHRyaWJ1dGVzTWFwID0gYnVpbGRBdHRyaWJ1dGVzTWFwO1xuICAgIHRoaXMuaXNJdFN0b3BOb2RlID0gaXNJdFN0b3BOb2RlO1xuICAgIHRoaXMucmVwbGFjZUVudGl0aWVzVmFsdWUgPSByZXBsYWNlRW50aXRpZXNWYWx1ZTtcbiAgICB0aGlzLnJlYWRTdG9wTm9kZURhdGEgPSByZWFkU3RvcE5vZGVEYXRhO1xuICAgIHRoaXMuc2F2ZVRleHRUb1BhcmVudFRhZyA9IHNhdmVUZXh0VG9QYXJlbnRUYWc7XG4gICAgdGhpcy5hZGRDaGlsZCA9IGFkZENoaWxkO1xuICB9XG5cbn1cblxuZnVuY3Rpb24gYWRkRXh0ZXJuYWxFbnRpdGllcyhleHRlcm5hbEVudGl0aWVzKXtcbiAgY29uc3QgZW50S2V5cyA9IE9iamVjdC5rZXlzKGV4dGVybmFsRW50aXRpZXMpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGVudEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBlbnQgPSBlbnRLZXlzW2ldO1xuICAgIHRoaXMubGFzdEVudGl0aWVzW2VudF0gPSB7XG4gICAgICAgcmVnZXg6IG5ldyBSZWdFeHAoXCImXCIrZW50K1wiO1wiLFwiZ1wiKSxcbiAgICAgICB2YWwgOiBleHRlcm5hbEVudGl0aWVzW2VudF1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnTmFtZVxuICogQHBhcmFtIHtzdHJpbmd9IGpQYXRoXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGRvbnRUcmltXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGhhc0F0dHJpYnV0ZXNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNMZWFmTm9kZVxuICogQHBhcmFtIHtib29sZWFufSBlc2NhcGVFbnRpdGllc1xuICovXG5mdW5jdGlvbiBwYXJzZVRleHREYXRhKHZhbCwgdGFnTmFtZSwgalBhdGgsIGRvbnRUcmltLCBoYXNBdHRyaWJ1dGVzLCBpc0xlYWZOb2RlLCBlc2NhcGVFbnRpdGllcykge1xuICBpZiAodmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnRyaW1WYWx1ZXMgJiYgIWRvbnRUcmltKSB7XG4gICAgICB2YWwgPSB2YWwudHJpbSgpO1xuICAgIH1cbiAgICBpZih2YWwubGVuZ3RoID4gMCl7XG4gICAgICBpZighZXNjYXBlRW50aXRpZXMpIHZhbCA9IHRoaXMucmVwbGFjZUVudGl0aWVzVmFsdWUodmFsKTtcbiAgICAgIFxuICAgICAgY29uc3QgbmV3dmFsID0gdGhpcy5vcHRpb25zLnRhZ1ZhbHVlUHJvY2Vzc29yKHRhZ05hbWUsIHZhbCwgalBhdGgsIGhhc0F0dHJpYnV0ZXMsIGlzTGVhZk5vZGUpO1xuICAgICAgaWYobmV3dmFsID09PSBudWxsIHx8IG5ld3ZhbCA9PT0gdW5kZWZpbmVkKXtcbiAgICAgICAgLy9kb24ndCBwYXJzZVxuICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgfWVsc2UgaWYodHlwZW9mIG5ld3ZhbCAhPT0gdHlwZW9mIHZhbCB8fCBuZXd2YWwgIT09IHZhbCl7XG4gICAgICAgIC8vb3ZlcndyaXRlXG4gICAgICAgIHJldHVybiBuZXd2YWw7XG4gICAgICB9ZWxzZSBpZih0aGlzLm9wdGlvbnMudHJpbVZhbHVlcyl7XG4gICAgICAgIHJldHVybiBwYXJzZVZhbHVlKHZhbCwgdGhpcy5vcHRpb25zLnBhcnNlVGFnVmFsdWUsIHRoaXMub3B0aW9ucy5udW1iZXJQYXJzZU9wdGlvbnMpO1xuICAgICAgfWVsc2V7XG4gICAgICAgIGNvbnN0IHRyaW1tZWRWYWwgPSB2YWwudHJpbSgpO1xuICAgICAgICBpZih0cmltbWVkVmFsID09PSB2YWwpe1xuICAgICAgICAgIHJldHVybiBwYXJzZVZhbHVlKHZhbCwgdGhpcy5vcHRpb25zLnBhcnNlVGFnVmFsdWUsIHRoaXMub3B0aW9ucy5udW1iZXJQYXJzZU9wdGlvbnMpO1xuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVOYW1lU3BhY2UodGFnbmFtZSkge1xuICBpZiAodGhpcy5vcHRpb25zLnJlbW92ZU5TUHJlZml4KSB7XG4gICAgY29uc3QgdGFncyA9IHRhZ25hbWUuc3BsaXQoJzonKTtcbiAgICBjb25zdCBwcmVmaXggPSB0YWduYW1lLmNoYXJBdCgwKSA9PT0gJy8nID8gJy8nIDogJyc7XG4gICAgaWYgKHRhZ3NbMF0gPT09ICd4bWxucycpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgaWYgKHRhZ3MubGVuZ3RoID09PSAyKSB7XG4gICAgICB0YWduYW1lID0gcHJlZml4ICsgdGFnc1sxXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhZ25hbWU7XG59XG5cbi8vVE9ETzogY2hhbmdlIHJlZ2V4IHRvIGNhcHR1cmUgTlNcbi8vY29uc3QgYXR0cnNSZWd4ID0gbmV3IFJlZ0V4cChcIihbXFxcXHdcXFxcLVxcXFwuXFxcXDpdKylcXFxccyo9XFxcXHMqKFsnXFxcIl0pKCgufFxcbikqPylcXFxcMlwiLFwiZ21cIik7XG5jb25zdCBhdHRyc1JlZ3ggPSBuZXcgUmVnRXhwKCcoW15cXFxccz1dKylcXFxccyooPVxcXFxzKihbXFwnXCJdKShbXFxcXHNcXFxcU10qPylcXFxcMyk/JywgJ2dtJyk7XG5cbmZ1bmN0aW9uIGJ1aWxkQXR0cmlidXRlc01hcChhdHRyU3RyLCBqUGF0aCwgdGFnTmFtZSkge1xuICBpZiAoIXRoaXMub3B0aW9ucy5pZ25vcmVBdHRyaWJ1dGVzICYmIHR5cGVvZiBhdHRyU3RyID09PSAnc3RyaW5nJykge1xuICAgIC8vIGF0dHJTdHIgPSBhdHRyU3RyLnJlcGxhY2UoL1xccj9cXG4vZywgJyAnKTtcbiAgICAvL2F0dHJTdHIgPSBhdHRyU3RyIHx8IGF0dHJTdHIudHJpbSgpO1xuXG4gICAgY29uc3QgbWF0Y2hlcyA9IHV0aWwuZ2V0QWxsTWF0Y2hlcyhhdHRyU3RyLCBhdHRyc1JlZ3gpO1xuICAgIGNvbnN0IGxlbiA9IG1hdGNoZXMubGVuZ3RoOyAvL2Rvbid0IG1ha2UgaXQgaW5saW5lXG4gICAgY29uc3QgYXR0cnMgPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjb25zdCBhdHRyTmFtZSA9IHRoaXMucmVzb2x2ZU5hbWVTcGFjZShtYXRjaGVzW2ldWzFdKTtcbiAgICAgIGxldCBvbGRWYWwgPSBtYXRjaGVzW2ldWzRdO1xuICAgICAgbGV0IGFOYW1lID0gdGhpcy5vcHRpb25zLmF0dHJpYnV0ZU5hbWVQcmVmaXggKyBhdHRyTmFtZTtcbiAgICAgIGlmIChhdHRyTmFtZS5sZW5ndGgpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50cmFuc2Zvcm1BdHRyaWJ1dGVOYW1lKSB7XG4gICAgICAgICAgYU5hbWUgPSB0aGlzLm9wdGlvbnMudHJhbnNmb3JtQXR0cmlidXRlTmFtZShhTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYoYU5hbWUgPT09IFwiX19wcm90b19fXCIpIGFOYW1lICA9IFwiI19fcHJvdG9fX1wiO1xuICAgICAgICBpZiAob2xkVmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnRyaW1WYWx1ZXMpIHtcbiAgICAgICAgICAgIG9sZFZhbCA9IG9sZFZhbC50cmltKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9sZFZhbCA9IHRoaXMucmVwbGFjZUVudGl0aWVzVmFsdWUob2xkVmFsKTtcbiAgICAgICAgICBjb25zdCBuZXdWYWwgPSB0aGlzLm9wdGlvbnMuYXR0cmlidXRlVmFsdWVQcm9jZXNzb3IoYXR0ck5hbWUsIG9sZFZhbCwgalBhdGgpO1xuICAgICAgICAgIGlmKG5ld1ZhbCA9PT0gbnVsbCB8fCBuZXdWYWwgPT09IHVuZGVmaW5lZCl7XG4gICAgICAgICAgICAvL2Rvbid0IHBhcnNlXG4gICAgICAgICAgICBhdHRyc1thTmFtZV0gPSBvbGRWYWw7XG4gICAgICAgICAgfWVsc2UgaWYodHlwZW9mIG5ld1ZhbCAhPT0gdHlwZW9mIG9sZFZhbCB8fCBuZXdWYWwgIT09IG9sZFZhbCl7XG4gICAgICAgICAgICAvL292ZXJ3cml0ZVxuICAgICAgICAgICAgYXR0cnNbYU5hbWVdID0gbmV3VmFsO1xuICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgLy9wYXJzZVxuICAgICAgICAgICAgYXR0cnNbYU5hbWVdID0gcGFyc2VWYWx1ZShcbiAgICAgICAgICAgICAgb2xkVmFsLFxuICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMucGFyc2VBdHRyaWJ1dGVWYWx1ZSxcbiAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLm51bWJlclBhcnNlT3B0aW9uc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLmFsbG93Qm9vbGVhbkF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICBhdHRyc1thTmFtZV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghT2JqZWN0LmtleXMoYXR0cnMpLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmF0dHJpYnV0ZXNHcm91cE5hbWUpIHtcbiAgICAgIGNvbnN0IGF0dHJDb2xsZWN0aW9uID0ge307XG4gICAgICBhdHRyQ29sbGVjdGlvblt0aGlzLm9wdGlvbnMuYXR0cmlidXRlc0dyb3VwTmFtZV0gPSBhdHRycztcbiAgICAgIHJldHVybiBhdHRyQ29sbGVjdGlvbjtcbiAgICB9XG4gICAgcmV0dXJuIGF0dHJzXG4gIH1cbn1cblxuY29uc3QgcGFyc2VYbWwgPSBmdW5jdGlvbih4bWxEYXRhKSB7XG4gIHhtbERhdGEgPSB4bWxEYXRhLnJlcGxhY2UoL1xcclxcbj8vZywgXCJcXG5cIik7IC8vVE9ETzogcmVtb3ZlIHRoaXMgbGluZVxuICBjb25zdCB4bWxPYmogPSBuZXcgeG1sTm9kZSgnIXhtbCcpO1xuICBsZXQgY3VycmVudE5vZGUgPSB4bWxPYmo7XG4gIGxldCB0ZXh0RGF0YSA9IFwiXCI7XG4gIGxldCBqUGF0aCA9IFwiXCI7XG4gIGZvcihsZXQgaT0wOyBpPCB4bWxEYXRhLmxlbmd0aDsgaSsrKXsvL2ZvciBlYWNoIGNoYXIgaW4gWE1MIGRhdGFcbiAgICBjb25zdCBjaCA9IHhtbERhdGFbaV07XG4gICAgaWYoY2ggPT09ICc8Jyl7XG4gICAgICAvLyBjb25zdCBuZXh0SW5kZXggPSBpKzE7XG4gICAgICAvLyBjb25zdCBfMm5kQ2hhciA9IHhtbERhdGFbbmV4dEluZGV4XTtcbiAgICAgIGlmKCB4bWxEYXRhW2krMV0gPT09ICcvJykgey8vQ2xvc2luZyBUYWdcbiAgICAgICAgY29uc3QgY2xvc2VJbmRleCA9IGZpbmRDbG9zaW5nSW5kZXgoeG1sRGF0YSwgXCI+XCIsIGksIFwiQ2xvc2luZyBUYWcgaXMgbm90IGNsb3NlZC5cIilcbiAgICAgICAgbGV0IHRhZ05hbWUgPSB4bWxEYXRhLnN1YnN0cmluZyhpKzIsY2xvc2VJbmRleCkudHJpbSgpO1xuXG4gICAgICAgIGlmKHRoaXMub3B0aW9ucy5yZW1vdmVOU1ByZWZpeCl7XG4gICAgICAgICAgY29uc3QgY29sb25JbmRleCA9IHRhZ05hbWUuaW5kZXhPZihcIjpcIik7XG4gICAgICAgICAgaWYoY29sb25JbmRleCAhPT0gLTEpe1xuICAgICAgICAgICAgdGFnTmFtZSA9IHRhZ05hbWUuc3Vic3RyKGNvbG9uSW5kZXgrMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYodGhpcy5vcHRpb25zLnRyYW5zZm9ybVRhZ05hbWUpIHtcbiAgICAgICAgICB0YWdOYW1lID0gdGhpcy5vcHRpb25zLnRyYW5zZm9ybVRhZ05hbWUodGFnTmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZihjdXJyZW50Tm9kZSl7XG4gICAgICAgICAgdGV4dERhdGEgPSB0aGlzLnNhdmVUZXh0VG9QYXJlbnRUYWcodGV4dERhdGEsIGN1cnJlbnROb2RlLCBqUGF0aCk7XG4gICAgICAgIH1cblxuICAgICAgICAvL2NoZWNrIGlmIGxhc3QgdGFnIG9mIG5lc3RlZCB0YWcgd2FzIHVucGFpcmVkIHRhZ1xuICAgICAgICBjb25zdCBsYXN0VGFnTmFtZSA9IGpQYXRoLnN1YnN0cmluZyhqUGF0aC5sYXN0SW5kZXhPZihcIi5cIikrMSk7XG4gICAgICAgIGlmKHRhZ05hbWUgJiYgdGhpcy5vcHRpb25zLnVucGFpcmVkVGFncy5pbmRleE9mKHRhZ05hbWUpICE9PSAtMSApe1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5wYWlyZWQgdGFnIGNhbiBub3QgYmUgdXNlZCBhcyBjbG9zaW5nIHRhZzogPC8ke3RhZ05hbWV9PmApO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwcm9wSW5kZXggPSAwXG4gICAgICAgIGlmKGxhc3RUYWdOYW1lICYmIHRoaXMub3B0aW9ucy51bnBhaXJlZFRhZ3MuaW5kZXhPZihsYXN0VGFnTmFtZSkgIT09IC0xICl7XG4gICAgICAgICAgcHJvcEluZGV4ID0galBhdGgubGFzdEluZGV4T2YoJy4nLCBqUGF0aC5sYXN0SW5kZXhPZignLicpLTEpXG4gICAgICAgICAgdGhpcy50YWdzTm9kZVN0YWNrLnBvcCgpO1xuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICBwcm9wSW5kZXggPSBqUGF0aC5sYXN0SW5kZXhPZihcIi5cIik7XG4gICAgICAgIH1cbiAgICAgICAgalBhdGggPSBqUGF0aC5zdWJzdHJpbmcoMCwgcHJvcEluZGV4KTtcblxuICAgICAgICBjdXJyZW50Tm9kZSA9IHRoaXMudGFnc05vZGVTdGFjay5wb3AoKTsvL2F2b2lkIHJlY3Vyc2lvbiwgc2V0IHRoZSBwYXJlbnQgdGFnIHNjb3BlXG4gICAgICAgIHRleHREYXRhID0gXCJcIjtcbiAgICAgICAgaSA9IGNsb3NlSW5kZXg7XG4gICAgICB9IGVsc2UgaWYoIHhtbERhdGFbaSsxXSA9PT0gJz8nKSB7XG5cbiAgICAgICAgbGV0IHRhZ0RhdGEgPSByZWFkVGFnRXhwKHhtbERhdGEsaSwgZmFsc2UsIFwiPz5cIik7XG4gICAgICAgIGlmKCF0YWdEYXRhKSB0aHJvdyBuZXcgRXJyb3IoXCJQaSBUYWcgaXMgbm90IGNsb3NlZC5cIik7XG5cbiAgICAgICAgdGV4dERhdGEgPSB0aGlzLnNhdmVUZXh0VG9QYXJlbnRUYWcodGV4dERhdGEsIGN1cnJlbnROb2RlLCBqUGF0aCk7XG4gICAgICAgIGlmKCAodGhpcy5vcHRpb25zLmlnbm9yZURlY2xhcmF0aW9uICYmIHRhZ0RhdGEudGFnTmFtZSA9PT0gXCI/eG1sXCIpIHx8IHRoaXMub3B0aW9ucy5pZ25vcmVQaVRhZ3Mpe1xuXG4gICAgICAgIH1lbHNle1xuICBcbiAgICAgICAgICBjb25zdCBjaGlsZE5vZGUgPSBuZXcgeG1sTm9kZSh0YWdEYXRhLnRhZ05hbWUpO1xuICAgICAgICAgIGNoaWxkTm9kZS5hZGQodGhpcy5vcHRpb25zLnRleHROb2RlTmFtZSwgXCJcIik7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYodGFnRGF0YS50YWdOYW1lICE9PSB0YWdEYXRhLnRhZ0V4cCAmJiB0YWdEYXRhLmF0dHJFeHBQcmVzZW50KXtcbiAgICAgICAgICAgIGNoaWxkTm9kZVtcIjpAXCJdID0gdGhpcy5idWlsZEF0dHJpYnV0ZXNNYXAodGFnRGF0YS50YWdFeHAsIGpQYXRoLCB0YWdEYXRhLnRhZ05hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmFkZENoaWxkKGN1cnJlbnROb2RlLCBjaGlsZE5vZGUsIGpQYXRoKVxuXG4gICAgICAgIH1cblxuXG4gICAgICAgIGkgPSB0YWdEYXRhLmNsb3NlSW5kZXggKyAxO1xuICAgICAgfSBlbHNlIGlmKHhtbERhdGEuc3Vic3RyKGkgKyAxLCAzKSA9PT0gJyEtLScpIHtcbiAgICAgICAgY29uc3QgZW5kSW5kZXggPSBmaW5kQ2xvc2luZ0luZGV4KHhtbERhdGEsIFwiLS0+XCIsIGkrNCwgXCJDb21tZW50IGlzIG5vdCBjbG9zZWQuXCIpXG4gICAgICAgIGlmKHRoaXMub3B0aW9ucy5jb21tZW50UHJvcE5hbWUpe1xuICAgICAgICAgIGNvbnN0IGNvbW1lbnQgPSB4bWxEYXRhLnN1YnN0cmluZyhpICsgNCwgZW5kSW5kZXggLSAyKTtcblxuICAgICAgICAgIHRleHREYXRhID0gdGhpcy5zYXZlVGV4dFRvUGFyZW50VGFnKHRleHREYXRhLCBjdXJyZW50Tm9kZSwgalBhdGgpO1xuXG4gICAgICAgICAgY3VycmVudE5vZGUuYWRkKHRoaXMub3B0aW9ucy5jb21tZW50UHJvcE5hbWUsIFsgeyBbdGhpcy5vcHRpb25zLnRleHROb2RlTmFtZV0gOiBjb21tZW50IH0gXSk7XG4gICAgICAgIH1cbiAgICAgICAgaSA9IGVuZEluZGV4O1xuICAgICAgfSBlbHNlIGlmKCB4bWxEYXRhLnN1YnN0cihpICsgMSwgMikgPT09ICchRCcpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gcmVhZERvY1R5cGUoeG1sRGF0YSwgaSk7XG4gICAgICAgIHRoaXMuZG9jVHlwZUVudGl0aWVzID0gcmVzdWx0LmVudGl0aWVzO1xuICAgICAgICBpID0gcmVzdWx0Lmk7XG4gICAgICB9ZWxzZSBpZih4bWxEYXRhLnN1YnN0cihpICsgMSwgMikgPT09ICchWycpIHtcbiAgICAgICAgY29uc3QgY2xvc2VJbmRleCA9IGZpbmRDbG9zaW5nSW5kZXgoeG1sRGF0YSwgXCJdXT5cIiwgaSwgXCJDREFUQSBpcyBub3QgY2xvc2VkLlwiKSAtIDI7XG4gICAgICAgIGNvbnN0IHRhZ0V4cCA9IHhtbERhdGEuc3Vic3RyaW5nKGkgKyA5LGNsb3NlSW5kZXgpO1xuXG4gICAgICAgIHRleHREYXRhID0gdGhpcy5zYXZlVGV4dFRvUGFyZW50VGFnKHRleHREYXRhLCBjdXJyZW50Tm9kZSwgalBhdGgpO1xuXG4gICAgICAgIGxldCB2YWwgPSB0aGlzLnBhcnNlVGV4dERhdGEodGFnRXhwLCBjdXJyZW50Tm9kZS50YWduYW1lLCBqUGF0aCwgdHJ1ZSwgZmFsc2UsIHRydWUsIHRydWUpO1xuICAgICAgICBpZih2YWwgPT0gdW5kZWZpbmVkKSB2YWwgPSBcIlwiO1xuXG4gICAgICAgIC8vY2RhdGEgc2hvdWxkIGJlIHNldCBldmVuIGlmIGl0IGlzIDAgbGVuZ3RoIHN0cmluZ1xuICAgICAgICBpZih0aGlzLm9wdGlvbnMuY2RhdGFQcm9wTmFtZSl7XG4gICAgICAgICAgY3VycmVudE5vZGUuYWRkKHRoaXMub3B0aW9ucy5jZGF0YVByb3BOYW1lLCBbIHsgW3RoaXMub3B0aW9ucy50ZXh0Tm9kZU5hbWVdIDogdGFnRXhwIH0gXSk7XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgIGN1cnJlbnROb2RlLmFkZCh0aGlzLm9wdGlvbnMudGV4dE5vZGVOYW1lLCB2YWwpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpID0gY2xvc2VJbmRleCArIDI7XG4gICAgICB9ZWxzZSB7Ly9PcGVuaW5nIHRhZ1xuICAgICAgICBsZXQgcmVzdWx0ID0gcmVhZFRhZ0V4cCh4bWxEYXRhLGksIHRoaXMub3B0aW9ucy5yZW1vdmVOU1ByZWZpeCk7XG4gICAgICAgIGxldCB0YWdOYW1lPSByZXN1bHQudGFnTmFtZTtcbiAgICAgICAgY29uc3QgcmF3VGFnTmFtZSA9IHJlc3VsdC5yYXdUYWdOYW1lO1xuICAgICAgICBsZXQgdGFnRXhwID0gcmVzdWx0LnRhZ0V4cDtcbiAgICAgICAgbGV0IGF0dHJFeHBQcmVzZW50ID0gcmVzdWx0LmF0dHJFeHBQcmVzZW50O1xuICAgICAgICBsZXQgY2xvc2VJbmRleCA9IHJlc3VsdC5jbG9zZUluZGV4O1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMudHJhbnNmb3JtVGFnTmFtZSkge1xuICAgICAgICAgIHRhZ05hbWUgPSB0aGlzLm9wdGlvbnMudHJhbnNmb3JtVGFnTmFtZSh0YWdOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy9zYXZlIHRleHQgYXMgY2hpbGQgbm9kZVxuICAgICAgICBpZiAoY3VycmVudE5vZGUgJiYgdGV4dERhdGEpIHtcbiAgICAgICAgICBpZihjdXJyZW50Tm9kZS50YWduYW1lICE9PSAnIXhtbCcpe1xuICAgICAgICAgICAgLy93aGVuIG5lc3RlZCB0YWcgaXMgZm91bmRcbiAgICAgICAgICAgIHRleHREYXRhID0gdGhpcy5zYXZlVGV4dFRvUGFyZW50VGFnKHRleHREYXRhLCBjdXJyZW50Tm9kZSwgalBhdGgsIGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvL2NoZWNrIGlmIGxhc3QgdGFnIHdhcyB1bnBhaXJlZCB0YWdcbiAgICAgICAgY29uc3QgbGFzdFRhZyA9IGN1cnJlbnROb2RlO1xuICAgICAgICBpZihsYXN0VGFnICYmIHRoaXMub3B0aW9ucy51bnBhaXJlZFRhZ3MuaW5kZXhPZihsYXN0VGFnLnRhZ25hbWUpICE9PSAtMSApe1xuICAgICAgICAgIGN1cnJlbnROb2RlID0gdGhpcy50YWdzTm9kZVN0YWNrLnBvcCgpO1xuICAgICAgICAgIGpQYXRoID0galBhdGguc3Vic3RyaW5nKDAsIGpQYXRoLmxhc3RJbmRleE9mKFwiLlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYodGFnTmFtZSAhPT0geG1sT2JqLnRhZ25hbWUpe1xuICAgICAgICAgIGpQYXRoICs9IGpQYXRoID8gXCIuXCIgKyB0YWdOYW1lIDogdGFnTmFtZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc0l0U3RvcE5vZGUodGhpcy5vcHRpb25zLnN0b3BOb2RlcywgalBhdGgsIHRhZ05hbWUpKSB7XG4gICAgICAgICAgbGV0IHRhZ0NvbnRlbnQgPSBcIlwiO1xuICAgICAgICAgIC8vc2VsZi1jbG9zaW5nIHRhZ1xuICAgICAgICAgIGlmKHRhZ0V4cC5sZW5ndGggPiAwICYmIHRhZ0V4cC5sYXN0SW5kZXhPZihcIi9cIikgPT09IHRhZ0V4cC5sZW5ndGggLSAxKXtcbiAgICAgICAgICAgIGkgPSByZXN1bHQuY2xvc2VJbmRleDtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy91bnBhaXJlZCB0YWdcbiAgICAgICAgICBlbHNlIGlmKHRoaXMub3B0aW9ucy51bnBhaXJlZFRhZ3MuaW5kZXhPZih0YWdOYW1lKSAhPT0gLTEpe1xuICAgICAgICAgICAgaSA9IHJlc3VsdC5jbG9zZUluZGV4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvL25vcm1hbCB0YWdcbiAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgLy9yZWFkIHVudGlsIGNsb3NpbmcgdGFnIGlzIGZvdW5kXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnJlYWRTdG9wTm9kZURhdGEoeG1sRGF0YSwgcmF3VGFnTmFtZSwgY2xvc2VJbmRleCArIDEpO1xuICAgICAgICAgICAgaWYoIXJlc3VsdCkgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIGVuZCBvZiAke3Jhd1RhZ05hbWV9YCk7XG4gICAgICAgICAgICBpID0gcmVzdWx0Lmk7XG4gICAgICAgICAgICB0YWdDb250ZW50ID0gcmVzdWx0LnRhZ0NvbnRlbnQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgY2hpbGROb2RlID0gbmV3IHhtbE5vZGUodGFnTmFtZSk7XG4gICAgICAgICAgaWYodGFnTmFtZSAhPT0gdGFnRXhwICYmIGF0dHJFeHBQcmVzZW50KXtcbiAgICAgICAgICAgIGNoaWxkTm9kZVtcIjpAXCJdID0gdGhpcy5idWlsZEF0dHJpYnV0ZXNNYXAodGFnRXhwLCBqUGF0aCwgdGFnTmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKHRhZ0NvbnRlbnQpIHtcbiAgICAgICAgICAgIHRhZ0NvbnRlbnQgPSB0aGlzLnBhcnNlVGV4dERhdGEodGFnQ29udGVudCwgdGFnTmFtZSwgalBhdGgsIHRydWUsIGF0dHJFeHBQcmVzZW50LCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgalBhdGggPSBqUGF0aC5zdWJzdHIoMCwgalBhdGgubGFzdEluZGV4T2YoXCIuXCIpKTtcbiAgICAgICAgICBjaGlsZE5vZGUuYWRkKHRoaXMub3B0aW9ucy50ZXh0Tm9kZU5hbWUsIHRhZ0NvbnRlbnQpO1xuICAgICAgICAgIFxuICAgICAgICAgIHRoaXMuYWRkQ2hpbGQoY3VycmVudE5vZGUsIGNoaWxkTm9kZSwgalBhdGgpXG4gICAgICAgIH1lbHNle1xuICAvL3NlbGZDbG9zaW5nIHRhZ1xuICAgICAgICAgIGlmKHRhZ0V4cC5sZW5ndGggPiAwICYmIHRhZ0V4cC5sYXN0SW5kZXhPZihcIi9cIikgPT09IHRhZ0V4cC5sZW5ndGggLSAxKXtcbiAgICAgICAgICAgIGlmKHRhZ05hbWVbdGFnTmFtZS5sZW5ndGggLSAxXSA9PT0gXCIvXCIpeyAvL3JlbW92ZSB0cmFpbGluZyAnLydcbiAgICAgICAgICAgICAgdGFnTmFtZSA9IHRhZ05hbWUuc3Vic3RyKDAsIHRhZ05hbWUubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgIGpQYXRoID0galBhdGguc3Vic3RyKDAsIGpQYXRoLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICB0YWdFeHAgPSB0YWdOYW1lO1xuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgIHRhZ0V4cCA9IHRhZ0V4cC5zdWJzdHIoMCwgdGFnRXhwLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZih0aGlzLm9wdGlvbnMudHJhbnNmb3JtVGFnTmFtZSkge1xuICAgICAgICAgICAgICB0YWdOYW1lID0gdGhpcy5vcHRpb25zLnRyYW5zZm9ybVRhZ05hbWUodGFnTmFtZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGNoaWxkTm9kZSA9IG5ldyB4bWxOb2RlKHRhZ05hbWUpO1xuICAgICAgICAgICAgaWYodGFnTmFtZSAhPT0gdGFnRXhwICYmIGF0dHJFeHBQcmVzZW50KXtcbiAgICAgICAgICAgICAgY2hpbGROb2RlW1wiOkBcIl0gPSB0aGlzLmJ1aWxkQXR0cmlidXRlc01hcCh0YWdFeHAsIGpQYXRoLCB0YWdOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYWRkQ2hpbGQoY3VycmVudE5vZGUsIGNoaWxkTm9kZSwgalBhdGgpXG4gICAgICAgICAgICBqUGF0aCA9IGpQYXRoLnN1YnN0cigwLCBqUGF0aC5sYXN0SW5kZXhPZihcIi5cIikpO1xuICAgICAgICAgIH1cbiAgICAvL29wZW5pbmcgdGFnXG4gICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkTm9kZSA9IG5ldyB4bWxOb2RlKCB0YWdOYW1lKTtcbiAgICAgICAgICAgIHRoaXMudGFnc05vZGVTdGFjay5wdXNoKGN1cnJlbnROb2RlKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYodGFnTmFtZSAhPT0gdGFnRXhwICYmIGF0dHJFeHBQcmVzZW50KXtcbiAgICAgICAgICAgICAgY2hpbGROb2RlW1wiOkBcIl0gPSB0aGlzLmJ1aWxkQXR0cmlidXRlc01hcCh0YWdFeHAsIGpQYXRoLCB0YWdOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYWRkQ2hpbGQoY3VycmVudE5vZGUsIGNoaWxkTm9kZSwgalBhdGgpXG4gICAgICAgICAgICBjdXJyZW50Tm9kZSA9IGNoaWxkTm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGV4dERhdGEgPSBcIlwiO1xuICAgICAgICAgIGkgPSBjbG9zZUluZGV4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfWVsc2V7XG4gICAgICB0ZXh0RGF0YSArPSB4bWxEYXRhW2ldO1xuICAgIH1cbiAgfVxuICByZXR1cm4geG1sT2JqLmNoaWxkO1xufVxuXG5mdW5jdGlvbiBhZGRDaGlsZChjdXJyZW50Tm9kZSwgY2hpbGROb2RlLCBqUGF0aCl7XG4gIGNvbnN0IHJlc3VsdCA9IHRoaXMub3B0aW9ucy51cGRhdGVUYWcoY2hpbGROb2RlLnRhZ25hbWUsIGpQYXRoLCBjaGlsZE5vZGVbXCI6QFwiXSlcbiAgaWYocmVzdWx0ID09PSBmYWxzZSl7XG4gIH1lbHNlIGlmKHR5cGVvZiByZXN1bHQgPT09IFwic3RyaW5nXCIpe1xuICAgIGNoaWxkTm9kZS50YWduYW1lID0gcmVzdWx0XG4gICAgY3VycmVudE5vZGUuYWRkQ2hpbGQoY2hpbGROb2RlKTtcbiAgfWVsc2V7XG4gICAgY3VycmVudE5vZGUuYWRkQ2hpbGQoY2hpbGROb2RlKTtcbiAgfVxufVxuXG5jb25zdCByZXBsYWNlRW50aXRpZXNWYWx1ZSA9IGZ1bmN0aW9uKHZhbCl7XG5cbiAgaWYodGhpcy5vcHRpb25zLnByb2Nlc3NFbnRpdGllcyl7XG4gICAgZm9yKGxldCBlbnRpdHlOYW1lIGluIHRoaXMuZG9jVHlwZUVudGl0aWVzKXtcbiAgICAgIGNvbnN0IGVudGl0eSA9IHRoaXMuZG9jVHlwZUVudGl0aWVzW2VudGl0eU5hbWVdO1xuICAgICAgdmFsID0gdmFsLnJlcGxhY2UoIGVudGl0eS5yZWd4LCBlbnRpdHkudmFsKTtcbiAgICB9XG4gICAgZm9yKGxldCBlbnRpdHlOYW1lIGluIHRoaXMubGFzdEVudGl0aWVzKXtcbiAgICAgIGNvbnN0IGVudGl0eSA9IHRoaXMubGFzdEVudGl0aWVzW2VudGl0eU5hbWVdO1xuICAgICAgdmFsID0gdmFsLnJlcGxhY2UoIGVudGl0eS5yZWdleCwgZW50aXR5LnZhbCk7XG4gICAgfVxuICAgIGlmKHRoaXMub3B0aW9ucy5odG1sRW50aXRpZXMpe1xuICAgICAgZm9yKGxldCBlbnRpdHlOYW1lIGluIHRoaXMuaHRtbEVudGl0aWVzKXtcbiAgICAgICAgY29uc3QgZW50aXR5ID0gdGhpcy5odG1sRW50aXRpZXNbZW50aXR5TmFtZV07XG4gICAgICAgIHZhbCA9IHZhbC5yZXBsYWNlKCBlbnRpdHkucmVnZXgsIGVudGl0eS52YWwpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YWwgPSB2YWwucmVwbGFjZSggdGhpcy5hbXBFbnRpdHkucmVnZXgsIHRoaXMuYW1wRW50aXR5LnZhbCk7XG4gIH1cbiAgcmV0dXJuIHZhbDtcbn1cbmZ1bmN0aW9uIHNhdmVUZXh0VG9QYXJlbnRUYWcodGV4dERhdGEsIGN1cnJlbnROb2RlLCBqUGF0aCwgaXNMZWFmTm9kZSkge1xuICBpZiAodGV4dERhdGEpIHsgLy9zdG9yZSBwcmV2aW91c2x5IGNvbGxlY3RlZCBkYXRhIGFzIHRleHROb2RlXG4gICAgaWYoaXNMZWFmTm9kZSA9PT0gdW5kZWZpbmVkKSBpc0xlYWZOb2RlID0gT2JqZWN0LmtleXMoY3VycmVudE5vZGUuY2hpbGQpLmxlbmd0aCA9PT0gMFxuICAgIFxuICAgIHRleHREYXRhID0gdGhpcy5wYXJzZVRleHREYXRhKHRleHREYXRhLFxuICAgICAgY3VycmVudE5vZGUudGFnbmFtZSxcbiAgICAgIGpQYXRoLFxuICAgICAgZmFsc2UsXG4gICAgICBjdXJyZW50Tm9kZVtcIjpAXCJdID8gT2JqZWN0LmtleXMoY3VycmVudE5vZGVbXCI6QFwiXSkubGVuZ3RoICE9PSAwIDogZmFsc2UsXG4gICAgICBpc0xlYWZOb2RlKTtcblxuICAgIGlmICh0ZXh0RGF0YSAhPT0gdW5kZWZpbmVkICYmIHRleHREYXRhICE9PSBcIlwiKVxuICAgICAgY3VycmVudE5vZGUuYWRkKHRoaXMub3B0aW9ucy50ZXh0Tm9kZU5hbWUsIHRleHREYXRhKTtcbiAgICB0ZXh0RGF0YSA9IFwiXCI7XG4gIH1cbiAgcmV0dXJuIHRleHREYXRhO1xufVxuXG4vL1RPRE86IHVzZSBqUGF0aCB0byBzaW1wbGlmeSB0aGUgbG9naWNcbi8qKlxuICogXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBzdG9wTm9kZXMgXG4gKiBAcGFyYW0ge3N0cmluZ30galBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBjdXJyZW50VGFnTmFtZSBcbiAqL1xuZnVuY3Rpb24gaXNJdFN0b3BOb2RlKHN0b3BOb2RlcywgalBhdGgsIGN1cnJlbnRUYWdOYW1lKXtcbiAgY29uc3QgYWxsTm9kZXNFeHAgPSBcIiouXCIgKyBjdXJyZW50VGFnTmFtZTtcbiAgZm9yIChjb25zdCBzdG9wTm9kZVBhdGggaW4gc3RvcE5vZGVzKSB7XG4gICAgY29uc3Qgc3RvcE5vZGVFeHAgPSBzdG9wTm9kZXNbc3RvcE5vZGVQYXRoXTtcbiAgICBpZiggYWxsTm9kZXNFeHAgPT09IHN0b3BOb2RlRXhwIHx8IGpQYXRoID09PSBzdG9wTm9kZUV4cCAgKSByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgdGFnIEV4cHJlc3Npb24gYW5kIHdoZXJlIGl0IGlzIGVuZGluZyBoYW5kbGluZyBzaW5nbGUtZG91YmxlIHF1b3RlcyBzaXR1YXRpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSB4bWxEYXRhIFxuICogQHBhcmFtIHtudW1iZXJ9IGkgc3RhcnRpbmcgaW5kZXhcbiAqIEByZXR1cm5zIFxuICovXG5mdW5jdGlvbiB0YWdFeHBXaXRoQ2xvc2luZ0luZGV4KHhtbERhdGEsIGksIGNsb3NpbmdDaGFyID0gXCI+XCIpe1xuICBsZXQgYXR0ckJvdW5kYXJ5O1xuICBsZXQgdGFnRXhwID0gXCJcIjtcbiAgZm9yIChsZXQgaW5kZXggPSBpOyBpbmRleCA8IHhtbERhdGEubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgbGV0IGNoID0geG1sRGF0YVtpbmRleF07XG4gICAgaWYgKGF0dHJCb3VuZGFyeSkge1xuICAgICAgICBpZiAoY2ggPT09IGF0dHJCb3VuZGFyeSkgYXR0ckJvdW5kYXJ5ID0gXCJcIjsvL3Jlc2V0XG4gICAgfSBlbHNlIGlmIChjaCA9PT0gJ1wiJyB8fCBjaCA9PT0gXCInXCIpIHtcbiAgICAgICAgYXR0ckJvdW5kYXJ5ID0gY2g7XG4gICAgfSBlbHNlIGlmIChjaCA9PT0gY2xvc2luZ0NoYXJbMF0pIHtcbiAgICAgIGlmKGNsb3NpbmdDaGFyWzFdKXtcbiAgICAgICAgaWYoeG1sRGF0YVtpbmRleCArIDFdID09PSBjbG9zaW5nQ2hhclsxXSl7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGE6IHRhZ0V4cCxcbiAgICAgICAgICAgIGluZGV4OiBpbmRleFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfWVsc2V7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGF0YTogdGFnRXhwLFxuICAgICAgICAgIGluZGV4OiBpbmRleFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjaCA9PT0gJ1xcdCcpIHtcbiAgICAgIGNoID0gXCIgXCJcbiAgICB9XG4gICAgdGFnRXhwICs9IGNoO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRDbG9zaW5nSW5kZXgoeG1sRGF0YSwgc3RyLCBpLCBlcnJNc2cpe1xuICBjb25zdCBjbG9zaW5nSW5kZXggPSB4bWxEYXRhLmluZGV4T2Yoc3RyLCBpKTtcbiAgaWYoY2xvc2luZ0luZGV4ID09PSAtMSl7XG4gICAgdGhyb3cgbmV3IEVycm9yKGVyck1zZylcbiAgfWVsc2V7XG4gICAgcmV0dXJuIGNsb3NpbmdJbmRleCArIHN0ci5sZW5ndGggLSAxO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlYWRUYWdFeHAoeG1sRGF0YSxpLCByZW1vdmVOU1ByZWZpeCwgY2xvc2luZ0NoYXIgPSBcIj5cIil7XG4gIGNvbnN0IHJlc3VsdCA9IHRhZ0V4cFdpdGhDbG9zaW5nSW5kZXgoeG1sRGF0YSwgaSsxLCBjbG9zaW5nQ2hhcik7XG4gIGlmKCFyZXN1bHQpIHJldHVybjtcbiAgbGV0IHRhZ0V4cCA9IHJlc3VsdC5kYXRhO1xuICBjb25zdCBjbG9zZUluZGV4ID0gcmVzdWx0LmluZGV4O1xuICBjb25zdCBzZXBhcmF0b3JJbmRleCA9IHRhZ0V4cC5zZWFyY2goL1xccy8pO1xuICBsZXQgdGFnTmFtZSA9IHRhZ0V4cDtcbiAgbGV0IGF0dHJFeHBQcmVzZW50ID0gdHJ1ZTtcbiAgaWYoc2VwYXJhdG9ySW5kZXggIT09IC0xKXsvL3NlcGFyYXRlIHRhZyBuYW1lIGFuZCBhdHRyaWJ1dGVzIGV4cHJlc3Npb25cbiAgICB0YWdOYW1lID0gdGFnRXhwLnN1YnN0cmluZygwLCBzZXBhcmF0b3JJbmRleCk7XG4gICAgdGFnRXhwID0gdGFnRXhwLnN1YnN0cmluZyhzZXBhcmF0b3JJbmRleCArIDEpLnRyaW1TdGFydCgpO1xuICB9XG5cbiAgY29uc3QgcmF3VGFnTmFtZSA9IHRhZ05hbWU7XG4gIGlmKHJlbW92ZU5TUHJlZml4KXtcbiAgICBjb25zdCBjb2xvbkluZGV4ID0gdGFnTmFtZS5pbmRleE9mKFwiOlwiKTtcbiAgICBpZihjb2xvbkluZGV4ICE9PSAtMSl7XG4gICAgICB0YWdOYW1lID0gdGFnTmFtZS5zdWJzdHIoY29sb25JbmRleCsxKTtcbiAgICAgIGF0dHJFeHBQcmVzZW50ID0gdGFnTmFtZSAhPT0gcmVzdWx0LmRhdGEuc3Vic3RyKGNvbG9uSW5kZXggKyAxKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHRhZ05hbWU6IHRhZ05hbWUsXG4gICAgdGFnRXhwOiB0YWdFeHAsXG4gICAgY2xvc2VJbmRleDogY2xvc2VJbmRleCxcbiAgICBhdHRyRXhwUHJlc2VudDogYXR0ckV4cFByZXNlbnQsXG4gICAgcmF3VGFnTmFtZTogcmF3VGFnTmFtZSxcbiAgfVxufVxuLyoqXG4gKiBmaW5kIHBhaXJlZCB0YWcgZm9yIGEgc3RvcCBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30geG1sRGF0YSBcbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWdOYW1lIFxuICogQHBhcmFtIHtudW1iZXJ9IGkgXG4gKi9cbmZ1bmN0aW9uIHJlYWRTdG9wTm9kZURhdGEoeG1sRGF0YSwgdGFnTmFtZSwgaSl7XG4gIGNvbnN0IHN0YXJ0SW5kZXggPSBpO1xuICAvLyBTdGFydGluZyBhdCAxIHNpbmNlIHdlIGFscmVhZHkgaGF2ZSBhbiBvcGVuIHRhZ1xuICBsZXQgb3BlblRhZ0NvdW50ID0gMTtcblxuICBmb3IgKDsgaSA8IHhtbERhdGEubGVuZ3RoOyBpKyspIHtcbiAgICBpZiggeG1sRGF0YVtpXSA9PT0gXCI8XCIpeyBcbiAgICAgIGlmICh4bWxEYXRhW2krMV0gPT09IFwiL1wiKSB7Ly9jbG9zZSB0YWdcbiAgICAgICAgICBjb25zdCBjbG9zZUluZGV4ID0gZmluZENsb3NpbmdJbmRleCh4bWxEYXRhLCBcIj5cIiwgaSwgYCR7dGFnTmFtZX0gaXMgbm90IGNsb3NlZGApO1xuICAgICAgICAgIGxldCBjbG9zZVRhZ05hbWUgPSB4bWxEYXRhLnN1YnN0cmluZyhpKzIsY2xvc2VJbmRleCkudHJpbSgpO1xuICAgICAgICAgIGlmKGNsb3NlVGFnTmFtZSA9PT0gdGFnTmFtZSl7XG4gICAgICAgICAgICBvcGVuVGFnQ291bnQtLTtcbiAgICAgICAgICAgIGlmIChvcGVuVGFnQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0YWdDb250ZW50OiB4bWxEYXRhLnN1YnN0cmluZyhzdGFydEluZGV4LCBpKSxcbiAgICAgICAgICAgICAgICBpIDogY2xvc2VJbmRleFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGk9Y2xvc2VJbmRleDtcbiAgICAgICAgfSBlbHNlIGlmKHhtbERhdGFbaSsxXSA9PT0gJz8nKSB7IFxuICAgICAgICAgIGNvbnN0IGNsb3NlSW5kZXggPSBmaW5kQ2xvc2luZ0luZGV4KHhtbERhdGEsIFwiPz5cIiwgaSsxLCBcIlN0b3BOb2RlIGlzIG5vdCBjbG9zZWQuXCIpXG4gICAgICAgICAgaT1jbG9zZUluZGV4O1xuICAgICAgICB9IGVsc2UgaWYoeG1sRGF0YS5zdWJzdHIoaSArIDEsIDMpID09PSAnIS0tJykgeyBcbiAgICAgICAgICBjb25zdCBjbG9zZUluZGV4ID0gZmluZENsb3NpbmdJbmRleCh4bWxEYXRhLCBcIi0tPlwiLCBpKzMsIFwiU3RvcE5vZGUgaXMgbm90IGNsb3NlZC5cIilcbiAgICAgICAgICBpPWNsb3NlSW5kZXg7XG4gICAgICAgIH0gZWxzZSBpZih4bWxEYXRhLnN1YnN0cihpICsgMSwgMikgPT09ICchWycpIHsgXG4gICAgICAgICAgY29uc3QgY2xvc2VJbmRleCA9IGZpbmRDbG9zaW5nSW5kZXgoeG1sRGF0YSwgXCJdXT5cIiwgaSwgXCJTdG9wTm9kZSBpcyBub3QgY2xvc2VkLlwiKSAtIDI7XG4gICAgICAgICAgaT1jbG9zZUluZGV4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHRhZ0RhdGEgPSByZWFkVGFnRXhwKHhtbERhdGEsIGksICc+JylcblxuICAgICAgICAgIGlmICh0YWdEYXRhKSB7XG4gICAgICAgICAgICBjb25zdCBvcGVuVGFnTmFtZSA9IHRhZ0RhdGEgJiYgdGFnRGF0YS50YWdOYW1lO1xuICAgICAgICAgICAgaWYgKG9wZW5UYWdOYW1lID09PSB0YWdOYW1lICYmIHRhZ0RhdGEudGFnRXhwW3RhZ0RhdGEudGFnRXhwLmxlbmd0aC0xXSAhPT0gXCIvXCIpIHtcbiAgICAgICAgICAgICAgb3BlblRhZ0NvdW50Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpPXRhZ0RhdGEuY2xvc2VJbmRleDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgfS8vZW5kIGZvciBsb29wXG59XG5cbmZ1bmN0aW9uIHBhcnNlVmFsdWUodmFsLCBzaG91bGRQYXJzZSwgb3B0aW9ucykge1xuICBpZiAoc2hvdWxkUGFyc2UgJiYgdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICAvL2NvbnNvbGUubG9nKG9wdGlvbnMpXG4gICAgY29uc3QgbmV3dmFsID0gdmFsLnRyaW0oKTtcbiAgICBpZihuZXd2YWwgPT09ICd0cnVlJyApIHJldHVybiB0cnVlO1xuICAgIGVsc2UgaWYobmV3dmFsID09PSAnZmFsc2UnICkgcmV0dXJuIGZhbHNlO1xuICAgIGVsc2UgcmV0dXJuIHRvTnVtYmVyKHZhbCwgb3B0aW9ucyk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHV0aWwuaXNFeGlzdCh2YWwpKSB7XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICB9XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBPcmRlcmVkT2JqUGFyc2VyO1xuIl0sIm5hbWVzIjpbInV0aWwiLCJyZXF1aXJlIiwieG1sTm9kZSIsInJlYWREb2NUeXBlIiwidG9OdW1iZXIiLCJPcmRlcmVkT2JqUGFyc2VyIiwiY29uc3RydWN0b3IiLCJvcHRpb25zIiwiY3VycmVudE5vZGUiLCJ0YWdzTm9kZVN0YWNrIiwiZG9jVHlwZUVudGl0aWVzIiwibGFzdEVudGl0aWVzIiwicmVnZXgiLCJ2YWwiLCJhbXBFbnRpdHkiLCJodG1sRW50aXRpZXMiLCJhZGRFeHRlcm5hbEVudGl0aWVzIiwicGFyc2VYbWwiLCJwYXJzZVRleHREYXRhIiwicmVzb2x2ZU5hbWVTcGFjZSIsImJ1aWxkQXR0cmlidXRlc01hcCIsImlzSXRTdG9wTm9kZSIsInJlcGxhY2VFbnRpdGllc1ZhbHVlIiwicmVhZFN0b3BOb2RlRGF0YSIsInNhdmVUZXh0VG9QYXJlbnRUYWciLCJhZGRDaGlsZCIsImV4dGVybmFsRW50aXRpZXMiLCJlbnRLZXlzIiwiT2JqZWN0Iiwia2V5cyIsImkiLCJsZW5ndGgiLCJlbnQiLCJSZWdFeHAiLCJ0YWdOYW1lIiwialBhdGgiLCJkb250VHJpbSIsImhhc0F0dHJpYnV0ZXMiLCJpc0xlYWZOb2RlIiwiZXNjYXBlRW50aXRpZXMiLCJ1bmRlZmluZWQiLCJ0cmltVmFsdWVzIiwidHJpbSIsIm5ld3ZhbCIsInRhZ1ZhbHVlUHJvY2Vzc29yIiwicGFyc2VWYWx1ZSIsInBhcnNlVGFnVmFsdWUiLCJudW1iZXJQYXJzZU9wdGlvbnMiLCJ0cmltbWVkVmFsIiwidGFnbmFtZSIsInJlbW92ZU5TUHJlZml4IiwidGFncyIsInNwbGl0IiwicHJlZml4IiwiY2hhckF0IiwiYXR0cnNSZWd4IiwiYXR0clN0ciIsImlnbm9yZUF0dHJpYnV0ZXMiLCJtYXRjaGVzIiwiZ2V0QWxsTWF0Y2hlcyIsImxlbiIsImF0dHJzIiwiYXR0ck5hbWUiLCJvbGRWYWwiLCJhTmFtZSIsImF0dHJpYnV0ZU5hbWVQcmVmaXgiLCJ0cmFuc2Zvcm1BdHRyaWJ1dGVOYW1lIiwibmV3VmFsIiwiYXR0cmlidXRlVmFsdWVQcm9jZXNzb3IiLCJwYXJzZUF0dHJpYnV0ZVZhbHVlIiwiYWxsb3dCb29sZWFuQXR0cmlidXRlcyIsImF0dHJpYnV0ZXNHcm91cE5hbWUiLCJhdHRyQ29sbGVjdGlvbiIsInhtbERhdGEiLCJyZXBsYWNlIiwieG1sT2JqIiwidGV4dERhdGEiLCJjaCIsImNsb3NlSW5kZXgiLCJmaW5kQ2xvc2luZ0luZGV4Iiwic3Vic3RyaW5nIiwiY29sb25JbmRleCIsImluZGV4T2YiLCJzdWJzdHIiLCJ0cmFuc2Zvcm1UYWdOYW1lIiwibGFzdFRhZ05hbWUiLCJsYXN0SW5kZXhPZiIsInVucGFpcmVkVGFncyIsIkVycm9yIiwicHJvcEluZGV4IiwicG9wIiwidGFnRGF0YSIsInJlYWRUYWdFeHAiLCJpZ25vcmVEZWNsYXJhdGlvbiIsImlnbm9yZVBpVGFncyIsImNoaWxkTm9kZSIsImFkZCIsInRleHROb2RlTmFtZSIsInRhZ0V4cCIsImF0dHJFeHBQcmVzZW50IiwiZW5kSW5kZXgiLCJjb21tZW50UHJvcE5hbWUiLCJjb21tZW50IiwicmVzdWx0IiwiZW50aXRpZXMiLCJjZGF0YVByb3BOYW1lIiwicmF3VGFnTmFtZSIsImxhc3RUYWciLCJzdG9wTm9kZXMiLCJ0YWdDb250ZW50IiwicHVzaCIsImNoaWxkIiwidXBkYXRlVGFnIiwicHJvY2Vzc0VudGl0aWVzIiwiZW50aXR5TmFtZSIsImVudGl0eSIsInJlZ3giLCJjdXJyZW50VGFnTmFtZSIsImFsbE5vZGVzRXhwIiwic3RvcE5vZGVQYXRoIiwic3RvcE5vZGVFeHAiLCJ0YWdFeHBXaXRoQ2xvc2luZ0luZGV4IiwiY2xvc2luZ0NoYXIiLCJhdHRyQm91bmRhcnkiLCJpbmRleCIsImRhdGEiLCJzdHIiLCJlcnJNc2ciLCJjbG9zaW5nSW5kZXgiLCJzZXBhcmF0b3JJbmRleCIsInNlYXJjaCIsInRyaW1TdGFydCIsInN0YXJ0SW5kZXgiLCJvcGVuVGFnQ291bnQiLCJjbG9zZVRhZ05hbWUiLCJvcGVuVGFnTmFtZSIsInNob3VsZFBhcnNlIiwiaXNFeGlzdCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/fast-xml-parser/src/xmlparser/XMLParser.js":
/*!*****************************************************************!*\
  !*** ./node_modules/fast-xml-parser/src/xmlparser/XMLParser.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { buildOptions } = __webpack_require__(/*! ./OptionsBuilder */ \"(ssr)/./node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js\");\nconst OrderedObjParser = __webpack_require__(/*! ./OrderedObjParser */ \"(ssr)/./node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js\");\nconst { prettify } = __webpack_require__(/*! ./node2json */ \"(ssr)/./node_modules/fast-xml-parser/src/xmlparser/node2json.js\");\nconst validator = __webpack_require__(/*! ../validator */ \"(ssr)/./node_modules/fast-xml-parser/src/validator.js\");\nclass XMLParser {\n    constructor(options){\n        this.externalEntities = {};\n        this.options = buildOptions(options);\n    }\n    /**\n     * Parse XML dats to JS object \n     * @param {string|Buffer} xmlData \n     * @param {boolean|Object} validationOption \n     */ parse(xmlData, validationOption) {\n        if (typeof xmlData === \"string\") {} else if (xmlData.toString) {\n            xmlData = xmlData.toString();\n        } else {\n            throw new Error(\"XML data is accepted in String or Bytes[] form.\");\n        }\n        if (validationOption) {\n            if (validationOption === true) validationOption = {}; //validate with default options\n            const result = validator.validate(xmlData, validationOption);\n            if (result !== true) {\n                throw Error(`${result.err.msg}:${result.err.line}:${result.err.col}`);\n            }\n        }\n        const orderedObjParser = new OrderedObjParser(this.options);\n        orderedObjParser.addExternalEntities(this.externalEntities);\n        const orderedResult = orderedObjParser.parseXml(xmlData);\n        if (this.options.preserveOrder || orderedResult === undefined) return orderedResult;\n        else return prettify(orderedResult, this.options);\n    }\n    /**\n     * Add Entity which is not by default supported by this library\n     * @param {string} key \n     * @param {string} value \n     */ addEntity(key, value) {\n        if (value.indexOf(\"&\") !== -1) {\n            throw new Error(\"Entity value can't have '&'\");\n        } else if (key.indexOf(\"&\") !== -1 || key.indexOf(\";\") !== -1) {\n            throw new Error(\"An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'\");\n        } else if (value === \"&\") {\n            throw new Error(\"An entity with value '&' is not permitted\");\n        } else {\n            this.externalEntities[key] = value;\n        }\n    }\n}\nmodule.exports = XMLParser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmFzdC14bWwtcGFyc2VyL3NyYy94bWxwYXJzZXIvWE1MUGFyc2VyLmpzIiwibWFwcGluZ3MiOiI7QUFBQSxNQUFNLEVBQUVBLFlBQVksRUFBQyxHQUFHQyxtQkFBT0EsQ0FBQyw4RkFBa0I7QUFDbEQsTUFBTUMsbUJBQW1CRCxtQkFBT0EsQ0FBQyxrR0FBb0I7QUFDckQsTUFBTSxFQUFFRSxRQUFRLEVBQUMsR0FBR0YsbUJBQU9BLENBQUMsb0ZBQWE7QUFDekMsTUFBTUcsWUFBWUgsbUJBQU9BLENBQUM7QUFFMUIsTUFBTUk7SUFFRkMsWUFBWUMsT0FBTyxDQUFDO1FBQ2hCLElBQUksQ0FBQ0MsZ0JBQWdCLEdBQUcsQ0FBQztRQUN6QixJQUFJLENBQUNELE9BQU8sR0FBR1AsYUFBYU87SUFFaEM7SUFDQTs7OztLQUlDLEdBQ0RFLE1BQU1DLE9BQU8sRUFBQ0MsZ0JBQWdCLEVBQUM7UUFDM0IsSUFBRyxPQUFPRCxZQUFZLFVBQVMsQ0FDL0IsT0FBTSxJQUFJQSxRQUFRRSxRQUFRLEVBQUM7WUFDdkJGLFVBQVVBLFFBQVFFLFFBQVE7UUFDOUIsT0FBSztZQUNELE1BQU0sSUFBSUMsTUFBTTtRQUNwQjtRQUNBLElBQUlGLGtCQUFpQjtZQUNqQixJQUFHQSxxQkFBcUIsTUFBTUEsbUJBQW1CLENBQUMsR0FBRywrQkFBK0I7WUFFcEYsTUFBTUcsU0FBU1YsVUFBVVcsUUFBUSxDQUFDTCxTQUFTQztZQUMzQyxJQUFJRyxXQUFXLE1BQU07Z0JBQ25CLE1BQU1ELE1BQU8sQ0FBQyxFQUFFQyxPQUFPRSxHQUFHLENBQUNDLEdBQUcsQ0FBQyxDQUFDLEVBQUVILE9BQU9FLEdBQUcsQ0FBQ0UsSUFBSSxDQUFDLENBQUMsRUFBRUosT0FBT0UsR0FBRyxDQUFDRyxHQUFHLENBQUMsQ0FBQztZQUN2RTtRQUNGO1FBQ0YsTUFBTUMsbUJBQW1CLElBQUlsQixpQkFBaUIsSUFBSSxDQUFDSyxPQUFPO1FBQzFEYSxpQkFBaUJDLG1CQUFtQixDQUFDLElBQUksQ0FBQ2IsZ0JBQWdCO1FBQzFELE1BQU1jLGdCQUFnQkYsaUJBQWlCRyxRQUFRLENBQUNiO1FBQ2hELElBQUcsSUFBSSxDQUFDSCxPQUFPLENBQUNpQixhQUFhLElBQUlGLGtCQUFrQkcsV0FBVyxPQUFPSDthQUNoRSxPQUFPbkIsU0FBU21CLGVBQWUsSUFBSSxDQUFDZixPQUFPO0lBQ3BEO0lBRUE7Ozs7S0FJQyxHQUNEbUIsVUFBVUMsR0FBRyxFQUFFQyxLQUFLLEVBQUM7UUFDakIsSUFBR0EsTUFBTUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxHQUFFO1lBQ3pCLE1BQU0sSUFBSWhCLE1BQU07UUFDcEIsT0FBTSxJQUFHYyxJQUFJRSxPQUFPLENBQUMsU0FBUyxDQUFDLEtBQUtGLElBQUlFLE9BQU8sQ0FBQyxTQUFTLENBQUMsR0FBRTtZQUN4RCxNQUFNLElBQUloQixNQUFNO1FBQ3BCLE9BQU0sSUFBR2UsVUFBVSxLQUFJO1lBQ25CLE1BQU0sSUFBSWYsTUFBTTtRQUNwQixPQUFLO1lBQ0QsSUFBSSxDQUFDTCxnQkFBZ0IsQ0FBQ21CLElBQUksR0FBR0M7UUFDakM7SUFDSjtBQUNKO0FBRUFFLE9BQU9DLE9BQU8sR0FBRzFCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGhlLWdyaWQtMi8uL25vZGVfbW9kdWxlcy9mYXN0LXhtbC1wYXJzZXIvc3JjL3htbHBhcnNlci9YTUxQYXJzZXIuanM/MzU2ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB7IGJ1aWxkT3B0aW9uc30gPSByZXF1aXJlKFwiLi9PcHRpb25zQnVpbGRlclwiKTtcbmNvbnN0IE9yZGVyZWRPYmpQYXJzZXIgPSByZXF1aXJlKFwiLi9PcmRlcmVkT2JqUGFyc2VyXCIpO1xuY29uc3QgeyBwcmV0dGlmeX0gPSByZXF1aXJlKFwiLi9ub2RlMmpzb25cIik7XG5jb25zdCB2YWxpZGF0b3IgPSByZXF1aXJlKCcuLi92YWxpZGF0b3InKTtcblxuY2xhc3MgWE1MUGFyc2Vye1xuICAgIFxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpe1xuICAgICAgICB0aGlzLmV4dGVybmFsRW50aXRpZXMgPSB7fTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gYnVpbGRPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICBcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2UgWE1MIGRhdHMgdG8gSlMgb2JqZWN0IFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcn0geG1sRGF0YSBcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW58T2JqZWN0fSB2YWxpZGF0aW9uT3B0aW9uIFxuICAgICAqL1xuICAgIHBhcnNlKHhtbERhdGEsdmFsaWRhdGlvbk9wdGlvbil7XG4gICAgICAgIGlmKHR5cGVvZiB4bWxEYXRhID09PSBcInN0cmluZ1wiKXtcbiAgICAgICAgfWVsc2UgaWYoIHhtbERhdGEudG9TdHJpbmcpe1xuICAgICAgICAgICAgeG1sRGF0YSA9IHhtbERhdGEudG9TdHJpbmcoKTtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJYTUwgZGF0YSBpcyBhY2NlcHRlZCBpbiBTdHJpbmcgb3IgQnl0ZXNbXSBmb3JtLlwiKVxuICAgICAgICB9XG4gICAgICAgIGlmKCB2YWxpZGF0aW9uT3B0aW9uKXtcbiAgICAgICAgICAgIGlmKHZhbGlkYXRpb25PcHRpb24gPT09IHRydWUpIHZhbGlkYXRpb25PcHRpb24gPSB7fTsgLy92YWxpZGF0ZSB3aXRoIGRlZmF1bHQgb3B0aW9uc1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB2YWxpZGF0b3IudmFsaWRhdGUoeG1sRGF0YSwgdmFsaWRhdGlvbk9wdGlvbik7XG4gICAgICAgICAgICBpZiAocmVzdWx0ICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgIHRocm93IEVycm9yKCBgJHtyZXN1bHQuZXJyLm1zZ306JHtyZXN1bHQuZXJyLmxpbmV9OiR7cmVzdWx0LmVyci5jb2x9YCApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICBjb25zdCBvcmRlcmVkT2JqUGFyc2VyID0gbmV3IE9yZGVyZWRPYmpQYXJzZXIodGhpcy5vcHRpb25zKTtcbiAgICAgICAgb3JkZXJlZE9ialBhcnNlci5hZGRFeHRlcm5hbEVudGl0aWVzKHRoaXMuZXh0ZXJuYWxFbnRpdGllcyk7XG4gICAgICAgIGNvbnN0IG9yZGVyZWRSZXN1bHQgPSBvcmRlcmVkT2JqUGFyc2VyLnBhcnNlWG1sKHhtbERhdGEpO1xuICAgICAgICBpZih0aGlzLm9wdGlvbnMucHJlc2VydmVPcmRlciB8fCBvcmRlcmVkUmVzdWx0ID09PSB1bmRlZmluZWQpIHJldHVybiBvcmRlcmVkUmVzdWx0O1xuICAgICAgICBlbHNlIHJldHVybiBwcmV0dGlmeShvcmRlcmVkUmVzdWx0LCB0aGlzLm9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBFbnRpdHkgd2hpY2ggaXMgbm90IGJ5IGRlZmF1bHQgc3VwcG9ydGVkIGJ5IHRoaXMgbGlicmFyeVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIFxuICAgICAqL1xuICAgIGFkZEVudGl0eShrZXksIHZhbHVlKXtcbiAgICAgICAgaWYodmFsdWUuaW5kZXhPZihcIiZcIikgIT09IC0xKXtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVudGl0eSB2YWx1ZSBjYW4ndCBoYXZlICcmJ1wiKVxuICAgICAgICB9ZWxzZSBpZihrZXkuaW5kZXhPZihcIiZcIikgIT09IC0xIHx8IGtleS5pbmRleE9mKFwiO1wiKSAhPT0gLTEpe1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQW4gZW50aXR5IG11c3QgYmUgc2V0IHdpdGhvdXQgJyYnIGFuZCAnOycuIEVnLiB1c2UgJyN4RCcgZm9yICcmI3hEOydcIilcbiAgICAgICAgfWVsc2UgaWYodmFsdWUgPT09IFwiJlwiKXtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFuIGVudGl0eSB3aXRoIHZhbHVlICcmJyBpcyBub3QgcGVybWl0dGVkXCIpO1xuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIHRoaXMuZXh0ZXJuYWxFbnRpdGllc1trZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gWE1MUGFyc2VyOyJdLCJuYW1lcyI6WyJidWlsZE9wdGlvbnMiLCJyZXF1aXJlIiwiT3JkZXJlZE9ialBhcnNlciIsInByZXR0aWZ5IiwidmFsaWRhdG9yIiwiWE1MUGFyc2VyIiwiY29uc3RydWN0b3IiLCJvcHRpb25zIiwiZXh0ZXJuYWxFbnRpdGllcyIsInBhcnNlIiwieG1sRGF0YSIsInZhbGlkYXRpb25PcHRpb24iLCJ0b1N0cmluZyIsIkVycm9yIiwicmVzdWx0IiwidmFsaWRhdGUiLCJlcnIiLCJtc2ciLCJsaW5lIiwiY29sIiwib3JkZXJlZE9ialBhcnNlciIsImFkZEV4dGVybmFsRW50aXRpZXMiLCJvcmRlcmVkUmVzdWx0IiwicGFyc2VYbWwiLCJwcmVzZXJ2ZU9yZGVyIiwidW5kZWZpbmVkIiwiYWRkRW50aXR5Iiwia2V5IiwidmFsdWUiLCJpbmRleE9mIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/fast-xml-parser/src/xmlparser/XMLParser.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/fast-xml-parser/src/xmlparser/node2json.js":
/*!*****************************************************************!*\
  !*** ./node_modules/fast-xml-parser/src/xmlparser/node2json.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n/**\n * \n * @param {array} node \n * @param {any} options \n * @returns \n */ function prettify(node, options) {\n    return compress(node, options);\n}\n/**\n * \n * @param {array} arr \n * @param {object} options \n * @param {string} jPath \n * @returns object\n */ function compress(arr, options, jPath) {\n    let text;\n    const compressedObj = {};\n    for(let i = 0; i < arr.length; i++){\n        const tagObj = arr[i];\n        const property = propName(tagObj);\n        let newJpath = \"\";\n        if (jPath === undefined) newJpath = property;\n        else newJpath = jPath + \".\" + property;\n        if (property === options.textNodeName) {\n            if (text === undefined) text = tagObj[property];\n            else text += \"\" + tagObj[property];\n        } else if (property === undefined) {\n            continue;\n        } else if (tagObj[property]) {\n            let val = compress(tagObj[property], options, newJpath);\n            const isLeaf = isLeafTag(val, options);\n            if (tagObj[\":@\"]) {\n                assignAttributes(val, tagObj[\":@\"], newJpath, options);\n            } else if (Object.keys(val).length === 1 && val[options.textNodeName] !== undefined && !options.alwaysCreateTextNode) {\n                val = val[options.textNodeName];\n            } else if (Object.keys(val).length === 0) {\n                if (options.alwaysCreateTextNode) val[options.textNodeName] = \"\";\n                else val = \"\";\n            }\n            if (compressedObj[property] !== undefined && compressedObj.hasOwnProperty(property)) {\n                if (!Array.isArray(compressedObj[property])) {\n                    compressedObj[property] = [\n                        compressedObj[property]\n                    ];\n                }\n                compressedObj[property].push(val);\n            } else {\n                //TODO: if a node is not an array, then check if it should be an array\n                //also determine if it is a leaf node\n                if (options.isArray(property, newJpath, isLeaf)) {\n                    compressedObj[property] = [\n                        val\n                    ];\n                } else {\n                    compressedObj[property] = val;\n                }\n            }\n        }\n    }\n    // if(text && text.length > 0) compressedObj[options.textNodeName] = text;\n    if (typeof text === \"string\") {\n        if (text.length > 0) compressedObj[options.textNodeName] = text;\n    } else if (text !== undefined) compressedObj[options.textNodeName] = text;\n    return compressedObj;\n}\nfunction propName(obj) {\n    const keys = Object.keys(obj);\n    for(let i = 0; i < keys.length; i++){\n        const key = keys[i];\n        if (key !== \":@\") return key;\n    }\n}\nfunction assignAttributes(obj, attrMap, jpath, options) {\n    if (attrMap) {\n        const keys = Object.keys(attrMap);\n        const len = keys.length; //don't make it inline\n        for(let i = 0; i < len; i++){\n            const atrrName = keys[i];\n            if (options.isArray(atrrName, jpath + \".\" + atrrName, true, true)) {\n                obj[atrrName] = [\n                    attrMap[atrrName]\n                ];\n            } else {\n                obj[atrrName] = attrMap[atrrName];\n            }\n        }\n    }\n}\nfunction isLeafTag(obj, options) {\n    const { textNodeName } = options;\n    const propCount = Object.keys(obj).length;\n    if (propCount === 0) {\n        return true;\n    }\n    if (propCount === 1 && (obj[textNodeName] || typeof obj[textNodeName] === \"boolean\" || obj[textNodeName] === 0)) {\n        return true;\n    }\n    return false;\n}\nexports.prettify = prettify;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmFzdC14bWwtcGFyc2VyL3NyYy94bWxwYXJzZXIvbm9kZTJqc29uLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUE7Ozs7O0NBS0MsR0FDRCxTQUFTQSxTQUFTQyxJQUFJLEVBQUVDLE9BQU87SUFDN0IsT0FBT0MsU0FBVUYsTUFBTUM7QUFDekI7QUFFQTs7Ozs7O0NBTUMsR0FDRCxTQUFTQyxTQUFTQyxHQUFHLEVBQUVGLE9BQU8sRUFBRUcsS0FBSztJQUNuQyxJQUFJQztJQUNKLE1BQU1DLGdCQUFnQixDQUFDO0lBQ3ZCLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJSixJQUFJSyxNQUFNLEVBQUVELElBQUs7UUFDbkMsTUFBTUUsU0FBU04sR0FBRyxDQUFDSSxFQUFFO1FBQ3JCLE1BQU1HLFdBQVdDLFNBQVNGO1FBQzFCLElBQUlHLFdBQVc7UUFDZixJQUFHUixVQUFVUyxXQUFXRCxXQUFXRjthQUM5QkUsV0FBV1IsUUFBUSxNQUFNTTtRQUU5QixJQUFHQSxhQUFhVCxRQUFRYSxZQUFZLEVBQUM7WUFDbkMsSUFBR1QsU0FBU1EsV0FBV1IsT0FBT0ksTUFBTSxDQUFDQyxTQUFTO2lCQUN6Q0wsUUFBUSxLQUFLSSxNQUFNLENBQUNDLFNBQVM7UUFDcEMsT0FBTSxJQUFHQSxhQUFhRyxXQUFVO1lBQzlCO1FBQ0YsT0FBTSxJQUFHSixNQUFNLENBQUNDLFNBQVMsRUFBQztZQUV4QixJQUFJSyxNQUFNYixTQUFTTyxNQUFNLENBQUNDLFNBQVMsRUFBRVQsU0FBU1c7WUFDOUMsTUFBTUksU0FBU0MsVUFBVUYsS0FBS2Q7WUFFOUIsSUFBR1EsTUFBTSxDQUFDLEtBQUssRUFBQztnQkFDZFMsaUJBQWtCSCxLQUFLTixNQUFNLENBQUMsS0FBSyxFQUFFRyxVQUFVWDtZQUNqRCxPQUFNLElBQUdrQixPQUFPQyxJQUFJLENBQUNMLEtBQUtQLE1BQU0sS0FBSyxLQUFLTyxHQUFHLENBQUNkLFFBQVFhLFlBQVksQ0FBQyxLQUFLRCxhQUFh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ZXIvc3JjL3htbHBhcnNlci9ub2RlMmpzb24uanM/ZGZjZCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogXG4gKiBAcGFyYW0ge2FycmF5fSBub2RlIFxuICogQHBhcmFtIHthbnl9IG9wdGlvbnMgXG4gKiBAcmV0dXJucyBcbiAqL1xuZnVuY3Rpb24gcHJldHRpZnkobm9kZSwgb3B0aW9ucyl7XG4gIHJldHVybiBjb21wcmVzcyggbm9kZSwgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogXG4gKiBAcGFyYW0ge2FycmF5fSBhcnIgXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBcbiAqIEBwYXJhbSB7c3RyaW5nfSBqUGF0aCBcbiAqIEByZXR1cm5zIG9iamVjdFxuICovXG5mdW5jdGlvbiBjb21wcmVzcyhhcnIsIG9wdGlvbnMsIGpQYXRoKXtcbiAgbGV0IHRleHQ7XG4gIGNvbnN0IGNvbXByZXNzZWRPYmogPSB7fTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB0YWdPYmogPSBhcnJbaV07XG4gICAgY29uc3QgcHJvcGVydHkgPSBwcm9wTmFtZSh0YWdPYmopO1xuICAgIGxldCBuZXdKcGF0aCA9IFwiXCI7XG4gICAgaWYoalBhdGggPT09IHVuZGVmaW5lZCkgbmV3SnBhdGggPSBwcm9wZXJ0eTtcbiAgICBlbHNlIG5ld0pwYXRoID0galBhdGggKyBcIi5cIiArIHByb3BlcnR5O1xuXG4gICAgaWYocHJvcGVydHkgPT09IG9wdGlvbnMudGV4dE5vZGVOYW1lKXtcbiAgICAgIGlmKHRleHQgPT09IHVuZGVmaW5lZCkgdGV4dCA9IHRhZ09ialtwcm9wZXJ0eV07XG4gICAgICBlbHNlIHRleHQgKz0gXCJcIiArIHRhZ09ialtwcm9wZXJ0eV07XG4gICAgfWVsc2UgaWYocHJvcGVydHkgPT09IHVuZGVmaW5lZCl7XG4gICAgICBjb250aW51ZTtcbiAgICB9ZWxzZSBpZih0YWdPYmpbcHJvcGVydHldKXtcbiAgICAgIFxuICAgICAgbGV0IHZhbCA9IGNvbXByZXNzKHRhZ09ialtwcm9wZXJ0eV0sIG9wdGlvbnMsIG5ld0pwYXRoKTtcbiAgICAgIGNvbnN0IGlzTGVhZiA9IGlzTGVhZlRhZyh2YWwsIG9wdGlvbnMpO1xuXG4gICAgICBpZih0YWdPYmpbXCI6QFwiXSl7XG4gICAgICAgIGFzc2lnbkF0dHJpYnV0ZXMoIHZhbCwgdGFnT2JqW1wiOkBcIl0sIG5ld0pwYXRoLCBvcHRpb25zKTtcbiAgICAgIH1lbHNlIGlmKE9iamVjdC5rZXlzKHZhbCkubGVuZ3RoID09PSAxICYmIHZhbFtvcHRpb25zLnRleHROb2RlTmFtZV0gIT09IHVuZGVmaW5lZCAmJiAhb3B0aW9ucy5hbHdheXNDcmVhdGVUZXh0Tm9kZSl7XG4gICAgICAgIHZhbCA9IHZhbFtvcHRpb25zLnRleHROb2RlTmFtZV07XG4gICAgICB9ZWxzZSBpZihPYmplY3Qua2V5cyh2YWwpLmxlbmd0aCA9PT0gMCl7XG4gICAgICAgIGlmKG9wdGlvbnMuYWx3YXlzQ3JlYXRlVGV4dE5vZGUpIHZhbFtvcHRpb25zLnRleHROb2RlTmFtZV0gPSBcIlwiO1xuICAgICAgICBlbHNlIHZhbCA9IFwiXCI7XG4gICAgICB9XG5cbiAgICAgIGlmKGNvbXByZXNzZWRPYmpbcHJvcGVydHldICE9PSB1bmRlZmluZWQgJiYgY29tcHJlc3NlZE9iai5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkpIHtcbiAgICAgICAgaWYoIUFycmF5LmlzQXJyYXkoY29tcHJlc3NlZE9ialtwcm9wZXJ0eV0pKSB7XG4gICAgICAgICAgICBjb21wcmVzc2VkT2JqW3Byb3BlcnR5XSA9IFsgY29tcHJlc3NlZE9ialtwcm9wZXJ0eV0gXTtcbiAgICAgICAgfVxuICAgICAgICBjb21wcmVzc2VkT2JqW3Byb3BlcnR5XS5wdXNoKHZhbCk7XG4gICAgICB9ZWxzZXtcbiAgICAgICAgLy9UT0RPOiBpZiBhIG5vZGUgaXMgbm90IGFuIGFycmF5LCB0aGVuIGNoZWNrIGlmIGl0IHNob3VsZCBiZSBhbiBhcnJheVxuICAgICAgICAvL2Fsc28gZGV0ZXJtaW5lIGlmIGl0IGlzIGEgbGVhZiBub2RlXG4gICAgICAgIGlmIChvcHRpb25zLmlzQXJyYXkocHJvcGVydHksIG5ld0pwYXRoLCBpc0xlYWYgKSkge1xuICAgICAgICAgIGNvbXByZXNzZWRPYmpbcHJvcGVydHldID0gW3ZhbF07XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgIGNvbXByZXNzZWRPYmpbcHJvcGVydHldID0gdmFsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIFxuICB9XG4gIC8vIGlmKHRleHQgJiYgdGV4dC5sZW5ndGggPiAwKSBjb21wcmVzc2VkT2JqW29wdGlvbnMudGV4dE5vZGVOYW1lXSA9IHRleHQ7XG4gIGlmKHR5cGVvZiB0ZXh0ID09PSBcInN0cmluZ1wiKXtcbiAgICBpZih0ZXh0Lmxlbmd0aCA+IDApIGNvbXByZXNzZWRPYmpbb3B0aW9ucy50ZXh0Tm9kZU5hbWVdID0gdGV4dDtcbiAgfWVsc2UgaWYodGV4dCAhPT0gdW5kZWZpbmVkKSBjb21wcmVzc2VkT2JqW29wdGlvbnMudGV4dE5vZGVOYW1lXSA9IHRleHQ7XG4gIHJldHVybiBjb21wcmVzc2VkT2JqO1xufVxuXG5mdW5jdGlvbiBwcm9wTmFtZShvYmope1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICBpZihrZXkgIT09IFwiOkBcIikgcmV0dXJuIGtleTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NpZ25BdHRyaWJ1dGVzKG9iaiwgYXR0ck1hcCwganBhdGgsIG9wdGlvbnMpe1xuICBpZiAoYXR0ck1hcCkge1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhhdHRyTWFwKTtcbiAgICBjb25zdCBsZW4gPSBrZXlzLmxlbmd0aDsgLy9kb24ndCBtYWtlIGl0IGlubGluZVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGNvbnN0IGF0cnJOYW1lID0ga2V5c1tpXTtcbiAgICAgIGlmIChvcHRpb25zLmlzQXJyYXkoYXRyck5hbWUsIGpwYXRoICsgXCIuXCIgKyBhdHJyTmFtZSwgdHJ1ZSwgdHJ1ZSkpIHtcbiAgICAgICAgb2JqW2F0cnJOYW1lXSA9IFsgYXR0ck1hcFthdHJyTmFtZV0gXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9ialthdHJyTmFtZV0gPSBhdHRyTWFwW2F0cnJOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNMZWFmVGFnKG9iaiwgb3B0aW9ucyl7XG4gIGNvbnN0IHsgdGV4dE5vZGVOYW1lIH0gPSBvcHRpb25zO1xuICBjb25zdCBwcm9wQ291bnQgPSBPYmplY3Qua2V5cyhvYmopLmxlbmd0aDtcbiAgXG4gIGlmIChwcm9wQ291bnQgPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChcbiAgICBwcm9wQ291bnQgPT09IDEgJiZcbiAgICAob2JqW3RleHROb2RlTmFtZV0gfHwgdHlwZW9mIG9ialt0ZXh0Tm9kZU5hbWVdID09PSBcImJvb2xlYW5cIiB8fCBvYmpbdGV4dE5vZGVOYW1lXSA9PT0gMClcbiAgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnRzLnByZXR0aWZ5ID0gcHJldHRpZnk7XG4iXSwibmFtZXMiOlsicHJldHRpZnkiLCJub2RlIiwib3B0aW9ucyIsImNvbXByZXNzIiwiYXJyIiwialBhdGgiLCJ0ZXh0IiwiY29tcHJlc3NlZE9iaiIsImkiLCJsZW5ndGgiLCJ0YWdPYmoiLCJwcm9wZXJ0eSIsInByb3BOYW1lIiwibmV3SnBhdGgiLCJ1bmRlZmluZWQiLCJ0ZXh0Tm9kZU5hbWUiLCJ2YWwiLCJpc0xlYWYiLCJpc0xlYWZUYWciLCJhc3NpZ25BdHRyaWJ1dGVzIiwiT2JqZWN0Iiwia2V5cyIsImFsd2F5c0NyZWF0ZVRleHROb2RlIiwiaGFzT3duUHJvcGVydHkiLCJBcnJheSIsImlzQXJyYXkiLCJwdXNoIiwib2JqIiwia2V5IiwiYXR0ck1hcCIsImpwYXRoIiwibGVuIiwiYXRyck5hbWUiLCJwcm9wQ291bnQiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/fast-xml-parser/src/xmlparser/node2json.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/fast-xml-parser/src/xmlparser/xmlNode.js":
/*!***************************************************************!*\
  !*** ./node_modules/fast-xml-parser/src/xmlparser/xmlNode.js ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";
eval("\nclass XmlNode {\n    constructor(tagname){\n        this.tagname = tagname;\n        this.child = []; //nested tags, text, cdata, comments in order\n        this[\":@\"] = {}; //attributes map\n    }\n    add(key, val) {\n        // this.child.push( {name : key, val: val, isCdata: isCdata });\n        if (key === \"__proto__\") key = \"#__proto__\";\n        this.child.push({\n            [key]: val\n        });\n    }\n    addChild(node) {\n        if (node.tagname === \"__proto__\") node.tagname = \"#__proto__\";\n        if (node[\":@\"] && Object.keys(node[\":@\"]).length > 0) {\n            this.child.push({\n                [node.tagname]: node.child,\n                [\":@\"]: node[\":@\"]\n            });\n        } else {\n            this.child.push({\n                [node.tagname]: node.child\n            });\n        }\n    }\n}\nmodule.exports = XmlNode;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmFzdC14bWwtcGFyc2VyL3NyYy94bWxwYXJzZXIveG1sTm9kZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU1BO0lBQ0pDLFlBQVlDLE9BQU8sQ0FBRTtRQUNuQixJQUFJLENBQUNBLE9BQU8sR0FBR0E7UUFDZixJQUFJLENBQUNDLEtBQUssR0FBRyxFQUFFLEVBQUUsNkNBQTZDO1FBQzlELElBQUksQ0FBQyxLQUFLLEdBQUcsQ0FBQyxHQUFHLGdCQUFnQjtJQUNuQztJQUNBQyxJQUFJQyxHQUFHLEVBQUNDLEdBQUcsRUFBQztRQUNWLCtEQUErRDtRQUMvRCxJQUFHRCxRQUFRLGFBQWFBLE1BQU07UUFDOUIsSUFBSSxDQUFDRixLQUFLLENBQUNJLElBQUksQ0FBRTtZQUFDLENBQUNGLElBQUksRUFBRUM7UUFBSTtJQUMvQjtJQUNBRSxTQUFTQyxJQUFJLEVBQUU7UUFDYixJQUFHQSxLQUFLUCxPQUFPLEtBQUssYUFBYU8sS0FBS1AsT0FBTyxHQUFHO1FBQ2hELElBQUdPLElBQUksQ0FBQyxLQUFLLElBQUlDLE9BQU9DLElBQUksQ0FBQ0YsSUFBSSxDQUFDLEtBQUssRUFBRUcsTUFBTSxHQUFHLEdBQUU7WUFDbEQsSUFBSSxDQUFDVCxLQUFLLENBQUNJLElBQUksQ0FBRTtnQkFBRSxDQUFDRSxLQUFLUCxPQUFPLENBQUMsRUFBRU8sS0FBS04sS0FBSztnQkFBRSxDQUFDLEtBQUssRUFBRU0sSUFBSSxDQUFDLEtBQUs7WUFBQztRQUNwRSxPQUFLO1lBQ0gsSUFBSSxDQUFDTixLQUFLLENBQUNJLElBQUksQ0FBRTtnQkFBRSxDQUFDRSxLQUFLUCxPQUFPLENBQUMsRUFBRU8sS0FBS04sS0FBSztZQUFDO1FBQ2hEO0lBQ0Y7QUFDRjtBQUdBVSxPQUFPQyxPQUFPLEdBQUdkIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGhlLWdyaWQtMi8uL25vZGVfbW9kdWxlcy9mYXN0LXhtbC1wYXJzZXIvc3JjL3htbHBhcnNlci94bWxOb2RlLmpzP2I1OWYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jbGFzcyBYbWxOb2Rle1xuICBjb25zdHJ1Y3Rvcih0YWduYW1lKSB7XG4gICAgdGhpcy50YWduYW1lID0gdGFnbmFtZTtcbiAgICB0aGlzLmNoaWxkID0gW107IC8vbmVzdGVkIHRhZ3MsIHRleHQsIGNkYXRhLCBjb21tZW50cyBpbiBvcmRlclxuICAgIHRoaXNbXCI6QFwiXSA9IHt9OyAvL2F0dHJpYnV0ZXMgbWFwXG4gIH1cbiAgYWRkKGtleSx2YWwpe1xuICAgIC8vIHRoaXMuY2hpbGQucHVzaCgge25hbWUgOiBrZXksIHZhbDogdmFsLCBpc0NkYXRhOiBpc0NkYXRhIH0pO1xuICAgIGlmKGtleSA9PT0gXCJfX3Byb3RvX19cIikga2V5ID0gXCIjX19wcm90b19fXCI7XG4gICAgdGhpcy5jaGlsZC5wdXNoKCB7W2tleV06IHZhbCB9KTtcbiAgfVxuICBhZGRDaGlsZChub2RlKSB7XG4gICAgaWYobm9kZS50YWduYW1lID09PSBcIl9fcHJvdG9fX1wiKSBub2RlLnRhZ25hbWUgPSBcIiNfX3Byb3RvX19cIjtcbiAgICBpZihub2RlW1wiOkBcIl0gJiYgT2JqZWN0LmtleXMobm9kZVtcIjpAXCJdKS5sZW5ndGggPiAwKXtcbiAgICAgIHRoaXMuY2hpbGQucHVzaCggeyBbbm9kZS50YWduYW1lXTogbm9kZS5jaGlsZCwgW1wiOkBcIl06IG5vZGVbXCI6QFwiXSB9KTtcbiAgICB9ZWxzZXtcbiAgICAgIHRoaXMuY2hpbGQucHVzaCggeyBbbm9kZS50YWduYW1lXTogbm9kZS5jaGlsZCB9KTtcbiAgICB9XG4gIH07XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gWG1sTm9kZTsiXSwibmFtZXMiOlsiWG1sTm9kZSIsImNvbnN0cnVjdG9yIiwidGFnbmFtZSIsImNoaWxkIiwiYWRkIiwia2V5IiwidmFsIiwicHVzaCIsImFkZENoaWxkIiwibm9kZSIsIk9iamVjdCIsImtleXMiLCJsZW5ndGgiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/fast-xml-parser/src/xmlparser/xmlNode.js\n");

/***/ })

};
;